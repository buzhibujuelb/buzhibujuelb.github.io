{"meta":{"title":"Imperceptible","subtitle":"Never Settle","description":"A oier's personal blog","author":"不知不觉","url":"https://20021123.xyz","root":"/"},"pages":[{"title":"about","date":"2018-10-15T11:38:36.000Z","updated":"2022-07-12T17:35:56.000Z","comments":false,"path":"about/index.html","permalink":"https://20021123.xyz/about/index.html","excerpt":"","text":"你好=.= 我是来自CDQZUESTC的一名蒟蒻LB 请多多指教"},{"title":"404 Not Found：该页无法显示","date":"2025-01-10T11:13:04.134Z","updated":"2019-03-03T10:37:00.000Z","comments":false,"path":"/404.html","permalink":"https://20021123.xyz/404.html","excerpt":"","text":""},{"title":"分类","date":"2025-01-10T11:13:04.136Z","updated":"2019-03-03T10:37:00.000Z","comments":false,"path":"categories/index.html","permalink":"https://20021123.xyz/categories/index.html","excerpt":"","text":""},{"title":"fun","date":"2019-03-04T14:24:31.000Z","updated":"2025-01-11T16:39:04.694Z","comments":true,"path":"fun/index.html","permalink":"https://20021123.xyz/fun/index.html","excerpt":"","text":"Timmy bird Orz Jerome_wei Game Wall"},{"title":"书单","date":"2025-01-10T11:13:04.135Z","updated":"2019-03-03T10:37:00.000Z","comments":false,"path":"books/index.html","permalink":"https://20021123.xyz/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2025-01-10T11:13:04.147Z","updated":"2019-03-03T10:37:00.000Z","comments":true,"path":"links/index.html","permalink":"https://20021123.xyz/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2025-01-10T11:13:04.149Z","updated":"2019-03-03T10:37:00.000Z","comments":false,"path":"repository/index.html","permalink":"https://20021123.xyz/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2025-01-10T11:13:04.149Z","updated":"2019-03-03T10:37:00.000Z","comments":false,"path":"tags/index.html","permalink":"https://20021123.xyz/tags/index.html","excerpt":"","text":""},{"title":"tools","date":"2019-03-03T14:35:55.000Z","updated":"2019-03-03T15:10:24.000Z","comments":true,"path":"tools/index.html","permalink":"https://20021123.xyz/tools/index.html","excerpt":"","text":"Rand Graph Editer Paint"},{"title":"","date":"2025-01-10T17:11:22.368Z","updated":"2019-03-03T15:12:28.000Z","comments":true,"path":"tools/paint.html","permalink":"https://20021123.xyz/tools/paint.html","excerpt":"","text":"Line width:DecreaseIncrease Color:BlackWhiteRed UndoRedoClearSave Back var lstX=-1,lstY=-1,frames=Array(),frameNow=0,frameCnt=0; function clear(log){ if(typeof(log)==\"undefined\"){ log=1; } board.save(); board_dom.width=board_dom.width; board.restore(); if(log){ frames.push({type:'clearAll'}); frameCnt++; } } function drawAt(X,Y,color,width){ color=color||document.getElementById(\"cl\").value; width=width||drawWidth; board.fillStyle=color; board.strokeStyle=color; board.lineWidth=width; board.beginPath(); board.arc(X,Y,width*0.5,0,360,false); board.fill(); board.closePath(); if(lstX!=-1){ board.beginPath(); board.moveTo(lstX,lstY); board.lineTo(X,Y); board.stroke(); board.closePath(); } lstX=X,lstY=Y; } function drawEnd(){ lstX=-1,lstY=-1; } function clickAt(X,Y){ if(!frameNow)frameNow=Array(); frameNow.push([X,Y]); drawAt(X,Y); } function clickEnd(){ drawEnd(); if(frameNow) { lstX=-1,lstY=-1; while(frames.length>frameCnt)frames.pop(); frames.push({type:'brush',color:document.getElementById(\"cl\").value,width:drawWidth,frame:frameNow}); frameNow=0; frameCnt++; } } function doFrame(x){ if(x.type=='brush'){ for(var j=0;j0){ frameCnt--; clear(0); for(var i=0;i"},{"title":"","date":"2025-01-10T11:13:04.150Z","updated":"2022-12-25T20:02:02.000Z","comments":true,"path":"tools/rand.html","permalink":"https://20021123.xyz/tools/rand.html","excerpt":"","text":"Rand function RND(){ var a = document.getElementById(\"a\"); var b = document.getElementById(\"b\"); var mx = parseInt(a.value); var mn = parseInt(b.value); if(mx"}],"posts":[{"title":"计算机网络","slug":"计算机网络","date":"2023-06-28T15:27:14.000Z","updated":"2023-06-28T15:28:47.182Z","comments":true,"path":"2023/06/28/计算机网络/","link":"","permalink":"https://20021123.xyz/2023/06/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","excerpt":"","text":"第一章 计算机网络 一、Internet 计算机网络 两台以上具有独立操作系统的计算机通过某些介质连接成的相互共享软硬件资源的集合体。 计算机网络向用户提供的最重要的两大功能 连通性 共享 Internet 具体构成描述 数以亿计的计算互连设备 主机（host）=端系统（end system） 运行网络应用程序 通信链路 (link） 双绞线 光纤 , 无线电频谱 , 卫星 传输速率 = 带宽 (bandwidth） 分组（交换） 路由器（ Router ）和交换机（Switch） Internet 提供的服务 提供网络应用基础架构 允许终端系统上运行分布式应用程序，并彼此交换数据 Web, email, games, e commerce, database, VOIP, P2P file sharing 为分布式应用程序提供的 通信服务接口 无连接服务 connectionless 面向连接服务 connection oriented 不提供数据传递时间保证（发送端到接收端）的服务 协议 协议：定义了两个或多个通信实体间所交换报文的格式和次序 ，以及在报文发送和或接收或者其他事件方面所采取的行动（ 响应） 基本要素：语法、语义、同步 二、网络边缘部分 端系统、客户和服务器 端系统/主机 运行网络应用程序 处在网络的边缘 传统主机 网络计算机和瘦客户 客户/服务器 C/S 模型 客户请求，并接收服务器提供的服务 e.g. Web browser/server; email client/server 端对端模型 peer peer model: 极少或不采用专门服务器 e.g. Gnutella, KaZaA 物理介质 物理链路：在发送方和接受方间 传播位（ bit ）信号 导引型媒体：信号在固态介质中有向传播 , 如：光纤、双绞线和同轴电缆等 非导引型媒体：信号在大气空间或外太空空间自由传播，如无线电 三、网络核心部分 如何传输数据 电路交换 : 每次会话预留沿其路径（线路）所需的独占资源－电话网 分组交换 : 数据以离散的数据块通过网络来发送 电路交换 多路复用（Multiple Access）：在一条传输链路上同时建立多条连接，分别传输数据。 • 分片分配到会话 • 分片没有被会话使用的情况下，分片空载(不共享) • 电路级性能（有保证） • 要求呼叫建立－－建立一个专门的端到端 线路(意味着每个链路上预留一个线路) 链路带宽分片 频分－frequency division 时分－time division 例：已知文件长 640kb，传输速率 1.536Mb/s，每条链路使用 24 个时隙的 TDM，创建端到端电路 500ms，求发送文件的时间 解： 分组交换 分组交换也称为包交换， 每个分组通过一系列链路和分组交换机传送，直到目的端，在目的端在把接收到的分组， 按顺序 组装起来，恢复原报文。 每个 端到端的数据流被划分成分组 所有分组共享网络资源 每个分组使用全部链路带宽 资源按需使用 资源竞争 资源需求总量可以大于可获得资源的总量 拥塞: 采用分组队列 , 等待使用链路 存储转发: 分组每次转发 1 站 在 1 个链路上传输 每经过 1 个链路转发 1 次 转发分组前，要求收到完整分组 分类为 数据报网络 TCP/IP 分组目的地址决定下一跳 会话期间路由可以改变 比方 : 驱车逐段问路 虚电路网络：X.25,FR,ATM 每个分组有 1 个标签 虚电路号 ,virtual circuit ID), 标签决定下 1 跳 连接建立时确定固定的路径 , 并且将保持于整个会话期间 路由器必须为每个连接维护状态信息 四、Internet 结构组成 国家/国际级 ISP 区域级 ISP 本地 ISP 或接入 ISP 五、分组交换网络中的延迟、丢失和吞吐量 分组延迟分为 节点处理延时 检查错误位 选择输出链路 处理延迟——微秒级 排队时延 等待被发送到输出链路上的时间，取决于路由器拥塞速度 传输时延 发送分组比特流的时间 L：分组长度，R：链路带宽 传播时延 ：物理链路长度，：介质的信号传播速度 往返时延 RTT 从发送发发送数据开始到发送方收到来自接收方的确认经历的总时间 可用来判断网络的通断性、测试网络实验、计算丢包率等 排队时延 不同分组其排队时延不同 使用统计量测度：如平均排队时延、排队时延方差 排队时延大小取决于流量到达该队列的速率、链路传输速度和到达流量的性质 流量强度：比特到达队列的速率与比特从队列推出的速率比 流量强度 ：链路速率（bps） ：分组长度（比特） ：平均分组到达速率（每秒分组 pkt/s） ：平均排队时延小，几乎没有分组到达或间隔很大 ：分组陆续到达，形成队列，时延变大 ：更多“分组”到达，超出服务能力，平均时延无穷大 设计系统时需保证流量强度不大于 分组丢失 通常，一条链路的缓存队列容量有限。 分组丢失： 当到达的分组发现队列已满，没有空间存储，被丢弃 。 丢失的分组可能由前面的节点或由源端系统重传，或根本不重传。 吞吐量 网络吞吐量 单位时间内整个网络传输数据的速率或分组数 单位： bps 或 data packets per second 吞吐量 接收端接收到数据的比特速率 瞬时吞吐量、平均吞吐量 六、协议层及其服务模型 ISO/OSI 七层参考模型 层号 名称 英文 7 应用层 Application 6 表示层 Presentation 5 会话层 Session 4 传输层 Transport 3 网络层 Network 2 数据链路层 Data Link 1 物理层 Physical TCP/IP 参考模型 层号 名称 5 应用层 4 传输层 3 网络层 2 数据链路层 1 物理层 应用层（ application） 支持网络应用，报文传送 FTP, SMTP, STTP … 传输层（ transport） 主机进程间数据段传送 TCP, UDP 网络层（ network） 主机（源目标节点）间分组传送 主要是 IP 协议 , 路由协议 链路层（link） 相邻网络节点间数据帧传送 PPP, Ethernet 物理层 物理介质上的比特传送 逻辑通信 分布式 在各节点的网络实体(entities) 实现了各层的功能——主机实现 5 层功能，路由器和交换机实现 2-3 层功能。 网络实体完成功能动作, 对等实体交换消息 实体: 定义自身功能的硬/软件的集合 对等实体: 两台计算机上同一层所属的程序、进程或实体称为该层的对等程序、对等进程或对等实体 协议分层与数据 各层发方从上层到下层，收方从下层到上层传递数据 发方添加头部信息创建新的数据单元，收方去掉头部 传递新的数据单元到下层 上层 各层传送不同的协议数据单元 PDU image-20230625204807810 七、攻击威胁下的网络 植入恶意软件 病毒：潜伏，自我复制，破坏 蠕虫：主动在网络中传播的病毒 僵尸网络： 通过各种手段在大量计算机中植入特定的恶意程序，使控制者能够通过相对集中的若干计算机直接向大量计算机发 送指令的攻击网络。攻击者通常利用这样大规模的僵尸网络实施各种其他攻击活动。 攻击服务器和网络基础设施 拒绝服务攻击（ DoS 三种类型 弱点攻击 带宽洪泛 连接洪泛 嗅探分组 分组嗅探器：记录每个流经的分组拷贝的被动接收机 容易受到攻击的网络：无线网络和以太网 LAN 第二章 应用层 一、应用层协议原理 客户机/服务器体系结构 服务器 总是打开的主机 具有固定的、众所周知的IP地址 主机群集常被用于创建强大的虚拟服务器 客户机 同服务器端通信 可以间断的同服务器连接 可以拥有动态IP地址 客户机相互之间不直接通信 纯P2P体系结构 没有总是打开的服务器 任意一对主机直接相互通信 对等方间歇连接并且可以改变IP地址 例如：Gnutella 优点：自扩展性 缺点：难以管理 进程通信 进程：运行在端系统中的程序 同一主机上的两个进程通过内部进程通信机制进行通信 不同主机上的进程通过交换报文相互通信 进程与计算机网络的接口-套接字 进程通过它的套接字在网络上发送和接收报文 套接字类比于门户 发送进程把报文推出门户 发送进程假定门户到另外一侧之间有运输设施，该设施可以传送报文到接收进程 套接字又叫做应用程序编程接口API 用户通过API对传输层的控制仅限于： 选择传输协议; 能设定几个参数 主机上的进程标识包括 IP 地址和 端口号 常用应用程序的端口号： Web 服务： 80 邮件服务： 25 应用层协议 交换的 报文类型 ：如请求报文和应答报文 报文类型的语法： 报文中的各个字段及其详细描述 字段 的语义： 即包含在字段中的信息的含义 规则： 进程何时、如何发送报文及对报文进行响应 运输协议提供的服务 TCP 服务 面向连接 可靠传输 流量控制 拥塞控制 UDP 服务 不可靠传输 二、Web 应用和 HTTP 协议 HTTP 概述 网页（ Web 页，或称文档） 由许多对象组成。 对象就是文件，可以是 HTML 文件 , JPEG 图像 , Java applet, 音频文件 多数网页由单个基本 HTML 文件和若干个所引用的对象构成 每个对象被一个 URL (Uniform Resource Locator 统一资源定位符）寻址 使用 TCP 协议 客户初始化一个与 HTTP 服务器 80 端口的TCP 连接 创建套接字 HTTP 服务器接受来自客户的 TCP 连接请求 , 建立连接 Browser (HTTP client) 和 Web 服务器(HTTP server) 交换 HTTP 消息 应用层协议消息 包括 HTTP 请求和响应消息 最后结束（或叫 关闭 )TCP 连接 HTTP 连接 非持久HTTP 连接 每个 TCP 连接上只传送一个对象，下载多个对象需要建立 多个 TCP 连接 HTTP/1.0 使用非持久 HTTP 连接 持久 HTTP 连接 一个 TCP 连接上可以传送多个对象 HTTP/1.1 默认使用持久 HTTP 连接 响应时间模型 RTT：一个小分组从客户主机到服务器再到客户主机的时间 响应时间 一个 RTT 用于建立 TCP 连接 一个 RTT 用于 HTTP 请求/响应消息的交互 html 文件传输时间 持久 HTTP 连接 非流水线方式： 客户机只能在 前一个响应接收到之后才能发出新的请求。 客户机为每一个引用对象的请求和接收都使用一个 RTT 时延。 会浪费一些服务器资源：服务器在发送完一个对象，等待下一个请求时，会出现空闲状态。 流水线方式： 客户机可一个接一个 连续产生请求 （只要有引用就产生）即在前一个请求接收到响应之前可以产生新的请求。服务器一个接一个 连续发送响应对象 。 节省 RTT 时延， 可能所有引用对象 只花费一个 。 TCP 连接空闲时间很短。 默认方式： 流水线方式的持久连接。 方法类型 HTTP/1.0 GET POST HEAD HTTP/1.1 GET, POST, HEAD PUT DELETE Cookies Cookie 头部行在 HTTP 响应消息 Cookie 头部行在 HTTP 请求消息 Cookie 文件保存在用户主机上并由浏览器管理 Cookie 也保存在 Web 站点的后端数据库 Web 缓存（代理服务器） 目标：代表起始服务器满足 HTTP 请求 所有 HTTP 请求指向缓存 对象在缓存中：缓存器返回对象 否则缓存器向起始服务器发出请求，接收对象后转发给客户机 为什么需要Web 缓存器 减少对客户机请求的响应时间 减少内部网络与接入链路上的通信量 能从整体上大大降低因特网上的 Web 流量 三、文件传输协议 FTP client/server 模式 client: 发起传输的一方 server: 远程主机 ftp: RFC 959 ftp 服务器 : 端口号 21 FTP 客户首先发起建立 1 个与 FTP 服务器端口号 21 之间的 TCP 控制连接 ,指定 TCP 作为传输层协议 客户在建立的控制连接上获得身份认证 客户在建立的控制连接上发送命令来浏览远程主机的目录 当服务器接收到 1 个文件传输命令时 , 在服务器端口号 20 创建 1 个与客户的 TCP 数据连接 1 个文件传输后 服务器结束这个 TCP 数据连接 FTP 数据连接建立方式 主动模式 客户端发送 PORT 命令 PORT h1,h2,h3,h4,p1,p2（h1 h4 是 IP 地址， p1 p2 是端口号） 服务器根据 PORT 命令指定的客户端地址和端口号发起数据连接 被动模式 客户端发送 PASV 命令 服务器返回监听的地址和端口号 客户端发起数据连接 四、电子邮件协议 SMTP, POP3, IMAP 主要组成部分: 用户代理user agents 邮件服务器mail servers 简单邮件传送协议和邮件接收协议 用户代理： 允许用户阅读,回复,转发,保存,编辑邮件消息 例如：Outlook, foxmail等 发送, 接收邮件消息到/从服务器 运行邮件协议 邮件服务器 邮箱mailbox 存放用户接收的邮件消息 外出报文队列outgoing message queue 运行邮件协议 SMTP 端口号 25 命令/应答的交互 命令 ASCII 文本格式 应答 : 状态码及其短语 邮件消息必须是 7 bit ASCII 邮件消息的格式 信头－头部行。如： To: From: Subject: 这些头部不同于 SMTP 命令 信体 邮件消息也必须是 ASCII 多媒体拓展 MIME: Multipurpose Internet mail Extensions 多用途因特网邮件扩展, RFC 2045, 2046 增添额外的信头头部声明 MIME content type IMAP 邮件访问协议，从服务器获取邮件消息 端口号 143 更多功能特征(更复杂！) 允许用户像对待本地邮箱那样操纵远程邮箱的邮件 POP 端口号 110 Post Office Protocol 邮局协议[RFC 1939] 身份认证(代理&lt;--&gt;服务器) 并下载邮件消息 会话是无状态的 可选下载并保留/下载并删除 HTTP Hotmail , Yahoo! Mail, etc. 五、DNS 端口号 53 使用 UDP 分布式数据库 查询方法 迭代查询 被查询的名字服务器回复可以被查询的名字服务器的 IP 地址 递归查询 一旦 DNS 服务器获得 DNS 映射， 它将缓存该映射到局部内存 服务器在一定时间后将丢弃缓存的信息 本地 DNS 服务器可以缓存 TLD 服务器的 IP 地址 因此根 DNS 服务器不会被经常访问 第三章 传输层 一、传输层服务 在两个不同的主机上运行的应用程序之间提供逻辑通信。进程之间的逻辑通信 传输层协议运行在端系统 发送方：将应用程序报文分成数据段传递给网络层 接收方：将数据段重新组装成报文传递到应用层 运输层和网络层协议的作用范围不同，IP 协议提供主机间逻辑通信，TCP 等协议则是进程间逻辑通信。 不可用的服务: 时延保证 带宽保证 二、多路复用和多路分解 在接收主机多路分解 将接收到的数据段传递到正确的套接字（多路分解） 在发送主机多路复用 从多个套接字收集数据, 用首部封装数据，然后将报文段传递到网络层（多路复用） UDP UDP 套接字由两个因素 指定 目的 IP 地址 目的端口号 当主机收到 UDP 数据段 检查数据段中的目的端口号 用端口号指示 UDP 数据段属于哪个套接字 具有不同的源 IP 地址且 或源端口号，但具有相同的目的 IP 地址和目的端口号的 IP 数据报，指向同样的套接字 TCP TCP 套接字由 4 部分指定 : 源 IP 地址 源端口号 目的 IP 地址 目的端口号 接收主机使用所有四个值将数据段定位到合适的套接字 服务器主机可同时支持很多个 TCP 套接字 每个套接字用 4 部分来表示 以 Web 服务器为 例：对 每个连接的客户都有不同的套接字 非持久 HTTP 将对每个请求有一个不同的套接字 三、无连接传输 UDP UDP 只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和差错检测的功能。 虽然 UDP 用户数据报只能提供不可靠的交付，但 UDP 在某些方面有其特殊的优点。 UDP 是无连接的，即发送数据之前不需要建立连接。 UDP 使用尽最大努力交付，即不保证可靠交付，同时也不使用拥塞控制。 UDP 没有拥塞控制，很适合多媒体通信的要求。 UDP 支持一对一、一对多、多对一和多对多的交互通信。 UDP 的首部开销小，只有 8 个字节。 UDP 是面向报文的。发送方 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。 UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。 应用层交给 UDP 多长的报文， UDP 就照样发送，即一次发送一个报文。 接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，一次交付一个完整的报文。 应用程序必须选择合适大小的报文。 UDP 校验和 发送方： 将数据段（首部和数据）看成 16bit 的整数序列，末位不足 16bit 补零 校验和：数据段内容相加（高位溢出回卷），最终结果取反。 将校验和放入 UDP 的校验和域 接收方： 计算收到数据段的校验和 检查相加和是否全为 1： NO - 检测到错误 YES - 没有检测到错误，不代表没有错误 四、可靠传输原理 rdt1.0 假设：使用最完美可靠的通道情况 没有 bit 错误 没有分组丢失 发送方，接收方分离的 FSMs : 发送方发送数据到下层信道 接收方从下层信道接收数据 rdt2.0 假设：下层信道可能让传输分组中的 bit 受损 校验和将检测到 bit 错误 问题： 如何从错误中恢复 确认（ACKs）: 接收方明确告诉发送方 分组接收正确 否认 （NAKs）:接收方明确告诉发送方 分组接收出错 发送方收到 NAK 后重发这个分组 在 rdt2.0 的新机制 （在 rdt1.0 中没有的）: 差错检测 接收方反馈： 控制信息 （ACK，NAK） rcvr-&gt;sender FSM 多了 make_pkt(data, checksum) isNAK(rcvpkt) isACK(rcvpkt) rdt2.1：处理混乱的 ACK/NAK：加入序号（1bit），状态数乘 2。 image-20230626032450073 image-20230626032459815 rdt2.2：给 ACK 引入了序号，因此可以无需 NAK，只用 ACK。 image-20230626032424032 rdt3.0 因为 rdt 3.0 的分组序号在 0 和 1 之间交替，因此 rdt 3.0 有时被称为比特交替协议 假设：下层信道丢失报文，已有的设施不能完全进行处理。 方法：添加倒计时定时器。 由于 3.0 出现了 timeout，因此重传分组改在 timeout 执行。 所有 rdt 都为停等协议。 image-20230626032723873 Go Back N(GBN) 接收方仅发送累积 ACK 发送方超时重发：已发送但未被确认的报文。 设序号空间为 n，窗口大小为 。 “窗口”, 允许的连续未确认的报文 只有一个定时器记录最早的未确认报文的发送时间 ACK-only: 总是为正确接收的最高序号的分组发送 ACK。 可能生成重复的 ACKs 接收到失序分组： 丢弃（不缓冲） -&gt; 没有接收缓冲区！ 重发最高序号分组的 ACK image-20230626034807563 image-20230626034823204 Selective Repeat(SR) 接收方为每个分组发送单独的 ACK 必要时，缓冲报文， 最后按序提交给上层 发送方超时重发：超时的分组。 对每个没有确认的报文发送者都要启动一个定时器（每个未被确认的报文都有一个定时器） 设序号空间为 n，窗口大小为 （小于等于接受空间大小的一半） image-20230626034854710 五、面向连接传输 TCP TCP 概述 全双工数据： 同一个连接上的双向数据流 MSS: TCP 报文段中数据字段的最大长度，而 MSS 通常根据 MTU（最大链路层帧）来设置。 面向连接： 在数据交换前握手（交换控制信息） 初始化发送方和接收方的状态 流量控制🌊： 发送方不会淹没接收方 拥塞控制🚧： 根据网络的拥塞情况来确定。 TCP 在 IP 不可靠服务之上创建 rdt 服务 流水线技术处理报文段 累积确认 TCP 使用单个重发定时器，即所有已发出去未收到的报文使用一个定时器 触发重发： 超时事件 重复确认 image-20230626035128114 首部固定长度为 20 字节，\"首部长度\"字段为 4bit，以 4bytes 为单位。故 TCP 首部总长度为 20bytes～60bytes 不等（但是是 4bytes 的倍数）。 检验和：包括首部和数据两部分，计算检验和时，要在报文段（首部+数据，此时检验和为 0）前加 12 字节的伪首部（IPv4，IPv6 的是另一种伪首部），该伪首部有源 IP 地址、目的 IP 地址等信息。（具体信息应该不做要求） 序号： 数据段中第一个字节在数据流中的位置编号 确认号： 期望🤩从另外一边收到的下一个字节的序号 累积确认 估计时延 估计 RTT 样本 RTT（SampleRTT）样本 RTT 均值（EstimatedRTT），这里的具体数值为典型值。 估计安全余量 EstimtedRTT 加上 “安全余量” EstimatedRTT 变化大 -&gt; 更大的安全余量 根据 SampleRTT 偏离 EstimatedRTT 多少来估计 定时器 连接管理 三次握手建立连接 🙌客户端发送 SYN 请求建立连接，指定初始序号。 🤝服务器回复 SYN 和 ACK 同意连接，指定服务端初始序号。 ✉客户端回复 ACK 表示收到，可能包含数据。 四次挥手关闭连接： 客户端发送 FIN 请求关闭连接（不能发送只能接收数据了） 服务器回复 ACK 并进行扫尾工作（扫尾时还可以发送数据） 服务器回复 FIN 表示可以关闭了 客户端回复 ACK 表示收到，随后进入超时等待 可靠数据传输 流水线💦技术处理报文段 累积确认 重发： 超时 重复确认：收到 3 个对同样报文段的确认，则认为该报文段之后的数据丢失，启动快速重传：在定时器超时之前重发。 流量控制 接收方在 TCP 头部消息中 rwnd 字段\"通知\"发送方剩余缓存区大小 rwnd 为零的时候还会继续发送探测报 发送方限制🚦已发送但是未被确认的数据量不超过 rwnd： 六、拥塞控制原理 拥塞的原因和代价 场景：多个发送者/接收者，链路可靠，无限大缓存，分组的到达速率接近链路容量时 ， 分组经历巨大的排队时延。 有限缓冲区，假设连接可靠：丢失数据，需要重传，因此增加了许多不必要的重发，发送方必须执行重传以补偿因为缓存溢出而丢弃 （ 丢失 ） 的分组。 同上场景，发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本。 当一个分组沿一条路径被丢弃时 ， 每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了 。 拥塞控制的方法 端到端拥塞控制 没有从网络中得到明确的反馈 从端系统观察到的丢失和延迟推断出拥塞 TCP 采用的方法 网络辅助的拥塞控制 路由器给端系统提供反馈 单 bit 指示拥塞 (SNA, DECnet , TCP/IP ECN, ATM) 指明发送者应该发送的速率 七、TCP 拥塞控制 端到端控制 没有网络辅助 发送方限制发送 大体上 CongWin 是动态的, 感知的网络拥塞的函数 发送方如何感知拥塞 丢失事件 = 超时或者 3 个重复的 ACKs TCP 发送方在丢失事件发生后降低发送速率 CongWin 三个机制 慢启动 AIMD 对拥塞事件作出反应 连接开始时，cwnd（拥塞窗口） = 1 MSS ， ssthresh （slow start threshold）=64 KB 慢启动：以 2 的指数方式增加速率🚀，cwnd 达到 ssthresh 阈值时结束慢启动进入拥塞避免 情景：倘若 cwnd 此时为 2，阈值为 3，那么慢启动状态下，下一个 cwnd 为 3。 拥塞避免：线性增加速率🚲 （无论哪种状态）超时丢包：cwnd 变为 1mss ssthresh 阈值变为 cwnd 的一半，然后慢启动 （慢启动、拥塞避免）三次冗余 ACK 丢包（快速重传）： TCP Tahoe：和超时丢包相同 cwnd 变为 1mss ssthresh 变为 cwnd 的一半 TCP Reno：cwnd 减半加三 ssthresh 变为原来 cwnd 的一半（快速恢复） 快速恢复（TCP Reno 才有）：收到三个重复的确认则减半 +3。快速恢复状态每收到一个重复的 ACK 增加 MSS，若收到新的 ACK 则设置 ssthresh 阈值为当前窗口大小 cwnd 当 CongWin 低于阀值 , 发送方处于慢启动阶段 , 窗口指数增长 当 CongWin 高于阀值 , 发送方处于拥塞避免阶段 , 窗口线性增长 当三个重复的 ACK 出现时 阀值置为 CongWin /2 并且 CongWin 置为阀值加上 3 个 MSS 并进入快速恢复阶段，此时每收到一个重复的 ACK 拥塞窗口增加 1MSS ，如果收到新的 ACK 则拥塞窗口置成阀值） 当超时发生时 ，阀值置为 CongWin /2 并且 CongWin 置为 1 MSS. image-20230626041154412 第四章 网络层（数据平面） 一、网络层服务 主机之间的逻辑通信 数据平面实现的唯一功能：转发，将分组从一个输入链路接口转移到适当的输出链路接口。硬件实现 控制平面实现的功能：路由选择，确定分组从源到目的地所采取的端到端路径。软件实现 传输层和网络层提供的服务对比： Transport: 两个进程（process）之间 Network: 两台主机（host）之间 现在的因特网网络层并没有提供服务质量保证，因特网只提供了尽力而为的服务 二、虚电路和数据报网络 类比于 TCP/UDP 的面向连接 / 无连接的传输层服务： 任何网络中的网络层只提供两种服务之一，不会同时提供。 虚电路网络 ：提供连接服务。 数据报网络 虚电路不同于路由，其建立了固定的源至目的端的路径。 数据传输前，建立虚电路；传输完毕则拆除虚电路。 在源-目的路径上的每个路由器都需要维护相应的链路的状态信息形成转发表：输入链路 VC 号，输出链路 VC 号以完成转发，其中，不同链路的 VC 号可以不同。 一条 VC 的组成： 源-目的路径 VC 号，路径上每段链路一个 VC 号。 沿着该链路的每台路由器的转发表项。 每个 VC 上的分组都有当前的 VC 号，在经过不同链路时需要更新为相应的 VC 号。 三、路由器结构 路由器的两个核心功能： 运行路由算法 协议 (OSPF, RIP, BGP） 将分组从路由器的输入链路传送到正确的输出链路。 输入端口功能 线路端接：将物理链路段接到路由器的物理层 数据链路处理：实现路由器的数据链路层功能 查找与转发：实现查找与转发，以便分组通过路由器交换结构转发到适当的输出端口 交换结构 经内存交换 分组被拷贝到系统内存 速度受内存带宽限制（每个分组需要两次经过总线） 传统计算机，交换在 CPU 直接控制下完成。 经总线交换 分组从输入端口缓存经过一根共享总线到达输出端口缓存 通过标签来控制进入哪个输出端口。 总线竞争： 交换速率受总线带宽限制 经互联网络交换 克服总线带宽限制，非阻塞。 输出端口 取出存放在输出端口内存的分组，传输到输出链路上 当交换结构交付给输出端口的速率超过输出链路速率，就需要排队和缓存管理功能 排队 输入端口排队： 当交换速度比所有输入端口的综合速度慢时 此时产生 HOL（线头阻塞），排在队列前面的分组阻止队列中其他的分组向前移动。 输出端口排队：当分组从交换结构到达的速率快于输出链路速率时丢失 需要缓存，排队造成延迟 ，缓存溢出会导致分组丢失 四、IP 协议 IP 头部固定长度 20 字节 TCP 头部固定长度 20 字节 数据包长度：首部+数据，理论 IP 数据报最大长度为 65535 字节。 分片 &amp; 重组 一个链路层帧能承载的最大数据量叫做最大传输单元 （MTU），不同的链路类型有不同的 MTU， MTU 严格限制着 IP 数据报的长度。所以大的 IP 数据报在网络中被分片🐾，并只能在目的地进行重组。 IP 首部的一些 bit 用于标识和保证分片的顺序。 offset 偏移量 = 数据域长度 / 8 fragflag=0 标志比特改分片为原始数据报的最后一个片 ID 标识号：初始数据报的标识号。来判断不同的段是否属于同一个分组 IPv4 编址 IP 地址中前 5 位用于标识 IP 地址的类别 A 类地址的第一位为 0 B 类地址的前两位为 10 C 类地址的前三位为 110 D 类地址的前四位为 1110 E 类地址的前五位为 11110 。 其中 A 类 、 B 类与 C 类地址为基本的 IP 地址 。 IP 地址： 高位为网络部分，低位为主机部分。 准确来说，IP 地址与接口（主机和物理链路间的边界）关联，一个主机上有多个接口，因此一个主机可以有多个 IP 地址。 子网：设备接口的 IP 地址具有相同的网络部分，没有路由器的接入，物理上能够相互抵达。 具体定义：为了确定子网，分开主机和路由器的每个接口，从而产生了几个分离的网络岛🏝️，这些独立网络中的每一个叫做一个子网 A类（网络号8位）：1. 0. 0. 1 127.255.255.254 B类（网络号16位）：128.0.0.1 191.255.255.254 C类（网络号24位）：192.0.0.1 223.255.255.254 特殊 IP 地址段 本地回环地址 127.0.0.1-127.255.255.254 这是预留的一组 IP 地址，主要是用来识别主机本身的地址。也叫做 \"localhost\"，一般用来测试。 私有地址 Private address 10.x.x.x, 172.16.x.x-172.31.x.x, 192.168.x.x 这三个地址段被称为私有 IP 地址段 也就是局域网所使用的地址段，在公网上不能被路由 0.0.0.0 这个地址严格上来说都不是真正意义上的 IP 地址。主要是用来标识不清楚的网络和主机的。系统遇到无法识别的网络或主机的时候会统一的归纳到这个地址 255.255.255.255 这个地址是受限的广播地址。主要指一个网段内的所有主机 子网掩码 功能：给定 IP 地址和子网掩码，获得该 IP 地址主机所在的网络地址（或网络号） 步骤：IP 地址与子网掩码按位进行 AND 运算 IP 寻址 - CIDR （无类别域际路由选择） CIDR 是一种 IP 地址分配方法 地址中的网络部分可以任意长 地址格式： a.b.c.d/x， 这里 x 是地址网络部分的 bit 数 层次编址与路由聚合 路由聚合：使用单个网络前缀通告多个网络。 路由聚合后不包含的网络可以采用：添加更加具体的路由，利用最长前缀匹配实现路由跳转 网络地址转换 - NAT🎗️ 作用： 实现私有 IP 与公有 IP 之间的转换。 优点： 一个公有 IP 地址用于私有网络中所有设备。 在本地网络改变设备 IP 地址不用通知外部世界。 变更 ISP 而不用改变本地网络设备的地址。 本地网络设备不能被外部世界寻址（安全）。 16-bit 端口号： 一个局域网地址可以同时支持 60,000 个并发连接！ NAT 存在争议 路由器只应该处理到第三层 违反了端到端主张，应用程序设计者在设计时不得不将 NAT 加以考虑，如 P2P 应用程序 应使用 IPv6 来解决地址短缺问题💊 IPv6 初始目的： 32-bit 地址空间即将耗尽。 数据报格式： 首部固定长度 40 字节，无变动。 不允许分片 地址空间 128 位。 第五章 网络层（控制平面） 一、路由算法 路由算法确定了通过网络的端到端路径 转发表确定了在路由器上的本地转发 路由的基本概念 默认路由器：与主机直接相连的路由器，又叫第一跳路由器。每当主机发送一个分组时，都先传送给它的默认路由器。 源路由器：源主机的默认路由器。 目的路由器：目的主机的默认路由器。 从源主机到目的主机的选路归结为从源路由器到目的路由器的选路。 路由算法：是确定一个分组从源路由器到目的路由器所经路径的算法 路由算法的关键：在给定的一组路由器以及连接路由器的链路中，找到一条从源路由器到目的路由器的最低费用的路径。 最低费用路径： 该路径上 链路费用之和最小 。若所有链路的费用相同，则最低费用路径就是最短路径，即 在源和目的地之间经过链路最少的路径 。 路由算法分类 全局的还是分散的？ 全局 所有路由器都有完整的网络拓扑结构、链路开销信息 “链路状态”（LS）算法 分散 路由器知道物理相连的邻居和到邻居的开销 邻居间反复进行计算处理，交换信息 “距离矢量”（DV）算法 静态的还是动态的？ 静态 路由变化很慢，通常由人工进行设置 动态 路由变化很快： A. 周期性更新 B. 直接响应链路开销变化 链路状态算法 即 Dijkstra 算法，基本思想如下： 初始化：将源节点到其它各节点的距离设为无穷大，源节点到自身的距离为 0，所有节点的前驱节点设为无穷大或 NULL。 选择源节点：从源节点开始，先将源节点加入已确定最短路径的节点集合 S 中。 更新距离：遍历源节点的邻居节点，计算它们到源节点的距离，如果这个距离比已经记录的距离更短，则更新邻居节点的距离。同时更新邻居节点的前驱节点为源节点。 选择最短路径：从未确定最短路径的节点中，选择距离源节点最近的一个节点👋，并将其加入已确定最短路径的节点集合 S 中。 重复步骤 3 和 4，直到所有节点都被加入到已确定最短路径的节点集合 S 中为止，此时得到了源节点到其他所有节点的最短路径。 问题： 时间复杂度 存在拥塞敏感的路由选择振荡 构建最低费用路径树 根据 目的节点找出顺序 和其 费用 以及 前驱节点 ，可以画出源节点 u 到所有目的节点的 最低费用路径树。 根据得到的所有目的节点的完整路径，或最低费用路径树，可以生成源节点的转发表。 转发表： 存放从源节点到每个目的节点的最低费用 路径上的下一跳节点。 即指出对于发往某个目的节点的分组，从该节点发出后的下一个节点。 距离向量算法 距离向量路由算法是一种迭代的、异步的和分布式的算法。 分布式： 每个节点都 从其直接相连邻居接收信息 ，进行计算，再将 计算结果分发给邻居。 迭代： 计算过程一直持续到 邻居之间无更多信息交换为止。 异步： 不要求所有节点相互之间步伐一致地操作。 自我终结： 算法能自行停止。 Bellman-Ford 算法， 主要思想： 每个节点周期性⏳的给相邻节点发送自己的距离向量估值 当节点 x 从它的任何一个邻居 v 收到一个新的距离向量估值，就使用 B-F 方程更新自己的距离向量估值 在简单正常的情况下， 距离向量估值 Dx（y） 收敛到实际的最小路径开销 dx（y） B-F 方程📝： 节点x有多个邻居v，计算x到y的最短距离，即从所有邻居中选择一个v，使得x到v的距离加上v到y的距离最小。 c（x，v）是 x 到 v 的距离，是 v 到 y 的距离。 开销变化 好消息传得快✈️：开销减小的好消息能迅速传播到整个网络。 坏消息传得慢🚘：开销增大的坏消息会出现“计数到无穷”的问题。 解决方法：毒性逆转 假如 Z 通过 Y 到达 X ，Z 告诉 Y 它到 X 的距离是无穷大，Y 将不会再经过 Z 到 X 不能解决三个或三个以上节点的环路无法通过该方法解决 报文复杂性 收敛速度 健壮性 LS（链路状态） 具有 n 个节点，E 个链路情况，每次发送O(nE)个报文 O(n^2)，可能会导致振荡 每个节点只计算自己的转发表（一定的健壮性） DV（距离向量） 只在邻居之间交换报文 收敛时间是变化的，可能导致计数到无限的问题 每个节点的转发表可被其他节点使用 ，错误会扩散到整个网络 二、因特网中的路由协议 一个区域内的路由器组成集合“自治系统 （AS） ” 和其他自治系统直接相连的路由器称为网关路由器 不同自治系统内的路由协议可以不同 同一个自治系统的路由器运行相同的路由协议 区域内路由协议：同一自治系统的路由器运行相同的～协议。 区域间路由协议：由网关路由器运行（也运行域内协议），与其他网关路由器交互。 域内路由协议 - IGP 也被称为内部网关协议， 主要类别： RIP ， OSPF ， IGRP 路由信息协议 - RIP 本质上就是采用距离向量算法 周期性通过 UDP 报文发送 RIP 通告，端口号为 520 距离衡量： 跳数 （max = 15 hops） RIP 通告 距离向量： 每隔 30 秒，通过响应报文在邻居间进行交换（也被称为 RIP 通告， advertisement） 每个通告： 包含了多达 25 个 AS 内的目的子网的列表 开放最短路径优先 - OSPF 本质上就是采用链路状态（Dijkstra）算法，并使用了洪泛链路状态信息。 OSPF 的链路开销由网络管理员配置，每当一条链路状态发生变化，路由器广播链路状态信息。 OSPF 信息直接通过 IP 传输 （不是 TCP 或 UDP），因此必须自己实现可靠报文传输、链路状态广播等功能。 两级层次： 本地区域， 主干区域。（这些区域都是在一个自治系统内） 只在区域内发送链路状态通告 每个节点有详细的区域拓扑； 仅知道到达其他区域内网络的方向（即最短路径） 区域边界路由器（同时属于本地区域和主干区域）:“汇总”了到本区域内部网络的路径， 并通告给其他区域边界路由器。 主干路由器：限于在主干区域内运行 OSPF 路由协议。（本身不是区域边界路由器） 边界路由器： 连接到其他自治系统。 域间路由协议 - BGP 前面的域内路由协议决定在每个 AS（自治系统）内 IP 数据包怎么走，而 BGP 就是用来决定 AS 之间 IP 数据包怎么走。 BGP 为 AS 提供： 从邻居 AS 获得前缀的可达信息 确定到\"前缀\"（CIDR）最好的路由。 BGP 基础： 路由器之间（BGP 对等方）通过半永久 TCP 连接来交换选路信息：BGP 会话 BGP 会话和物理链路无关（并不总是和某条物理链路对应） 通告路由信息 网关路由器之间通过 eBGP 会话传递 域内路由器之间通过 iBGP 会话传递 路由选择 BGP 中，前缀+属性=路由。 在真实的网络中，从一个给定的路由器到一个目的子网可能有多条路径，这就需要我们从中选出最好的路由。 两个重要的 BGP 属性： AS-PATH : 包含通告已经通过的 AS 的列表，例如 AS1 通过 AS2 到达 AS3 中的子网 x，其AS-PATH为AS2 AS3 NEXT-HOP :是AS-PATH起始路由器接口的 IP 地址。 AS-PATH可以防止🔮环路。如当某台路由器发现 AS-PATH 中包含自身所在的 AS 时，则会拒绝该 BGP 通告。 区分域内和域外的原因 规模：层次路由节省了转发表的大小空间，减少了路由更新的流量。 策略： AS 间：管理员想控制本 AS 内产生的通信流怎样选路，以及什么通信流穿过自己的网络 AS 内：单个管理者，因此不需要策略 性能： AS 间：策略或许比性能更重要 AS 内：性能比较重要 三、SDN 软件定义网络 SDN SoftwareDefinedNetwork ）源自美国斯坦福大学 CLeanState 研究组提出的一种新型网络创新架构，可通过软件编程的形式定义和控制网络，具有控制平面和转发平面分离及开放性可编程的特点。 SDN 的核心理念是，希望应用软件可以参与对网络的控制管理，满足上层业务需求，通过自动化业务部署，简化网络运维。 SDN 并不是一个具体的技术，它是一种网络设计理念，规划了网络的各个组成部分（软件、硬件、转发面和控制面）及相互之间的互动关系。 第六章 链路层 一、链路层概述 数据链路层的职责是将数据报从一个节点传送到与该节点直接有物理链路相连的另一个节点。 节点：主机和路由器（包括网桥和交换机） 链路：沿着通信路径连接相邻节点的通信信道。包括：有线链路，无线链路，局域网。 帧：链路层协议交换的数据单元。 提供的服务： 封装成帧：把网络层数据加头（源 MAC 和目的 MAC 等等）加尾，封装成帧。 链路访问：媒体访问控制协议（MAC）规定了帧在链路上传输的规则，包括点对点链路和广播链路。 邻接节点之间可靠传输：通常用于易于产生高差错率的链路，例如无线链路。 传输层已经有了可靠数据传输，为何链路层也要可靠传输？ 链路层可靠传输目的是在链路上完成差错检测和纠正，而不是等数据传到端系统发现出错了，再进行数据重传等操作。 需要注意的是，链路层的可靠传输通过确认和重传等实现，这与以太网等提供的无比特差错传输还是有差别的。以太网受到差错帧直接丢包。 差错检测与纠错：差错由信号衰减和噪声引起。 流量控制 （PPT 写了但是我没听说过） 链路层在 “适配器” （网卡）中实现 Ethernet 卡，PCMCIA 卡， 802.11 卡 许多功能由硬件实现，高层链路层功能（组装链路层寻址信息等）通过软件实现。 二、差错检测和纠错 差错检测和纠正技术不能保证接收方检测到所有的比特差错，即 可能出现未检测到的比特差错 ，而接收方并未发现。 选择一个合适的差错检测方案使未检测到的情况发生的概率很小即可。 差错检测和纠错技术越好，越复杂，开销更大。 奇偶校验 最基本的方法。 一比特奇偶校验 发送方： 在要发送的信息 D d 位）后面 附加一个奇偶校验位使“ 1” 的个数是 奇数（奇校验） 或 偶数（偶校验） 一起传输发送（ d+1 位）。 接收方： 检测收到的信息（ d+1 位）中“ 1” 的个数。 偶校验： 发现奇数个“1”，至少有一个比特发生差错（奇数个比特差错）。 奇校验： 发现偶数个“1”，至少有一个比特发生差错 。 可以查出任意奇数个错误，但不能发现偶数个错误。 若比特差错概率很小，差错独立发生，一比特奇偶校验可满足要求。 若差错集中一起“突发”（突发差错），一帧中未检测到的差错的概率达到 50% 。 二维奇偶校验 将要传信息 D d 比特）划分为 i 行 j 列（ i 个组，每组 j 位） 对每行和每列分别计算奇偶值； 结果的 i+j+1 个奇偶比特构成了帧的差错检测比特。 可以检测并纠正单个比特差错 （数据或校验位中）。 能够检测但不能纠正分组中任意两个比特的差错 Internet 校验和 常用于运输层。 同 UDP 校验和 循环冗余检测 常用于链路层。 每个 CRC 标准能够检测少于 r+1 位的猝发错误和任意的奇数个比特错误 校验和通常应用于网络层及其之上的层次，要求简单快速的软件实现方式，而 CRC 通常应用于链路层，可以适配器硬件实现复杂的算法🎨。 当不通过 CRC 检测时（余数非零），链路层丢弃该帧（以太网）。 计算 CRC 比特流程： 假设除数 G 有 r+1 位，则在原始数据 D 之后补充 r 个 0，随后利用模 2 除法计算得到余数，余数就是所求 CRC 比特。 三、多路访问链路和协议 两种网络链路： 点对点链路：链路两端各一个节点。一个发送和一个接收。如点对点协议 PPP 。 广播链路： 多个节点连接到一个共享的广播信道。 广播： 任何一个节点传输一帧时，信号在信道上广播，其他节点都可以收到一个拷贝。常用于局域网 LAN 中，如早期的以太网和无线局域网。 信道划分 A. 时分 TDMA(time division multiple access） 每个节点轮流访问信道，只能在自己分配的时隙中使用信道，未被使用的时隙空闲 B. 频分 FDMA (frequency division multiple） 信道被分成不同频段，每个节点分配一个固定的频段，未被使用的频段空闲 C. 码分 CDMA 为节点分配一种不同的编码，使其能够同时传输且被正确接收。通常用于无线信道之中。 时分频分优缺点： 消除碰撞且公平 一个节点只能使用 R/N 的带宽，尽管是唯一一个有数据要发送的节点 随机接入 在随机接入协议中，一个传输节点总是以信道的全部速率（即 R bps）进行发送。当有碰撞时，涉及碰撞的每个节点反复地重发它的帧（也就是分组），到该帧无碰撞地通过为止。但是当一个节点经历一次碰撞时，它不必立刻重发该帧。相反，它在重发该帧之前等待一个随机时延。 效率 ：当有很多节点，每个节点有很多帧要发送时，成功时隙所占的百分比 A. 纯 Aloha 不按时隙划分，随机发送📢。 冲突后立即以概率 p 重发。 最高效率： B. 时隙 Aloha 时间划分为相同大小的时隙，一个时隙等于传送一个帧的时间。节点只能在一个时隙的开始才能传送。 冲突后，在下一个时隙以概率 p 重发。 最高效率： C. CSMA 载波侦听： 传送前侦听信道，如果信道空闲，传送整个帧； 如果信道忙，延迟传送。 存在问题： 由于传播延迟，可能导致两个节点没监听到其他节点的传送导致发生冲突，浪费带宽。 距离和传播延迟决定冲突概率。 D. CSMA/CD 在载波侦听的基础上加入 CD （冲突检测），优点是放弃会发生冲突的传送，减少带宽浪费。 基本思想： 当一个节点要发送数据时，首先监听信道，看是否存在载波。 如果信道空闲，则发送数据，如果信道忙，则继续监听，一旦发现空闲立即发送。 发送过程中未检测到碰撞，则传输成功；否则停止正常发送，反而发送一短暂的干扰信号 jam，强化冲突，让其他节点都知道出现了冲突。 发送干扰信号后，指数退避一随机时间。假设该帧经过 n 次冲突后，适配器在 中随机选取一个值 K，其中 ，然后等待 K*512 （以太网）比特时间后，回到第 b 步。 轮转 高负载 低负载 分割信道 信道共享，公平高效 延迟访问，如果只有一个活跃节点，只分配了 1/N 的带宽 随机访问 冲突开销大 效率高，单个节点可以获得整个信道 轮转协议是两者的折中 A. 轮询 从节点中选择一个作为主节点，主节点轮流向其他节点发送报文，告诉它能够传输帧的最大数量，待其传输完成后，再向下一个节点发送报文，依此类推。 缺点： 轮询开销：主节点要发送额外的报文 延迟访问：一个节点必须等待自己回合才能发送 主节点失效，整个网络失效 B. 令牌传递 一种称为令牌的特殊帧在节点之间以固定次序进行交换，当一个节点收到令牌时，它才能发送数据，发送完毕后将令牌传递给下一个。 缺点： 令牌开销 延迟访问 四、交换局域网 局域网： Local Area Network ( LAN ) 多址访问协议广泛应用于局域网 基于随机访问的 CSMA/CD 广泛应用于局域网 基于令牌传递技术的令牌环和 FDDI 在局域网技术中变得次要或被淘汰 链路层技术的发展，使得局域网、城域网、广域网的概念变得越来越模糊和不重要 MAC 地址 MAC 地址（ LAN 地址、物理地址） 节点“网卡”本身所带的地址（唯一）。 MAC 地址长度通常为 6 字节 (48 比特 )，共 个。 6 字节地址用 16 进制表示 ，每个字节表示为一对 16 进制数 网卡的 MAC 地址是 永久的 （生产时固化在其 ROM 里） 广播地址： FF-FF-FF-FF-FF-FF MAC 地址具有扁平结构，而且无论到哪都不会变化。类比身份证号。 IP 地址具有层次结构（分为网络和主机部分），会随着主机移动而改变。类比住址 DNS 域名系统： 将 主机名解析到 IP 地址 。 DNS 为在因特网中任何地方的主机解析主机名。 ARP 地址解析协议： 将 IP 地址解析到 MAC 地址 。 ARP 只为在 同一个 LAN 上的节点解析 IP 地址。 ARP ARP 工作原理（假设主机 A 向主机 B 发送）： 查询发送方的 ARP 表中是否存在目标 IP 的记录。如果存在则顺利完成解析。 如果 B 的 MAC 地址不在 A 的 ARP 表中，则 A 广播（即目标 MAC 地址为 FF-FF-FF-FF-FF-FF）包含 B 的 IP 地址的 ARP 查询包。在局域网上所有的机器都能收到 A 发送的 ARP 查询包。 主机 B 收到 ARP 查询包，发现是其中包含自己的 IP 地址，则单独发送一个带有自己 MAC 地址的包给 A。 A 收到后在自己的 ARP 表中缓存 IP-to-MAC 直到信息过期。 发送数据报到子网外 主机 A 构建 IP 数据报，源地址是 A 的 IP 地址，目的地址是 B 的 IP 地址 主机 A 构建链路层数据帧，目的 MAC 地址是路由器左边端口的 MAC 地址 image-20230626213810490 数据帧从主机 A 发送到路由器 R 路由器 R 收到数据帧，抽取出数据报递交到 IP 层 image-20230626213856058 路由器 R 转发数据报，源地址为 A 的 IP 地址，目的地址为 B 的 IP 地址 路由器 R 将该数据报封装成链路层帧，目的 MAC 地址为主机 B 的 MAC 地址 以太网 以太网的最大传输单元 MTU 是 1500 字节： 若 IP 数据报超过 1500 字节，必须将该数据报分段。 最小长度是 46 字节： 如果 IP 数据报小于 46 字节， 必须填充为 46 字节。 接收方网络层去除填充内容。 Preamble: 前同步码，8 个字节 前 7 个字节为 10101010，最后一个为 10101011 用于发送方和接收方的时钟同步 Addresses: MAC 地址，6 个字节 如果适配器收到的帧的目的地址与之匹配或者是一个广播地址（ARP 包），就把帧传给网络层 否则，抛弃该帧 Type: 类型，2 个字节， 指明可以支持的高层协议，主要是 IP 协议，也可以是其他协议如：Novell IPX 和 AppleTalk Data:46～1500 字节 CRC:循环冗余校验（帧校验序列），4 个字节。 接收方检测，如果有错，丢弃该帧 交换机 本处的交换机均指链路层交换机（与具有部分路由器功能的三层交换机区分） 链路层设备： 存储和转发以太网帧 检查帧头，并根据目的 MAC 地址有选择地转发帧 当 MAC 帧被转发到某一共享网段时，需要使用 CSMA/CD 访问该网段。 透明性 主机不关心交换机的存在 即插即用，自学习 交换机不需要被配置 自学习 交换机会学习通过哪些端口可以到达哪些主机 当收到数据帧时，交换机“学习”发送主机的位置：进入的局域网网段 到达端口 在转发表中记录发送主机/位置对 MAC addr Interface TTL A 1 60 过滤/转发 1234567if 目的MAC地址 in 交换表: if 目标MAC地址对应接口 == x: 丢弃该帧(过滤) # 不将同一网段的的帧转发到其他网段 else: 转发到指定接口else: 广播 两种交换方式 存储转发：具有差错检测功能，转发时延较大，适用于出错率高的链路。 快速分组又称直通交换：不具有差错检测功能，转发时延较小，适用于时延要求高，出错率低的链路。 VLAN 交换机将一个子网划分成若干个 LAN 网段 交换机过滤数据包： 同一 LAN 网段的数据帧传输不被转发到其它 LAN 网段 每个 LAN 网段变成一个独立的冲突域 交换机和路由器比较 都是存储转发设备 路由器：网络层设备，转发分组 交换机：数据链路层设备，转发帧 路由器实现路由算法建立路由表，并转发分组。网络层（IP）提供 TTL 等防止环路的措施。 交换机实现自学习包含交换表、转发/过滤，但不提供对广播风暴（错误配置导致环路，广播帧不断增多）的保护。","categories":[{"name":"总结","slug":"总结","permalink":"https://20021123.xyz/categories/%E6%80%BB%E7%BB%93/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://20021123.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://20021123.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"操作系统 第八章 磁盘存储器的管理","slug":"操作系统-第八章-磁盘存储器的管理","date":"2023-06-25T07:20:25.000Z","updated":"2023-06-25T07:20:19.280Z","comments":true,"path":"2023/06/25/操作系统-第八章-磁盘存储器的管理/","link":"","permalink":"https://20021123.xyz/2023/06/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%AE%A1%E7%90%86/","excerpt":"","text":"第八章 磁盘存储器的管理 一、外存的组织方式 1.1 连续组织方式 优点 顺序访问容易 顺序访问速度快 缺点 要为一个文件分配连续的存储空间，产生许多外部碎片，降低了外存空间利用率 必须事先知道文件长度 不能灵活增删记录 对于哪些动态增长的文件很难事先知道文件最终大小。及时事先知道，采用预分配存储空间的方法时，也会使大量存储空间长期空闲 1.2 链接组织方式 链接组织方式为文件分配多个不连续的盘块，在通过每个盘块上的连接指针将同属于一个文件的多个离散盘块连接成一个链表 消除了磁盘的外部碎片，提高外存利用率 增删改记录容易 能适应文件的动态增长 1. 隐式链接 文件目录的每个目录项中都含有指向链接文件第一盘块和最后一盘块的指针 只适合于顺序访问，对随机访问十分低效 可靠性差 2. 显式链接 将物理块指针显式存放在内存里的一张链接表中 分配给文件的所有盘块号都在该表中，又称为文件分配表 FAT 1.3 FAT 技术 略 1.4 NTFS 文件组织方式 以簇作文文件基本单位 1.5 索引组织方式 1. 单级索引组织方式 链接组织方式的问题 不能支持高效的直接存取 FAT 占用较大的内存空间，对于各文件的所有盘块号，需调入整个 FAT 才能找到其所有盘块号 索引分配方法为每个文件分配一个索引表，吧分配给该文件的所有盘块号都记录在该索引快中，建立文件时只需在为之建立的目录项填上指向该索引块的指针 主要优点是支持直接访问 主要问题是每当建立一个索引文件，应为该文件分配一个索引块，记录所有分配该文件的盘块号，对中小型文件对索引块的利用率较低 2. 多级索引组织方式 在为大文件分配磁盘空间时，若所分配的盘块的盘块号已经装满一个索引，则需再分配一个索引块……文件太大索引块太多时低效 引入多级索引 如果每个盘块大小 1KB，每个盘块号 4B，则一个索引块可存放 256 个盘块号 这样，二级索引时，最多存放文件的盘块号总数为 个，所允许的文件大小最大为 4MB 若盘块大小 4KB，则两级索引下最大文件长度为 3. 增量式索引组织方式 基本思想 为了全面照顾小中大及特大型作业，采取多重组织方式构成文件的物理结构 UNIX System V 的组织方式 索引节点有 13 个地址项，即 i.addr(0)~i.addr(12) 直接地址：10 个直接地址项，即 i.addr(0)~i.addr(9) 存放直接盘块号，即 direct blocks，当文件不大于 40KB 时可以直接读出 一次间址：i.addr(10) 提供一次间址，在一次间址块中存放 1K 个盘块号，允许文件长达 4MB 多次间址：i.addr(11) 提供二次间址，允许文件长达 i.addr(12) 提供三次间址，允许文件长达 二、文件存储空间的管理 2.1 空闲表法与空闲列表法 1. 空闲表法 空闲表：空闲表发属于连续分配方式，为每个文件分配一个连续的存储空间 存储空间的分配与回收：同样采用首次适应和最佳适应算法等 2. 空闲链表法 空闲盘块连 将磁盘上所有空闲空间以盘块为单位拉成一条链 每次请求分配空间时从链首开始摘下适当数目盘块分配给数目，删除文件时回收的盘块一次挂载末尾 优点是分配和回收一个盘块简单，但效率低，空闲盘块链长 空闲盘区链 所有空闲盘区拉成一条链，每个盘区除了指向下一个盘区的指针还有本盘区大小（盘块数）的信息 优缺点与上一种相反 2.2 位示图法 1. 位示图 用二进制的一位表示一个盘块的使用情况 1 2 3 4 5 6 7 8 1 1 1 0 0 0 1 1 0 2 0 1 0 0 0 0 1 0 ... 2. 盘块的分配 顺序扫描位示图，找出一个或一组值为 的二进制位 找到的一个或一组二进制位转换成相对应的盘块号 其中 表示每行位数 修改位示图，令 3. 盘块的回收 转盘块号为行列号 修改位示图，令 优点是很容易找到一个或一组相邻的空闲盘块 位数图很小，占用空间少，可以保存在内存中，节省了许多磁盘的启动操作","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://20021123.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://20021123.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统 第七章 文件管理","slug":"操作系统-第七章-文件管理","date":"2023-06-25T07:19:25.000Z","updated":"2023-06-25T07:19:52.379Z","comments":true,"path":"2023/06/25/操作系统-第七章-文件管理/","link":"","permalink":"https://20021123.xyz/2023/06/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/","excerpt":"","text":"第七章 文件管理 一、文件和文件系统 1.1 数据项、记录和文件 1. 数据项 数据项是文件系统中最低级的数据组织形式，可分为 基本数据项：是用于描述一个对象的某种属性的字符集，是数据组织中可以命名的最小逻辑数据单位，又称字段 组合数据项：有若干个基本数据项组成，简称组项 基本数据项除了数据名外还要有数据类型 数据项的名字和类型两者共同定义了一个数据项的“型” 表征一个实体在数据项上的数据则称为“值” 2. 记录 记录是一组相关数据项的集合，用于描述一个对象在某方面的属性 众多记录中，为了能唯一地标识一个记录，需要确定出一个或几个数据项，称它们的集合为“关键字” 通常只用一个数据项作为关键字 3. 文件 文件是由创建者定义的、具有文件名的一组相关元素的集合，可分为有结构文件和无结构文件两种 有结构文件中，文件由若干相关记录组成，无结构文件被看成是一个字符流 文件属性包括 文件类型 文件长度 文件的物理位置 文件的建立时间 1.2 文件名和类型 1. 文件名和拓展名 文件名：不同系统之间文件名规定不同。有的有长度限制，有的不允许空格，有的不区分大小写 拓展名：拓展名是添加在文件名后的若干附加字符，又称后缀名，用于指示文件类型。 2. 文件类型 常用分类方法 按用途分类 系统文件：允许用户调用但不允许读或修改；有的系统文件不直接对用户开放 用户文件 库文件：允许用户调用但不允许修改 按文件中数据的形式分类 源文件：源程序和数据构成的文件 目标文件：源程序编译后尚未链接目标代码的文件，后缀 .obj 可执行文件：编译后链接后的文件，后缀 .exe 按存取控制属性分类 只执行文件 只读文件 读写文件 按组织形式和处理方式分类 普通文件：由 ASCII 码或二进制码组成的字符文件 目录文件：由文件目录形成的文件 特殊文件：特指系统中各类 I/O 设备 1.3 文件系统的层次结构 分为三个层次 最底层是对象及其属性 中间层是对对象进行操纵和管理的软件集合 最高层是文件系统提供给用户的接口 1. 对象及其属性 文件系统管理的对象为 文件 目录 磁盘存储空间 2. 对对象操纵和管理的软件集合 对文件存储空间的管理 对文件目录的管理 用于将文件的逻辑地址转换为物理地址的机制 对文件读和写的管理 对文件的共享和保护功能 通常把文件系统有关的软件分为四层 I/O 控制层：磁盘驱动程序等组成，也称设备驱动程序层 基本文件系统层：用于处理内存与磁盘之间数据块的交换 基本 I/O 管理程序：用于完成与磁盘 I/O 有关的事务 逻辑文件系统：用于处理和记录文件相关的操作 3. 文件系统的接口 命令接口：作为用户与文件系统直接交互的接口，可通过键盘终端键入命令 程序接口：作为用户程序与文件系统的接口，可通过系统调用取得文件系统的服务 1.4 文件操作 1. 最基本的文件操作 创建文件 删除文件 读文件 写文件 设置文件的读/写位置 2. 文件的“打开”和“关闭”操作 避免多次重复检索目录，大多数 OS 中引入了“打开（open）”的系统调用 所谓打开，是指系统将指名文件的属性（包括文件在外存的物理位置）从外存拷贝到内从打开文件表的一个表目中，并将表目编号返回给用户。 当用户不需要对文件实施相应的操作时，可以用“关闭（close）”关闭文件。 3. 其他文件操作 对文件属性的操作，即允许用户直接设置和获得文件的属性，改变文件名、文件主、文件访问权、查询文件状态（文件类型、大小、拥有者、访问权）等 有关目录的操作：创建目录、删除目录、改变当前目录等 实现文件共享的系统调用 对文件系统进行操作的系统调用 二、文件的逻辑结构 所有文件都存在两种形式的文件结构 文件的逻辑结构：从用户观点触发观察到的文件形式，即文件时由一系列的逻辑记录组成的，是用户可以直接处理的数据及其结构，独立于文件的物理特性，又称文件组织 文件的物理结构：又称文件的存储结构，指系统将文件存储在外存上所形成的一种存储组成形式，对用户不可见。 2.1 文件逻辑结构的类型 1. 按文件是否有结构分类 有结构文件 在记录式文件中，每个记录都用于描述时提及重大一个实体，个记录有相同或不同数目的数据项 定长记录：文件中所有记录的长度相同，能有效提高检索记录的速度和效率，方便对文件处理和修改，广泛用于数据处理 变长记录：各记录的长度不同。可能是一个记录中所包含的数据项数目不相同如书的作者、论文的关键字；也可能是数据项本身长度不定。对可变长记录的检索速度满，不便修改，广泛用于商业领域 无结构文件 流式文件，长度以字节为单位，可以看成一个记录一个字节的记录式文件 2. 按文件的组织方式分类 顺序文件：由一系列纪录按某种顺序排列所形成的文件，记录可定长或变长 索引文件：为可变长记录建立一张索引表，为每个记录设置一个表项提高对记录的检索速度 顺序索引文件：前两者相结合的产物，为每个文件建立索引表时不是为一个记录一个索引表项，而是一组记录的第一个建立索引表项 2.2 顺序文件 1. 顺序文件的排列方式 串结构 顺序结构：由用户指定一个字段为关键字 2. 顺序文件的优缺点 最佳应用场合是对文件中的记录进行批量存取时 对于顺序存储设备（磁带）也只有顺序文件能被存储并有效工作 交互应用的场合效率差 增删记录比较困难，解决方法是配置一个运行记录文件或事务文件，每隔一段时间将其与原来的主文件合并 2.3 记录寻址 1. 隐式寻址方式 对于定长记录的顺序文件，直接读完后 写也一样 变长记录加上 即可， 是刚读完/写完的记录长度 2. 显式寻址方式 用于对定长记录的文件实现直接或随机访问 通过文件中记录的位置 对于可变长记录，假定每个记录前用一字节标记该记录长度，则 利用关键字：按照用户指定的关键字查找记录 2.4 索引文件 1. 按关键字建立索引 索引表按关键字排序，本身也是一个订场记录的顺序文件 可以用折半查找法查找 2. 具有多个索引表的索引文件 可以为不同的属性都配置一张索引表 索引文件的主要优点是将一个需要顺序查找的文件改造成一个可随机查找的文件，极大提高了文件的查找速度 只是需要配置一张索引表，增加了存储开销 2.5 索引顺序文件 1. 索引顺序文件的特征 索引顺序文件是对顺序文件的一中改进 它增加了文件索引表 增加了溢出文件，用来记录新增加的、删除的和修改的记录 2. 一级索引文件 首先将变长记录顺序文件中的所有记录分为若干组，然后为顺序文件建立一张索引表，每组第一个建立一个索引项 3. 两级索引顺序文件 对一个非常大的文件，可以为顺序文件设置多级索引，形成两级索引表 2.6 直接文件和哈希文件 1. 直接文件 采用前几种文件结构对记录进行存取都需根据给定的记录键值对线性表或链表进行检索 对于直接文件可以根据给定关键字直接获得指定记录的物理地址 2. 哈希文件 是目前应用最为广泛的直接文件，利用哈希函数将关键字转换为相应记录的地址 尉氏县动态分配，指向的是某一目录表响应表目的指针 三、文件目录 目录管理的要求为 实现“按名存取”：是目录管理中最基本的功能，也是文件系统提供最基本的服务 提高对目录的检索速度 文件共享：多用户系统中允许多用户共享一个文件 允许文件重名 3.1 文件控制块和索引节点 1. 文件控制块 FCB 基本信息 文件名 文件物理位置：存放文件的设备名、文件起始盘块号、盘块数或字节数的文件长度 文件逻辑结构：流式文件还是记录式文件、记录数，定长还是变长等 文件的物理结构：是顺序文件，链接式文件还是索引文件 存取控制信息类 文件主的存取权限，核准用户的存取权限，一般用户的存取权限 使用信息类 建立日期和事件 上次修改日期时间 当前使用信息 已打开该文件进程数 是否被锁住 是否在内存中被修改 2. 索引节点 索引节点的引入 文件目录通常存放在磁盘上，在检索目录文件中只用到了文件名，其他信息不需调入内存 所以在 UNIX 系统，将文件描述信息单独形成一个称为索引节点的数据结构，简称为 i 结点 文件目录项中每个目录项仅由文件名和指向该文件所对应的 i 结点指针构成 磁盘索引节点 文件主标识符 文件类型 文件存取权限 文件物理地址：iaddr(0)~iaddr(12) 以直接或间接方式给出数据文件所在盘块编号 文件长度 文件连接级数 文件存取时间 内存索引结点 索引节点编号 状态 访问 级数 文件所属文件系统的逻辑设备号 链接指针 3.2 简单的文件目录 1. 单机文件目录 优点是简单，但只能实现第一点按名存取 缺点为 查找速度满 不允许重名 不便于文件共享 2. 两级文件目录 主文件目录中，每个用户目录文件占有一个目录项，包括用户名和指向该用户目录文件的指针 提高了检索目录的速度 在不同的用户目录中可以使用相同文件名 不同用户可以使用不同的文件名访问系统中同一个共享文件 3.3 树形结构目录 1. 树形目录 最通用且实用 2. 路径名和当前目录 路径名 在树形结构目录中，从根目录到任何数据文件都只有一条唯一的通路 当前目录 可为每个进程设置一个“当前目录”又称“工作目录”，进程对各文件的访问都只需从当前目录开始 较两级目录而言，树形结构目录 查询速度更快 层次结构更清晰 能更有效进行文件的管理和保护 3. 目录操作 创建目录 删除目录 不删除非空目录 删除非空目录及其下所有子文件即目录 改变目录 移动目录 链接操作 查找 3.4 目录查询级数 1. 线性检索法 2. 哈希法 对于使用了模式匹配通配符“*”“？”等的文件名只能使用线性查找法 四、文件共享 4.1 基于有向无环图实现文件共享 1. 有向无环图 DAG 树形结构目录不适合文件共享 允许一个文件有多个父目录则可允许用户以对称的方式实现文件共享 2. 利用索引节点 文件的物理地址即其他属性不放在目录项中而是在索引节点中 4.2 利用符号链接实现文件共享 1. 符号链接的基本思量 允许一个文件由多个父目录，但其中仅有一个作为主（属主）父目录，其他的几个父目录通过符号链接方式与之相链接 好处是属主结构仍是简单树 2. 如何利用符号链接实现共享 由系统创建一个 LINK 类型的新文件，只包含路径名 3. 利用符号链接的优点 只有文件主才拥有指向其索引节点的指针，其他用户只用有该文件的路径名 不会发生在文件主删除共享文件后留下悬空指针的情况 4. 存在的问题 每次访问共享文件时都要多次度盘 还要为每个共享用户建立一条符号链，消耗磁盘空间 五、文件保护 影响文件安全性的因素有 人为因素 系统因素 自然因素 三方面的措施 存取控制机制 系统容错技术 后备系统 5.1 保护域 1. 访问权 把一个进程能对某对象进程操作的权利称为访问权 每个访问权可以用有序对（对象名，权集）表示，如 2. 保护域 保护域简称域，是进程对一组对象访问权的集合，进程只能在指定域内执行操作 3. 进程和域的静态关系 进程和域之间可以一一对应，此时在进程的整个生命周期中可用资源固定，这种域称为“静态域” 4. 进程和域的动态联系 进程和域也可以一对多，即一个阶段对应一个域，不同阶段的权限集不同 这称为动态联系方式，这种方式中应增设保护域切换功能 5.2 访问矩阵 1. 基本的访问矩阵 F1 F2 F3 F4 F5 F6 Printer 1 Printer 2 D1 R R,W D2 R R,W,E R,W W D3 R,W,E W W 2. 具有域切换权的访问矩阵 即存在 时才允许进程从域 切换到域 F1 F2 F3 F4 F5 F6 Printer 1 Printer 2 域D1 域D2 域D3 D1 R R,W S D2 R R,W,E R,W W S D3 R,W,E W W 5.3 访问矩阵的修改 1. 拷贝权 在 域中运行的进程能将其对对象 的访问权复制成在任何域中对同一对象的实现 2. 所有权 如果在 中包含所有访问权（O），则在 上运行的进程可以增删其他任何域中的进程对 的访问权 3. 控制权 控制权用于改变矩阵中某一行的各项访问权，即 中包含控制权，则 中运行的进程可以增删 中运行的进程对个对象的访问权 5.4 访问矩阵的实现 1. 访问控制表 由有序对（域，权集）组成的 由于矩阵空项远多于非空项，能显著提高查找速度 不少系统当对象是文件时边吧访问控制表放在该文件的文件控制表/索引节点中 2. 访问权限表 每一行可构成一张访问权限表，即一个域可对哪些对象执行的操作所构成的表 类型 权利 对象 文件 R-- 指向文件 3 的指针 打印机 -W- 指向打印机 1 的指针","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://20021123.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://20021123.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统 第六章 输入输出系统","slug":"操作系统-第六章-输入输出系统","date":"2023-06-25T07:19:25.000Z","updated":"2023-06-25T07:19:23.695Z","comments":true,"path":"2023/06/25/操作系统-第六章-输入输出系统/","link":"","permalink":"https://20021123.xyz/2023/06/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"第六章 输入输出系统 一、I/O 系统的功能、模型和接口 1.1 I/O 系统的基本功能 第一二方面是为了方便用户使用 第三四方面是提高 CPU 和 I/O 设备利用率 第五六方面是为用户在共享设备时提供方便，以保证系统有条不紊运行，发生错误是能及时发现甚至自动修正 1. 隐藏物理设备的细节 通过对设备加以适当的抽象，以隐藏掉物理设备的实现细节，仅向上层提供少量的，抽象的读/写命令 2. 与设备的无关性 用户不仅可以使用抽象的 I/O 命令，还可以使用抽象的逻辑设备名来使用设备 有效提高 OS 的可移植性和易适应性 3. 提高处理机和 I/O 设备的利用率 尽可能让处理机和 I/O 设备并行操作，以提高它们的利用率 一方面要求处理机能快速响应用户的 I/O 请求，使 I/O 设备尽快运行起来 另一方面减少在每个 I/O 设备运行时处理机的干预时间 4. 对 I/O 设备进行控制 目前的四种控制方式 采用轮询的可编程 I/O 方式 采用中断的可编程 I/O 方式 直接存储器访问 I/O 通道 5. 确保对设备的正确设备 系统中的设备可分为两类 独占设备，进程应互斥地访问这类设备。如打印机，磁带机 共享设备，一段时间内允许多个进程同时访问。如磁盘 6. 错误处理 临时性错误：重试操作 持久性错误：向上层报告 1.2 I/O 系统的层次结构和模型 1. I/O 软件的层次结构 用户层 I/O 软件，实现与用户交互的接口 设备独立性软件，用于实现用户程序与设备驱动器的统一接口、设备命名、设备保护以及设备的分配和释放等 设备驱动程序，与设备直接相关，用于具体实现系统对设备发出的操作指令 中断处理程序，用于保存被中断进程的 CPU 环境，转入相应的中断处理程序进行处理 2. I/O 系统中各种模块之间的层次试图 I/O 系统的上下接口 I/O 系统接口：是 I/O 系统与上层系统之间的接口，向上层提供对设备进行操作的抽象 I/O 命令，以方便高层对设备的使用 上层系统有文件系统、虚拟存储器系统以及用户进程等 软件/硬件接口：下面一个接口是软件/硬件接口，它的上面是中断处理程序和用于不同设备的设备驱动程序，它下面是各种设备的控制器 I/O 系统的分层 I/O 系统本身分为三个层次 中断处理程序 设备驱动程序 设备独立性软件 1.3 I/O 设备接口 1. 块设备接口 块设备：数据的存取与传输以数据块为单位，例如磁盘。基本特征是传输速率高，可寻址。磁盘 I/O 常用 DMA 方式 隐藏了磁盘的二维结构 将抽象命令映射为低层操作 2. 流设备接口 字符设备：数据的存取与传输以字符为单位，如键盘、打印机。基本特征是传输速率低，不可寻址。常采用中断驱动方式 get 和 put 操作：只能采取顺序存取方式。通常是建立一个字符缓冲区（队列），获取或输出字符的方式是采用 get 和 put 操作 in-control 指令：通常提供一种通用的指令，包含许多参数，表示一个与具体设备相关的特定功能 3. 网络通信接口 二、I/O 设备和设备控制器 2.1 I/O 设备 1. I/O 设备的类型 按使用特性分类 存储设备：用以存储信息 I/O 设备 输入设备：键盘、鼠标、扫描仪、摄像头 输出设备：打印机、绘图仪 交互式设备：显示器 按传输速率分类 低速设备：键盘、鼠标 中速设备：行式打印机、激光打印机 高速设备：磁带机、磁盘机、光盘机 2. 设备与控制器的接口 设备不直接与 CPU 通信，而是与设备控制器通信，在 I/O 设备与设备控制器的接口中通常有三种类型的信号，对应三条信号线 数据信号线 控制信号线 状态信号线 2.2 设备控制器 1. 设备控制器的基本功能 接收和识别命令 数据交换 标识和报告设备的状态 地址识别 数据缓冲区 差错控制 2. 设备控制器的组成 设备控制器与处理机调度接口 设备控制器与设备的接口 I/O 逻辑 2.3 内存映像 I/O 1. 利用特定的 I/O 指令 1Store cpu-reg,k 2. 内存映像 I/O 不再区分内存单元地址和设备控制器的寄存器地址 1Store cpu-reg,k 2.4 I/O 通道 1. I/O 通道的引入 I/O 通道是特殊的处理机，具有执行 I/O 指令的能力，并通过执行通道程序控制 I/O 操作，与一般处理的区别是 指令类型单一 通道没有自己的内存，与 CPU 共享 2. 通道类型 字节多路通道 数组选择通道 数组多路通道 3. “瓶颈”问题 增加设备到主机间的通路而不增加通道，即把一个设备连接到多个控制器上，一个控制器连接到多个通道上 不仅解决了瓶颈问题，还提高了系统可靠性 三、中断机构和中断处理程序 见计组 四、设备驱动程序 4.1 设备驱动程序概述 1. 设备驱动程序的功能 接收与设备无关的软件发来的命令和参数，将命令中的抽象要求转换为与设备相关的底层操作序列 检查用户 I/O 请求的合法性，了解 I/O 设备工作状态，传递 I/O 设备操作有关参数，设置设备工作方式 发出 I/O 命令 及时响应设备控制器传来的中断请求 2. 设备驱动程序的特点 驱动程序是实现在设备无关的软件和设备控制器之间通信和转换的程序， 驱动程序与设备控制器以及 I/O 设备的硬件特性紧密相关 驱动程序与 I/O 设备采用的控制方式紧密相关 由于驱动程序与硬件紧密相关，其中一部分必须用汇编语言书写。很多驱动程序已经固化在 ROM 中 驱动程序应允许重写入 3. 设备处理方式 每一类设备设置一个进程：适用于比较大的系统 整个系统中设置一个 I/O 进程；也可以设置一个输入进程一个输出进程 不设置专门的设备处理进程，只为各类设备设置相应的设备驱动程式，供系统用户进程调用 4.2 设备驱动程序的处理过程 抽象要求转为具体要求 对服务请求校验 检查设备状态 传递比快参数 启动 I/O 设备 多道程序系统中，驱动程序一旦发出一个 I/O 命令，启动了一个 I/O 操作后，驱动程序便把控制返回给 I/O 系统，阻塞自己直到中断到来。具体的 I/O 操作在设备控制器的控制下进行，所以设备忙于传送数据时，处理机可以干其他事，实现了处理机与 I/O 设备的并行操作 4.3 对 I/O 设备的控制方式 1. 轮询 2. 中断 3. DMA 4. 通道 五、与设备无关的 I/O 软件 设备独立性/设备无关性：应用程序中所用的设备，不局限于使用某个具体的物理设备 为实现设备独立性，必须在设备驱动程序之上设置一层软件，称为与设备无关的 I/O 软件，或设备独立性软件 5.1 与设备无关软件的基本概念 1. 以物理设备名使用设备 2. 引入了逻辑设备名 可实现 I/O 重定向 3. 逻辑设备名称到物理设备名称的转换 系统中必须具有将逻辑设备名称转换为某物理设备名称的功能 5.2 与设备无关的软件 1. 设备驱动程序的统一接口 要求每个设备驱动程序与 OS 只有有相同或相近的接口 要将抽象的设备名映射到具体的驱动程序上 对设备进行保护，禁止无权访问 2. 缓冲管理 单缓、多缓、等 3. 差错控制 4. 对独立设备的分配与回收 5. 提供独立于设备的块大小 5.3 设备分配 1. 设备分配中的数据结构 设备控制表 DCT 控制器控制表、通道控制表、系统设备表 2. 设备分配时考虑的因素 设备的固有属性 独占设备的分配策略 共享设备的分配策略 虚拟设备的分配策略 设备分配算法 先来先服务 优先级高者先 设备分配中的安全性 3. 独占设备的分配程序 5.4 逻辑设备名到物理设备名映射的实现 1. 逻辑设备表 LUT 2. 逻辑设备表的涉笔问题 整个系统一张：单用户系统 每个用户一张 六、用户层的 I/O 软件 6.1 系统调用与库函数 1. 系统调用 当应用程序需要执行某种 I/O 操作时，在应用程序中使用相应的系统调用。当 OS 捕获到系统调用后，将 CPU 从用户态切换为核心态，转向操作系统中相应过程，由该过程完成所需 I/O 操作。执行完毕后 CPU 从核心态转为用户态，返回应用程序继续执行 2. 库函数 C 语言中有对文件和设备进行访问的库函数，检查设备状态的库函数等 6.2 假脱机（Spooling）系统 1. 假脱机技术 外围操作与 CPU 对数据的操作同时进行，这种在联机情况下实现的同时外围操作的技术称为 SPOOLing 技术 2. SPOOLing 的组成 SPOOLing 系统建立在通道技术和多道程序技术的基础上，以高速随机外存（磁盘）为后援存储器 输入井与输出井 输入缓冲区和输出缓冲区 输入进程和输出进程 井管理程序 3. SPOOLing 系统的特点 提高了 I/O 速度 将独占设备改为共享设备 实现了虚拟设备功能 4. 假脱机打印机系统 5. 守护进程 守护进程是允许使用该独占设备的唯一进城，所有其他进程不能直接使用该设备，而是将对该设备的使用要求写入一份文件中，放在假脱机目录。由守护进程按照目录中的文件依次完成诸设备的请求 七、缓冲区管理 7.1 缓冲的引入 缓和 CPU 和 I/O 设备间速度不匹配的矛盾 降低对 CPU 的中断频率，放宽对 CPU 中断响应时间的限制 解决数据粒度不匹配的问题 提高 CPU 和 I/O 设备的并行性 7.2 单缓冲区与双缓冲区 1. 单缓冲区 2. 双缓冲区 由于缓冲区是共享资源，生产者和消费者使用时必须互斥 如果为生产者和消费者设置两个缓冲区便能解决这一问题 在实现两台机器之间的通信时单缓冲只能实现任一时刻单方面的数据传输。双向缓冲区可以一个用作发送缓冲区一个用作接收缓冲区 7.3 环形缓冲区 略 7.4 缓冲池 缓冲区仅仅是一组内存块的链表，而缓冲池则是包含了一个管理的数据结构及一组操作函数的管理机制，用于管理多个缓冲区 八、磁盘存储器的性能和调度 8.1 磁盘性能简述 1. 数据的组织和格式 磁盘上能存储的物理记录块数目是由扇区数、磁道数和磁盘面数决定的 双面可存储盘片 存储面（盘面） 磁道（柱面） 2. 磁盘的类型 固定头磁盘：可并行读写，有效提高 I/O 速度，用于大容量磁盘 移动头磁盘：仅能串行方式读写，中小型磁盘 3. 磁盘访问时间 寻道时间 ：把磁臂（磁头）移动到指定磁道上所经历的时间，由启动磁臂的时间 与磁头移动 条磁道所花费的时间之和，即 其中 是常数，与磁盘驱动器的速度有关，一般 ，高速磁盘 ，磁盘的启动时间 约为 ，一般来说寻道时间为 旋转延迟时间 ：指定扇区移动到磁头下面所经历的时间，不同磁盘速度相差很大 对于硬盘转速 ，则每转需 ，平均旋转延迟时间 传输时间 ：把数据从磁盘读出想磁盘写入数据所经历的时间，与每次读写的字节数 和旋转速度有关 其中 为每秒转数； 为一条磁道上的字节数，当一次读写的字节数相当于半条磁道上的字节数时，，因此访问时间 可表示为 8.2 早期的磁盘调度算法 1. 先来先服务（FCFS） 2. 最短寻道时间优先（SSTF） 每次找最近的 8.3 基于扫描的磁盘调度算法 1. 扫描（SCAN）算法 又称电梯调度算法，自里向外时只找外面的最近的，到了最外面再向里扫描 性能良好，防止饥饿 2. 循环扫描（CSCAN）算法 规定磁头单向移动，例如只是从里向外移动，移到最外的磁道并访问后，磁头立即返回最里的欲访问磁道 3. NStepSCAN 和 FSCAN 调度算法 NStepSCAN 算法 防止某些进程反复请求都某一磁道的 I/O 操作垄断整个磁盘设备的“磁盘黏着”操作 将请求队列分为若干个长度为 的子队列，按 FCFS 算法依次处理子队列，队列内按 SCAN 算法 FSCAN 算法 是 NStepSCAN 算法的简化，将请求队列分给两个队列 一个是当前所有请求磁盘 I/O 的进程的队列，由 SCAN 算法处理 另一个是扫描期间新出现的所有请求磁盘 I/O 的进程的等待处理的队列，即推迟到下一次扫描时处理","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://20021123.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://20021123.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统 第五章 虚拟存储器","slug":"操作系统-第五章-虚拟存储器","date":"2023-06-25T07:18:25.000Z","updated":"2023-06-25T07:18:41.719Z","comments":true,"path":"2023/06/25/操作系统-第五章-虚拟存储器/","link":"","permalink":"https://20021123.xyz/2023/06/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/","excerpt":"","text":"第五章 虚拟存储器 一、虚拟存储器概述 1.1 常规存储管理方式的特征和局部性原理 1. 常规存储管理方式的特征 一次性：作业必须一次性地全部装入内存后方可开始运行，导致大作业无法在小内存中运行，无法进一步提高系统的多道程序度，限制了处理机利用率和系统吞吐量的提高 驻留性：作业呗装入内存后，整个作业都一直驻留在内存中，其中任何部分都不会背换出，直至作业运行结束 2. 局部性原理 在一较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域 程序执行时大多数情况是顺序执行 过程调用将会使程序执行轨迹由一部分转移到另一部分。大多数情况过程调用的深度不超过 5 程序中存在许多循环结构，仅有少数指令构成 程序中包括许多对数据结构的处理，局限在很小的范围内 局限性又体现在 时间局限性：程序中某条指令被执行，则不久后该指令可能再次执行；某数据被访问过，不久后可能被再次访问。时间局限性的典型原因是程序中存在大量的循环操作 空间局限性：一旦程序访问了某个存储单元，不久之后其临近的存储单元也将被访问。典型情况是程序的顺序执行 3. 虚拟存储器的基本工作情况 由局部性原理知，程序运行之前不需要全部装入内存，而是讲那些当前运行的少数页面或段装入内存便可，其余暂存在盘上。 程序运行时若所要访问的页（段）已调入内存便可继续执行，否则（称为缺页或缺段）发出缺页（段）中断请求，OS 遍利用请求调页（段）功能将它们调入内存。若内存已满则利用页（段）的置换功能，将暂时不用的页（段）调至盘上，腾出足够的空间后，再调入所需的页（段），使程序继续执行 这样可使一个大的用户程序在较小的内存中间中运行，也可在内存中同时装入更多的进程使它们并发执行 1.2 虚拟存储器的定义和特征 1. 虚拟存储器的定义 虚拟存储器指具有请求调入和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。逻辑容量有内外存容量之和决定，运行速度接近内存速度，每位成本接近外存。 2. 虚拟存储器的特征 多次性：一个作业允许被多次调入内存运行，是虚拟存储器最重要的特征 对换性：相对于常驻性而言 虚拟性：从逻辑上扩充内存容量，是用户所看到的内存容量远大于实际内存容量。改善内存利用率，提高程序执行并发速度。是实现虚拟存储器的最重要的目标 1.3 虚拟存储器的实现方法 1. 分页请求系统 硬件支持 请求分页的页表机制 缺页中断机构 地址变换机构 实现请求分页的软件 2. 请求分段系统 硬件支持 请求分段的段表机制 缺段中断机构 地址变换机构 软件支持 二、请求分页存储管理方式 2.1 请求分页中的硬件支持 1. 请求页表机制 状态位（存在位）P 访问字段 A 修改位 M 外存地址 2. 缺页中断机构 在指令执行期间产生和处理中断信号 一条指令在执行期间可能产生多次缺页中断 3. 地址变换机构 在这里插入图片描述 2.2 请求分页中的内存分配 1. 最小物理块数的确定 最小物理块数是指保证进程正常运行所需的最小物理块数 与计算机的硬件结构有关，取决于指令的格式、功能和寻址方式 2. 内存分配策略 固定分配局部置换 固定分配：每个进程分配一组固定数目的物理块。进程运行期间不再改变 局部置换：发现缺页只能从分配给该进程的 个页面中选一页换出，再调入一页，以保证分配给该进程的内存空间不变 困难在于：确定每个进程分配多少个物理块难以确定 太少导致频繁缺页中断降低系统吞吐量；太多导致内存中驻留进程数减少，CPU 利用率下降，而且实现进程对换更耗时 可变分配全局置换 可变分配：先为每个进程分配一定数目的物理块，运行期间可适当增加或减少 全局置换：进程发生缺页后，将 OS 保留的空闲物理块取一块分配给该进程 最易于实现的一种物理块分配和置换策略 可变分配局部置换 当缺页时，只运行从该进程在内存的页面中选择一页换出，不会影响其他进程的运行。 若进程频繁缺页中断，则系统再为其分配若干附加的物理块；反之若缺页率特别地可适当减少分配的物理块数 3. 物理块分配算法 平均分配算法 未考虑到进程本身的大小，实际上的不公平 按比例分配算法 假设 个进程，每个页面数为 ，则系统中各进程页面总数为 假定物理块总数为 ，则每个进程分到的物理块数为 考虑优先权的分配算法。通常采取吧内存分为两部分，一部分按比例分配，另一部分根据优先权为晋城的优先权分配。重要的实时系统中完全按优先权分配物理块 2.3 页面调入策略 1. 何时调入页面 预调页策略 请求调页策略 2. 何处调入页面 系统拥有足够对换区空间：全部从对换区调入所需页面。为此，进程运行前将进程有关的文件从文件区拷贝到对换区 系统缺少足够对换区空间：不会被修改的文件直接从文件去调入。可能修改的文件将它们换出时需调到对换区 UNIX 方式：与进程有关的文件都放在文件区，范式未运行过的页面都从文件去调入。调出的页面放在对换区 3. 页面调入过程 未修改过可以不写写会磁盘 对用户透明 4. 缺页率 访问页面成功的总数为 ，访问页面失败的次数为 ，总的页面访问次数为 ，则缺页率为 受以下因素的影响 页面大小 进程分配物理块数目 页面置换算法 程序固有特性 三、页面置换算法 3.1 最佳置换算法和先进先出置换算法 1. 最佳置换算法 被淘汰页是以后永不访问，或最长内不再被访问的页面 2. 先进先出（FIFO）页面置换算法 总是淘汰最先进入内存的页面 3.2 最近最久未使用和最少使用置换算法 1. LRU 置换算法 选择最近最久未使用的页面淘汰 2. LRU 置换算法的硬件支持 寄存器 未记录某进程在内存中各页的使用情况，需为每个在内存中的页面配置一个移位寄存器，表示为 当进程访问某物理块时，将相应寄存器的 设为 ，定时信号每隔一段时间将寄存器右移一位。具有最小熟知的寄存器所对应的页面就是最近最久未使用的页面 栈 每当进程访问某页面时将该页面的页面号从栈中溢出并压入栈顶，栈底就是最近最久未使用的页面号 3. 最少使用（LFU）置换算法 设置一个寄存器记录被访问的频率 同样使用移位寄存器方式 3.3 Clock 置换算法 一种成本没有 LRU 高的 LRU 近似算法 1. 简单的 Clock置换算法 为每页设置一位访问位，再将内存中所有页面通过链接指针链接成一个循环队列 某页被访问时，该位设为 检查淘汰时，若为 则换出，若为 则重新设为 暂不换出，按照 FIFO 算法检查下一个页面 又称为最近未用算法（NRU） 2. 改进型 Clock 算法 除了考虑页面的使用情况外，增加一个因素——置换代价，则访问位 A 和修改位 M 组合成一下四种页面 A=0，M=0：最近既未被访问，有未被修改，最佳淘汰页 A=0，M=1：最近未被访问，已被修改，不是很好的淘汰页 A=1，M=0：最近已被访问，未被修改，可能再次被访问 A=1，M=1：最近已被访问且已被修改，可能在北方文 执行过程可分为以下三步 寻找 A=0 且 M=0 的第一类页面，此时不改变访问位 A 如果第一步没找到，写拍照 A=0 且 M=1 的第二类页面，第二轮扫描设所有扫描过的页面的访问位为 0 第二步也是被，则所有访问位复 0，重复第一步，若仍失败则重复第二步，此时一定能找到被淘汰的页 减少了磁盘的 I/O 次数，但实现算法本身的开销有所增加 3.4 页面缓冲算法（PBA） 1. 影响页面换进换出效率的若干因素 页面置换算法 写回磁盘的频率 读入内存的频率 2. 页面缓冲算法 PBA 显著降低页面换进换出的频率，减少磁盘 I/O 次数，减少页面换入换出开销 减少了上述的开销，才能采用一种较为简单的置换策略如 FIFO 算法。不许特殊硬件支持，实现简单 3.5 访问内存的有效时间 被访问页在内存中，页表项在快表中 被访问页在内存中，页表项不在快表中 被访问页不在内存中 设缺页中断处理时间为 令命中率为 ，缺页率为 如不考虑命中率仅考虑缺页率即 ，则 四、“抖动”与工作集 4.1 多道程序度与“抖动“ 1. 多道程序度与处理机的利用率 在系统中运行更多的进程，即增加多道程序度，以提高处理机利用率 处理机利用率是一个单峰函数 2. 产生抖动的原因 同时在系统中运行的程序太多，分配给每一个进程的物理块太少，频繁缺页，对磁盘的有效访问增加，每个进程的大部分时间都用于页面的换入换出，不能做什么有效的工作，从而导致处理机的利用率急剧下降并趋于 称此时的进程处于“抖动”状态 4.2 工作集 1. 工作集的基本概念 程序在运行时间，对页面的访问是不均匀的，在一段时间内仅局限于较少的页面，另一短时间内又局限于另一些较少的页面。这些页面称为活跃页面 2. 工作集的定义 工作集，是在某段时间间隔 里，进程实际所要访问的页面集合。即进程在时间间隔 中引用页面的集合 工作集是窗口尺寸 的非降函数 4.3 “抖动”的预防方法 1. 采用局部置换策略 简单易行，效果不是很好 2. 工作集算法融入处理机调度 调度前检查是否每个进程驻留页面够多，够则调入新作业，否则给缺页率高的进程增加物理块 3. 利用“L=S”准则调节缺页率 是两次缺页之间的平均时间， 是平均缺页服务时间 说明很少缺页，磁盘能力未充分利用 缺页速度已超过磁盘处理能力 最大利用率 4. 选择暂停的进程 多道程序度偏高时，应基于某种原则暂停某些当前活动的进程，调出到磁盘上 五、请求分段存储管理方式 5.1 请求分段中的硬件支持 1. 请求段表机制 2. 缺段中断机构 3. 地址变换机构 5.2 分段的共享和保护 1. 共享段表 共享进程计数：某进程不再需要而释放时，检查 count 是否为 ，为 才回收该内存区 存取控制字段：存取权限，如文件主允许读写，其他进程允许读或只运行执行 段号：同一个共享段在不同进程可以由不同的段号，每个进程可以用自己进程的段号访问它 2. 共享段的分配与回收 共享段的分配 第一个请求使用该共享段的进程，有系统分配物理区，调入该区，始址填入请求进程段表的相应项 在共享段表中增加一项，count 置为 其他的进程需要调用共享段时只需段表填写共享段的物理地址，count+=1 共享段的回收 撤销进程段表的表项，count-=1。若 count 为零则回收，否则只是取消调用者进程在共享段表的记录 3. 分段保护 越界检查 存取控制检查 只读 只执行 读/写 环保护机构：底编号的环有高优先级。OS 核心位于 号环内；某些重要的应用程序和操作系统服务占据中间环；一般的应用程序占据外环 程序可以访问相同/外环中的数据，调用相同/内环中的服务","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://20021123.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://20021123.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统 第四章 存储器管理","slug":"操作系统-第四章-存储器管理","date":"2023-06-25T07:17:25.000Z","updated":"2023-06-25T07:17:43.443Z","comments":true,"path":"2023/06/25/操作系统-第四章-存储器管理/","link":"","permalink":"https://20021123.xyz/2023/06/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AD%98%E5%82%A8%E5%99%A8%E7%AE%A1%E7%90%86/","excerpt":"","text":"第四章 存储器管理 一、存储器的层次结构 1.1 多层结构的存储器系统 1. 存储器的多层结构 寄存器-高速缓存-主存-磁盘缓存-固定磁盘-可移动存储介质 2. 可执行存储器 寄存和主存称为可执行存储器 1.2 主存储器与寄存器 1.3 高速缓存和磁盘缓存 1. 高速缓存 2. 磁盘缓存 磁盘缓存用于缓解磁盘的 I/O 速度和主存的访问素的的不匹配，用于暂时存放频繁使用的一部分的磁盘数据和信息以减少访问磁盘的次数 磁盘缓存和高速缓存不同，本身并不是一种实际存在的存储器，而是利用主存中的部分存储空间暂时存放从磁盘中读出或写入的信息 二、程序的装入和链接 2.1 程序的装入 1. 绝对装入方式 2. 可重定位装入方式 将指令中的逻辑地址与本程序在内存中的起始地址相加得到正确的物理地址 地址变换通常在进程装入时一次完成，以后不再改变，又称为静态重定位 3. 动态运行时的装入方式 可重定位装入方式不允许程序运行时在内存中移动位置。 动态运行时装入程序在装入模块仅内存后，并不直接将逻辑地址转换为物理地址，而是推迟到程序真正要执行的时再转换。因此装入内存后的动态地址仍是逻辑地址 2.2 程序的链接 链接时装目标模块和所需的库函数装配成一个完整的装入模块 1. 静态链接 将目标模块及它们所需的库函数链接称一个完整的装配模块 对相对地址进行修改 变换外部调用符号 2. 装入时动态链接 发生一个外部模块调用事件，编译器装入程序找出相应的外部目标模块并装入内存 便于修改和更新 便于实现对目标模块的共享 3. 运行时动态链接 将对某些模块的链接推迟到程序执行时才进行 加快程序的装入过程，节省大量的内存空间 三、连续分配存储管理方式 连续分配方式是最早出现的一种存储器分配方式，该方式为一个用户程序分配一个连续的内存空间 3.1 单一连续分配 单道程序环境 3.2 固定分区分配 1. 划分分区的方法 分区大小相等：缺点是缺乏灵活性，但特殊场合如炉温群控系统可以使用 分区大小不等：通常多个小分区，适量中等分区，少量大分区 2. 内存分配 按分区大小排序，建立一张分区使用表 3.3 动态分区分配 1. 动态分区分配中的数据结构 常用的有 空闲分区表：每个空闲分区一个表目，包括分区号、分区大小、分区起始地址等 空闲分区链：在每个分区的起始部分设置踹出血控制分区分配的信息 2. 动态分区分配算法 3. 分区分配操作 分配内存 回收内存 相邻的空闲分区可以合并 3.4 基于顺序搜索的动态分区分配算法 1. 首次适应（FF）算法 地址递增找到第一个 倾向于利用内存中低址部分的空闲分区，为以后的大作业分配大的内存空间创造了条件 缺点是低址部分不断被划分，留下许多难以利用的小的空闲分区，称为碎片 2. 循环首次适应（NF）算法 不是从链首，而是从上次找的的空闲分区开始 使内存中的空闲分区分配的更均匀，减少了查找空闲分区的消耗 缺点是缺乏大的空闲分区 3. 最佳适应（BF）算法 每次找到最小的能装下的空闲分区 每次分割后所切割下来剩余部分总是最小的，碎片多 4. 最坏适应（WF）算法 每次挑选一个最大的空闲区分割一部分给作业使用 优点是剩下的空闲区不至于太小，产生碎片的可能性最小 查找效率很高 3.5 基于索引搜索的动态分区分配算法 1. 快速适应（quick fit）算法 又称分类搜索法，将空闲分区根据容量大小进行分类。每一类单独设立一个空闲分区链表 优点是查找效率高 缺点是为了合并分区，在分区归还主存时的算法复杂，系统开销大 此外该算法分配空闲分区以进程为单位，在为进程所分配的一个分区或多或少存在浪费 2. 伙伴系统（buddy system） 无论分配分区或空闲分区，大小均为 的幂 找一个最小的 ，找不到就分 ，还找不到就分 ，以此类推 对一个大小为 ，地址为 的内存块，其伙伴块的地址为 3. 哈希算法 利用哈希快速查找的优点，构造一张以空闲分区大小为关键字的哈希表 分配空闲分区时，根据所需大小计算哈希值，得到其位置，得到相应的空闲分区链表实现最佳分配策略 3.6 可重定位分区分配 1. 紧凑 通过移动内存中作业的位置，把原来多个分校的小分区拼接成一个打分去的方法，称为“拼接”或“紧凑“ 每紧凑一次就要对移动了的程序或数据的地址进行修改，影响系统效率 2. 动态重定位 在系统中增设一个重定位寄存器，存放程序（数据）在内存中的起始位置 程序执行时真正访问的内存地址是相对地址与重定位寄存器中的地址相加而形成的 3. 动态重定位分区分配算法 与动态分区分配算法基本相同，只是添加了紧凑的功能 当找不到一个足够大的空闲分区时，若所有小的空闲分区总和满足用户需求，则紧凑，否则返回分配失败 四、对换 4.1 多道程序环境下的对换技术 1. 对换的引入 对换是指内存中暂时不能运行的进程或暂时不用的程序和数据换出到外村上，以便腾出足够的内存空间，再把已具备运行条件的进程或程序数据等换入内存 可以提高处理机利用率和系统吞吐量 2. 对换的类型 整体对换：中级调度以整个进程为单位在，称为进程对换或整体对换 页面（分段）对换：如果对换的目标是进程的一个“页面”或“分段”，则称为页面分段或分段对换，统称为“部分对换”，目的是为了支持虚拟存储系统 4.2 对换空间的管理 1. 对换空间管理的主要目标 在具有对换功能的 OS 中，通常把磁盘空间分为文件区和对换区 对文件区管理的主要目标 通常的文件都是较长时间驻留在外存上，访问频率较低 主要目标是提高文件存储空间的利用率，然后才是提高文件的访问速度 因此管理采用离散分配方式 对对换空间管理的主要目标 对换空间只占用磁盘的小部分，用于存放从内存换出的进程 进程驻留的时间短暂，对换操作频率较高 主要目标是提高进程换入换出的速度，然后才是提高文件存储空间的利用率 因此采用连续分配方式，较少考虑外存中的碎片问题 2. 对换空闲盘块管理中的数据结构 形式与内存在动态分区分配方式的数据结构相似 空闲分区表或空闲分区链 每个表目记录：对换区的首址及其大小，分别用盘块号和盘块数表示 3. 对换空间的分配与回收 与动态分区方式相同 4.3 进程的换入与换出 1. 进程的换出 选择被换出的进程 先选阻塞或睡眠状态的进程，多个选优先级最低的。 又是还需考虑进程在内存的驻留时间 进程换出过程 只能换出非共享的程序和数据段。对于共享的程序和数据段，只要还有进程需要就不能被换出 2. 进程的换入 首先查看 PCB 集合中所有进程的状态，找出“就绪”但已换出的进程，选择其中已换出到磁盘上时间最久的进程 一直对换直到没有可换入进程或内存不足 五、分页存储管理方式 允许一个进程直接分散地装入许多不相邻的分区中，便可充分利用内存空间，基于这一思想产生了离散分配方式 分页存储管理方式：用户程序的地址空间分为若干个固定大小的区域，称为“页”或“页面”。典型的页面大小为 1KB。相应地，内存空间也分为若干个物理块或页框 分段存储管理方式：这是为了满足用户要求形成的一种存储管理方式。将用户程序的地址空间分为若干个大小不同的段，每段可定义一组相对完整的信息。在存储器分配时以段位单位 段页式存储管理方式：是两种存储管理方式结合的产物 5.1 分页存储管理的基本方法 1. 页面和物理块 页面：将进程的逻辑地址空间分为若干页，加以编号，从 开始，如第 页。内存的物理地址空间也分为若干块，同样编号，如 块。进程的最后一页常装不满一块，形成不可利用的碎片，称为“页内碎片” 页面大小：过小的页面可以减少内存碎片，有利内存利用率的提高；但会造成每个进程占用过多的页面，导致进程页表过长；还会降低页面换入换出的效率。过大的页面虽然可以减少页表长度，但会使页内碎片增大 通常的页面大小为 的幂，为 2. 地址结构 31~12 11~0 页号 P 位移量 W 包含两部分：前一部分为页号，后一部分为偏移量，即业内地址 若给定一个逻辑地址空间中的地址为 ，页面大小为 ，则页号和页内地址为 3. 页表 在分页系统中，系统为每个进程建立了一张页面映像表，简称页表，记录了相应页在内存中对应的物理块号 作用是实现从页号到物理块号的地址映射 5.2 地址变换机构 基本任务是实现从逻辑地址到物理地址的转换，借助于页表完成 1. 基本的地址变换机构 页表寄存器 PTR 2. 具有快表的地址变换机构 联想寄存器，又称 TLB，用以存放当前访问的哪些页表项 5.3 访问内存的有效时间 从进程发出指定逻辑地址的访问请求，经过地址变换，到在内存中找到对应的实际物理地址单元取出数据所花费的总时间称为内存的有效访问时间（EAT）。 假设一次访问内存时间为 ，在基本分页存储管理方式中，有效方式时间为第一次查找页表对应项+第二次查找实际物理地址时间之和 引入快表时，假设 为查找快表的时间，命中率为 ，则 5.4 两级和多级页表 1. 两级页表 2. 多级页表 见下章 5.5 反置页表 1. 反置页表的引入 为减少页表占用的内存空间，引入反置页表 反置页表为每一个物理块设置一个页表项，按物理块的编号排序，内容是页号和所隶属进程的标识符 2. 地址变换 六、分段存储管理方式 6.1 分段存储管理方式的引入 通常的程序都可分为若干个短，如主程序段、子程序段、数据段以及栈段等，每个段大多是一个相对独立的逻辑单位 实现和满足信息共享、信息保护、动态链接和信息的动态增长等需要也已段位基本单位 1. 方便编程 12LOAD 1,[A]|&lt;D&gt;STORE 1,[B]|&lt;C&gt; 2. 信息共享 分页系统一个可被共享的过程可能需要占用数十个页面，造成共享的困难 3. 信息保护 函数只允许执行不允许读写等，只需段做标志 页面的话可能有装有不同的保护属性的程序段的数据 4. 动态增长 数据段的动态增长很难预先知道 5. 动态链接 动态链接要求的是目标程序（即段）作为链接的基本单位 6.2 分段系统的基本原理 1. 分段 分段存储管理方式中，作业的地址空间分为若干个段，如主程序段 MAIN，子程序段 X，数据段 D，栈段 S 等 每个段都从 开始编址，并采用一段连续的地址空间。 段长并不相等 2. 段表 段表记录了段在内存中的起始地址（基址）和段长 3. 地址变换机构 先判断是否段号太大访问越界，在检查端内地址 d 和该段段长 SL，最后将段基址和段内地址相加得物理地址 同样每次访问两次内存，解决方法是也增设一个联想存储器 4. 分段和分页的主要区别 页是信息的物理单位。采用分页以实现离散分配方式，提高内存利用率。分页仅仅是系统管理上的需要，对用户不可见 分段存储管理方式中的段信息的逻辑单位，通常包含一组意义相对完整的信息，目的在于更好地满足用户需要 页的大小固定且有系统决定。短的长度不固定，决定于用户编写的程序 分页的用户程序地址空间是一维的。分段系统中用户程序的地址空间是二维的，需给出段名和段内地址 6.3 信息共享 1. 分页程序中对程序和数据的共享 可重入代码又称为纯代码，是一种允许多个进程同时访问的代码。是一种不允许任何进程对它进行修改的代码。 在每个进程中，都必须配以局部数据区，把在执行中可能改变的部分拷贝到该数据区 每个进程的页表都设置共享程序的页表项 2. 分段程序中程序和数据的共享 只需在进程的段表中为共享程序设置一个段表项即可 6.4 段页式存储管理方式 1. 基本原理 段页式系统是分段和分页原理的结合 段表内容不再是内存始址和段长，而是页表始址和页表长度 2. 地址变换过程 利用段表始址和段号，得到页表始址，在用段内页号得到页表项位置，读出物理块号，最后用块号和页内地址构成物理地址 每次需访问三次内存，为提高执行速度增设一个高速缓冲器，存[段号:段内页号]对应的块号","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://20021123.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://20021123.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统 第三章 处理机调度与死锁","slug":"操作系统-第三章-处理机调度与死锁","date":"2023-06-25T07:16:55.000Z","updated":"2023-06-25T07:17:11.823Z","comments":true,"path":"2023/06/25/操作系统-第三章-处理机调度与死锁/","link":"","permalink":"https://20021123.xyz/2023/06/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%E4%B8%8E%E6%AD%BB%E9%94%81/","excerpt":"","text":"第三章 处理机调度与死锁 一、处理机调度的层次和调度算法的目标 1.1 处理机调度的层次 1. 高级调度 高级调度又称长程调度或作业调度，主要功能是根据算法决定外存上位于后备队列的哪几个作业调入内存，为它们创建进程，分配必要资源，放入就绪队列 主要用于多道批处理系统，分时和实时系统中 不设置 2. 低级调度 低级调度又称进程调度或短程调度。根据算法决定就绪队列中哪个进程获得处理机，并由分派程序将处理机分配给被选中的进程 是最基本的一种调度 3. 中级调度 中级调度又称内存调度。用于提高内存利用率和系统吞吐量。把暂时不能运行的的进程调至外存等待，此时进程中的状态称为就绪外存状态（或挂起状态）。当它们已具备运行条件且内存有稍有空闲时就由中级调度决定把哪些外存上的就绪进程重新调入内存，并修改其状态为就绪状态 1.2 处理机调度算法的目标 1. 处理机调度算法的共同目标 资源利用率 利用率有效工作时间有效工作时间空闲等待时间 公平性：诸进程都获得合理的 CPU 时间，不会发生进程饥饿现象 平衡性：对于多种类型的进程，有的属于计算型，有的属于 I/O 型，应尽可能保证系统资源利用的平衡性 策略强制执行：只要需要，就必须予以准确地执行，及时造成某些工作的延迟也要执行 2. 批处理系统的目标 平均周转时间短 系统吞吐量高 处理机利用率高 3. 分时系统的目标 响应时间快 均衡性 4. 实时系统的目标 截止时间的标准 可预测性 二、作业与作业调度 2.1 批处理系统中的作业 1. 作业和作业步 作业：作业是比程序更为广泛的概念，不仅包含了通常的程序和数据，还配有一份作业说明书。在批处理系统中，以作业为基本单位存外存调入内存 作业步：通常在作业运行期间，每个作业都必须经过若干相对独立又相互关联的顺序加工步骤才能得到结果。我们吧其中的每一个加工步骤称为一个作业步，各作业步之间存在着相互联系，常常是上一个作业步的输出做下一个作业步的输入，如“编译”、“链接装配”、“运行”作业步。 2. 作业控制块（JCB） 作业控制块是作业在系统中存在的标志，保存了系统对作业进行调度和管理所需的全部信息。 每当一个作业进入系统时，便由作业注册程序为该作业建立一个作业控制块，再根据作业类型将它放在对应的作业后备队列中等到调度。调度程序依据一定的调度算法调度他们，将被调度的作业装入内存。在作业运行期间，系统按照 JCB 中的信息和作业说明书对作业进行控制。当一个作业执行结束进入完成状态时，系统负责回收已分配的资源，撤销作业控制块 3. 作业运行的三个阶段和三种状态 三阶段：收容、运行、完成 收容阶段：操作员将用户提交的作业输入到硬盘上，再为该作业建立 JCB，并将它发缓释作业后备队列中，此时作业的状态为后备状态 运行阶段：一个作业从第一次进入就绪状态开始，直到运行结束前，在此期间都处于运行状态 完成阶段：当作业运行完成或发生异常情况提前结束时，作业便进入完成阶段，相应的作业状态为完成状态 2.2 作业调度的主要任务 1. 接纳多少个作业 2. 接纳哪些作业 2.3 先来先服务（FCFS）和短作业优先（SJF）调度算法 1. 先来先服务 FCFS 在单处理机系统中已很少作为主调度算法，但进程把它与其他调度算法结合使用形成一种更有效的调度算法，例如可以在系统中按晋城的优先级设置多个队列，每个优先级一个队列，其中每个队列的调度都给予 FCFS 算法 2. 短作业优先 实际情况中，短作业占有很大比例，为使他们比长作业优先执行产生了短作业优先算法 缺点 必须阈值作业的运行时间。如果估计过低，系统可能按估计的世界终止作业的运行，但此时作业并未完成，故一般都会片场估计 对长作业非常不利，长作业的周转时间会明显增长。可能使作业等待时间过长，出现饥饿现象 采用 SJF 算法时，人机无法实现交互 该调度算法完全未考虑作业的紧迫程度，不能保证紧迫性作业能获得及时处理 2.4 优先级调度算法和高响应比优先调度算法 1. 优先级调度算法（PSA） 优先级调度算法中基于作业的紧迫程度，由外部赋予作业相应的优先级，调度算法根据该优先级进行调度。PSA 可以作为作业调度算法或进程调度算法。 当作为作业调度算法时，系统从后备队列中选择若干个优先级最高的作业装入内存。 2. 高响应比优先调度算法（HRRN） 高响应比优先算法引入一个动态优先级，随等待时间延长而增加 优先权等待时间要求服务时间要求服务时间 由于等待时间与服务时间之和就是系统对该作业的响应时间，故该优先级由相当于响应比 。因此优先级又可表示为 等待时间要求服务时间要求服务时间响应时间要求服务时间 如果作业的等待时间相同，则要求服务时间的越短优先级越高，类似于 SJF，有利于短作业 当要求服务时间相同，作业优先级决定于等待时间，类似于 FCFS 对场左右的优先级，可以随等待时间的增加而提高，当其等待时间足够长时也可获得处理机，因此该算法实现了较好的折中。但是每次要进行调度前要先进行响应比的计算，增加了系统开销 三、进程调度 3.1 进程调度的任务、机制和方式 1. 进程调度的任务 保存处理机的现场信息 按某种算法选取进程 把处理机分配给进程 2. 进程调度机制 排队器：为提高进程调度的效率，应先将系统中的所有就绪进程按照一定的策略排成一个或多个队列以便调度程序能最快找到它 分派器：分配器根据进程调度所选定的进程将其从就绪队列中取出，然后进行从分配器到新选出进程的上下文切换，将处理机分配给辛选出的进程 上下文切换器：对处理机切换时会发生两对上下文的切换操作 第一对上下文切换时，OS 保存当前进程的上下文，在装入分配程序的上下文以便分配程序运行 第二次上下文切换时，移出分配程序的上下文，吧新选进程的 CPU 现场信息装入到处理机的各个相应寄存器中，以便新选进程进行 3. 进程调度方式 非抢占方式 在采用这种调度方式时，一旦被处理机分配给某进程后，就一直让它运行，知道该进程完成或发生某事件被阻塞时，才把处理机分配给其他进程 可能引起进程调度的因素可归结为 正在执行的进程运行完毕，或因某时间使其无法继续运行 正在执行的进程因提出 I/O 请求暂停执行 在进程通信或同步过程中执行了某种原语操作，如 Block 原语。 优点是实现简单，系统开销小，适用于大多数的批处理系统 抢占方式 这种调度方式允许调度程序根据某种原则暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一进程。 对于批处理机系统，可以防止一个长进程长时间占用处理机，以确保处理机能为所有进程提供更为公平的服务 在分时系统中，只有采用抢占方式才可能实现人机交互 在实时系统中，抢占方式能满足实时系统的需求。但抢占方式比较复杂，所需付出的系统开销也较大 抢占的主要原则有 优先级原则 短进程优先原则 时间片原则，即个进程按时间片轮转运行时，当正在执行的进程的一个时间片用完后，便停止该进程的执行而重新进程调度 3.2 轮转调度算法 1. 轮转法的原理 在轮转法（RR）中，系统根据 FCFS 策略，将所有的就绪进程排成一个就绪队列，并可设置每隔一段时间间隔产生一个中断，激活系统中的进程调度程序 ，完成一次调度，将 CPU 分配给队首进程，令其执行。当晋城的时间片耗尽或运行完毕时，系统再次将 CPU 分配给新的队首进程 2. 进程切换时机 若一个时间片尚未用完，正在运行的进程便已完成，就立即激活调度程序 在一个时间片用完时 3. 时间片大小的确定 时间片小，有利于短作业，因为它能在该时间片内完成，但会频繁执行进程调度和上下文切换，增加系统开销 时间片长，每个进程都能在一个时间片内完成，RR 算法则退化为 FCFS 算法，无法满足短作业和交互式用户的需求 一个可去的大小是略大于一个典型的交互所需的时间，使大多数交互式进程能在一个时间片内完成，从而获得很小的响应时间 3.3 优先级调度算法 1. 优先级调度算法的类型 非抢占式优先级调度算法 抢占式优先级调度算法 2. 优先级的类型 静态优先级 创建进程时确定，在进程的整个运行期间不变，依据为 进程类型。系统&gt;用户 进程对资源的需求。资源要求少优先级高 用户要求 金泰优先级法简单易行，系统开销小，但不够精确，可能会出现优先级低的进程长时间没有被调度的情况 动态优先级 可以规定就绪队列中的进程随等待时间的延长优先级相应提高。 当采用抢占式调度方式时，规定当前进程的优先级随运行时间推移而下降，可防止一个长作业长期垄断处理机 3.4 多队列调度算法 将进程就绪队列从一个拆分为多个，将不同类型或性质的进程固定分配在不同的就绪队列，不同的就绪队列采用不同的调度算法，一个就绪队列中的进程可以设置不同的优先级，不同的就绪队列本身也可设置不同的优先级 3.5 多级反馈队列调度算法 1. 调度机制 设置多个就绪队列。优先级从高到低，时间片长度依次翻倍 每个队列采用 FCFS 算法，当新进程进入内存后，首先放入第一队列的末尾。当进程时间片完成仍为执行完成后扔在下一队列，直到最后第 队列按 RR 方式运行 按队列优先级调度。即当 的所有队列均空时，才会调度第 队列的进程。当处理机正在处理第 队列的某进程时又有新进程进入任一优先级较高的队列时，将正在运行的队列方位第 队列的末尾，将处理机分配给新到的高优先级进程 2. 调度算法的性能 终端型用户：交互性作业通常能在第一队列规定的时间片内完成 段批处理作业用户：对于这类作业如果在第一队列中完成便可获得与终端型作业一样的响应时间。对于稍长的短作业也只需在第二三队列各执行一时间片，周转时间仍较短 长批处理作业：对于长作业，将依次在 中，然后再按、轮转方式运行，不必担心得不到处理 3.6 基于公平原则的调度算法 1. 保证调度算法 当有 个相同类型的进程同时运行，为公平起见保证每个进程都获得相同的处理及时间 2. 公平分享调度算法 若用户所拥有的进程时不同，则对用户不公平。 可以考虑每一个用户所拥有的进程数目 四、实时调度 4.1 实时调度的条件 1. 提供必要的信息 就绪时间 开始截止时间和完成截止时间 处理时间 资源要求 优先级 2. 系统处理能力强 假定系统有 个周期性的硬实时任务 HRT，处理时间为 ，周期时间为 ，则在单处理机情况下，满足以下限制条件才可调度 多处理机的情况则 3. 采用抢占式调度机制 4. 具有快速切换机制 4.2 实时调度算法的分类 1. 非抢占式调度算法 非抢占式轮转调度算法 数秒至数十秒的响应时间 非抢占式优先调度算法 数秒至数百毫秒 2. 抢占式调度算法 基于时钟中断的抢占式优先级调度算法 几十至几毫秒 立即抢占的优先级调度算法 几毫秒至100微妙 4.3 最早截止时间优先（EDF）算法 1. 非抢占式调度方式用于非周期实时任务 2. 抢占式调度方式用于周期实时任务 通常的优先级调度不能使用于实时系统 4.4 最低松弛度优先（LLF）算法 松弛度（紧急程度）=截止时间-执行时间 松弛度低排最前 4.5 优先级倒置 1. 优先级倒置的形成 P1，P3 共享临界资源，P3 先到，再来 P3，P1 被阻塞完成 P2 和 P3 后再完成 P1，倒置 2. 解决办法 简单的方法：进入临界区后不允许抢占。但如果 P3 临界区很长则高优先级进程扔等待很长时间，无法令人满意 使用的方法：当 P1 要用的临界资源被 P3 占用时，由 P3 继承 P1 的优先级，避免了 P2 的插入 五、死锁概述 5.1 资源问题 1. 可重用性资源和消耗性资源 可重用性资源 是一种可供用户重复使用多次的资源，性质有 每一个可重用性资源的单元只能分配给一个进程，不允许多个进程共享 进程在使用可重用性资源时，必须要 请求资源 使用资源 释放资源 系统中每一类可重用性资源的单元数相对固定 可消耗性资源 又称临时性资源，有进程在运行期间动态创建和消耗的资源，例如进程间通信的消息。性质有 每一类可消耗资源单元数目在运行期间可以不断变换 进程运行时可以不断创造可消耗性资源 进程在运行过程中可请求若干可消耗性资源单元用于自己的消耗 2. 可抢占性资源和不可抢占性资源 可抢占性资源 某进程在获得这类资源后，该资源可以再被其他进程或系统抢占。如优先极高的进程可以抢占低的处理机。在内存紧张时把一个进程从内存掉出道外存，即抢占该进程在内存的空间，对于这类资源不会引起死锁 不可抢占性资源 即一旦系统吧资源分配给某进城后，不能将它强行收回，只能在进程用完后自行释放。例如刻录光盘，磁带机，打印机等 5.2 计算机系统中的死锁 1. 竞争不可抢占性资源引起死锁 2. 进程可消耗资源引起死锁 3. 进程推进顺序不当引起死锁 5.3 死锁的定义、必要条件和处理方法 1. 死锁的定义 如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的时间，那么该组进程是死锁的 2. 产生死锁的必要条件 互斥条件。进程对所分配到的资源进行排他性使用 请求和保持条件。进程以保持了至少一个资源但又提出了新的资源请求 不可抢占条件。进程已获得的资源在使用完之前不可抢占 循环等待条件。在发生死锁时，必定存在一个进程——资源的循环链 3. 处理死锁的方法 预防死锁：设置某些限制条件，破坏四个必要条件之一或多个 避免死锁：在自愿的动态分配时用某种方法防止系统进入不安全状态 检测死锁：无需任何先执行措施，运行发生死锁。但可通过检测机构及时检测出死锁的发生然后采取恰当措施解决进程 解除思索：当检测到死锁时则采取相应措施解脱进程。常用的方式是侧小一些进程，回收他们的资源，分配给已处于阻塞状态的进程使其能继续执行 六、预防死锁 6.1 破坏“请求和保持”条件 1. 第一种协议 所有进程在开始之前必须一次性地申请在整个运行过程中所需的全部资源 简单，易行，安全 缺点 资源被严重浪费，严重饿坏了资源利用率 进程经常会发生饥饿现象 2. 第二种协议 运行一个进程自获得运行处其所需的资源后开始运行。运行过程中在逐步释放已分配给自己的，已用毕的全部资源，然后请求新的所需资源 6.2 破坏“不可抢占”条件 协议中规定当一个已经保持了某些不可被抢占资源的进程提出新的资源请求而不能被满足时，必须释放已保持的所有资源，一代需要时重新申请 实现起来不较复杂且需付出很大的代价 6.3 破坏“循环等待”条件 对所有资源进行线性排序，并赋予不同的序号 规定每个进程必须按序号递增的顺序请求资源 多个同类资源单元必须一起请求 当有高资源要低资源时必须释放所有相同和更高序号的资源 相比强两种策略，资源利用率he系统吞吐量都有明显改善 缺点 系统中各类自愿的序号必须相对稳定，限制了新类型设备的添加 尽管分配序号是考虑到大多数作业在实际使用这些资源的顺序，但会发生：作业使用各类自愿的顺序与系统规定的顺序不同，造成对自愿的浪费 为方便用户，系统对用户编程的限制条件应尽可能少，但这种方法会限制用户简单、自主地编程 七、避免死锁 7.1 系统安全状态 1. 安全状态 安全状态，是指系统能按照某种进程推进顺序 为每个进程分配器所需资源直至满足每个进程对自愿的最大需求，此时称 为安全序列。如果系统找不到安全序列则称系统处于不安全状态 不安全状态不一定会产生死锁，但安全状态一定不会产生思索 2. 安全状态之例 进程 最大需求 已分配 可用 P1 10 5 3 P2 4 2 P3 9 2 此时存在一个安全序列 3. 由安全状态向不安全状态的转换 7.2 利用银行家算法避免死锁 1. 银行家算法中的数据结构 可利用资源向量 ，含有 个元素的数组，当 则系统中有 个 类资源 最大需求矩阵 ，这是一个 的矩阵，定义了 个进程对 类自愿的最大需求 分配矩阵 ，也是一个 的矩阵，定义了当前系统已分配给每一进程的资源数 需求矩阵 ，也是一个 的矩阵，表示每个进程尚需的各类资源 2. 银行家算法 设 是进程 的请求向量，当 发出资源请求时，系统按以下步骤检查 如果 则继续，否则出错，需求资源超过宣称最大值 如果 则继续，否则尚无足够资源 尝试分配资源 ，修改数据结构的值 系统执行安全性算法检查此次资源分配后系统是否处于安全状态 3. 安全型算法 设置两个向量 工作向量 表示系统可提供给进程继续运行所需的各类资源数目，开始时 表示系统是否有足够的资源分配给该进程，开始时 从进程集合中找到一个能满足以下条件的进程 若找到步骤3，否则步骤4 当进程 获得资源后，执行直至释放资源，所以 $$ $$ 如果所有进程的 满足则系统处于安全状态，反之不安全状态 八、死锁的检测与解除 8.1 死锁的检测 1. 资源分配图 进程结点和资源节点， 请求边表示资源请求进程，分配边表示资源分配 2. 死锁定理 简化资源分配图，略 8.2 死锁的解除 抢占资源：从一个或多个进程中抢占足够数量的资源分配给死锁进程 终止（撤销）进程：终止（撤销）系统中的若干死锁进程 1. 终止进程的方法 终止所有死锁进程 逐个终止进程 代价可以为 进程的优先级大小 进程执行时间，还需多少时间 进程已使用资源，还需多少资源 进程时交互式的还是批处理使得 2. 付出代价最小的死锁解除算法 每次选解除代价最小的解除即可","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://20021123.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://20021123.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统 第二章 进程的描述与控制","slug":"操作系统-第二章-进程的描述与控制","date":"2023-06-25T07:16:07.000Z","updated":"2023-06-25T07:16:36.707Z","comments":true,"path":"2023/06/25/操作系统-第二章-进程的描述与控制/","link":"","permalink":"https://20021123.xyz/2023/06/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/","excerpt":"","text":"第二章 进程的描述与控制 一、前驱图与程序执行 1.1 前驱图 前趋图(Precedence Graph)是一个有向无循环图，记为DAG(Directed Acyclic Graph)，用于描述进程之间执行的前后关系。图中的每个结点可用于描述一个程序段或进程，乃至一条语句；结点间的有向边则用于表示两个结点之间存在的偏序(Partial Order)或前趋关系(Precedence Relation)“→”。 在前趋图中，把没有前趋的结点称为初始结点(Initial Node)，把没有后继的结点称为终止结点(Final Node)。 每个结点还具有一个重量(Weight)，用于表示该结点所含有的程序量或结点的执行时间。 1.2 程序顺序执行 1. 程序的顺序执行 通常，一个应用程序由若干程序段组成，每一个程序段完成特定功能，它们在执行时都需要按照某种先后次序顺序执行，仅当前一程序段执行完毕后才运行后以程序段 2. 程序顺序执行的特征 顺序性：处理机严格按照程序规定的顺序执行 封闭性：程序运行时独占全机资源，程序一旦开始执行，其执行结果不受外界因素影响 可再现性：只要程序执行时的环境和初始条件相同，都将获得相同的结果。 （不论它是从头到尾不停顿地执行，还是“停停走走”地执行） 1.3 程序并发执行 1. 程序的并发执行 对不同作业的没有前驱关系的不同程序可以并发执行 2. 程序并发执行时的特征 间断性：程序并发执行是，由于共享系统资源，这些程序 形成相互制约的关系，具有“执行-暂停-执行”特征 失去封闭性：程序并发执行时，多个程序共享系统资源，因而 这些资源的状态将由多个程序来改变，从而导致 程序的运行失去封闭性 不可再现性：程序并发执行，由于失去了封闭性，从而也失去了可再现性 二、进程的描述 2.1 进程的定义和特征 1. 进程的定义 进程是程序的一次执行。 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。 进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。 2. 进程的特征 动态性 进程的实质是进程实体的一次执行过程，因此，动态性是进程的最基本的特征。 动态性表现：“它由创建而产生，由调度而执行，由撤消而消亡”。可见，进程实体有一定的生命期。 程序是一组有序指令的集合，其本身并不具有运动的含义，因而是静态的。 并发性 这是指多个进程实体同存于内存中，且能在一段时间内同时运行 独立性 指进程实体是一个能独立运行、独立分配资源和独立接受调度的基本单位 异步性 指进程按各自独立的、不可预知的速度向前推进，或说进程实体按异步方式运行 3. 进程的结构 为使程序（含数据）能独立运行，应为之配置一进程控制块，即 PCB； 而由程序段、相关的数据段和 PCB 三部分便构成了进程实体。 所谓创建进程，实质上是创建进程实体中的 PCB ；而撤消进程，实质上是撤消进程的 PCB。 2.2 进程的基本状态及转换 1. 进程的三种基本状态 就绪（Ready）状态：当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行。 执行状态：进程已获得CPU，其程序正在执行。 阻塞状态：正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃处理机而处于暂停状态，把这种暂停状态称为阻塞状态，有时也称为等待状态。根据阻塞原因，系统中设置多个阻塞队列。 2. 三种状态的转换 3. 创建状态和终止状态 创建状态 如果进程所需资源尚不能得到满足，如无足够的内存空间，创建工作将无法完成，进程不能被调度，此时的进程状态为创建状态 终止状态一个进程到达了自然结束点，或者出现了无法克服的错误，或是被操作系统所终结，或是被其他有终止权的进程所终结，它将进入终止状态 2.3 挂武器操作和进程状态的转换 使执行的进程暂停执行,静止下来,我们把这种静止状态称为挂起状态 挂起状态的原因 终端用户的请求：用户发现程序运行有问题，将其暂停 父进程请求：挂起子进程，协调子进程的活动 负荷调节的需要：当实时系统中的工作负荷较重，把一些不重要的进程挂起，以保证系统能正常运行 操作系统的需要：操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账 2.4 进程管理中的数据结构 1. PCB 的作用 独立运行基本单位的标志。 能实现间断性运行方式。（保护CPU现场） 提供进程管理所需要的信息。（OS通过PCB对进程实施控制和管理。） 提供进程调度所需要的信息。（提供进程状态、优先级等信息） 实现与其它进程的同步与通信。（消息队列指针，信号量等） 2. PCB 中的信息 进程标识符 进程标识符用于惟一地标识一个进程。一个进程通常有两种标识符： （1）内部标识符。为每一个进程赋予一个惟一的数字标识符，通常是进程的序号(Pid)。设置内部标识符主要是为了方便操作系统使用。 （2）外部标识符。它由创建者提供(进程的名字)，通常是由字母、数字组成，往往是由用户（进程）在访问该进程时使用。 处理机状态 处理机状态信息主要是由处理机的各种寄存器中的内容组成的。 通用寄存器，又称为用户可视寄存器。 指令计数器（PC），其中存放了要访问的下一条指令的地址。 程序状态字PSW，其中含有状态信息，如条件码、执行方式、中断屏蔽标志等 用户栈指针(SP)，用于存放系统调用参数及调用地址。栈指针指向该栈的栈顶。 进程调度信息 进程状态，指明进程的当前状态 进程优先级 进程调度所需的其它信息。如：进程已等待CPU的时间总和、进程已执行的时间总和等 事件。是指进程由执行状态转变为阻塞状态所等待发生的事件，即阻塞原因 进程控制信息 程序和数据的地址，是指进程的程序和数据所在的内存或外存地址。 进程同步和通信机制，指实现进程同步和通信时必需的机制，如消息队列指针、信号量等，他们可能全部或部分的放在PCB中。 资源清单。进程所需的全部资源及已经分配到该进程的资源的清单； 链接指针。本进程所在队列的下一个进程的PCB的首地址。 3. PCB 的组织方式 链接方式：把具有同一状态的 PCB，用其中的链接字链接成一个队列 索引方式：相同状态进程的 PCB 组织在一张表格中，系统根据所有进程的状态建立几张索引表，系统分别记载各 PCB 表格的起始地址 多级队列：按照进程状态不同分别组织 PCB 队列，同一状态进程 PCB 按照优先级高低（或者到达的先后顺序）用链接指针连接起来 三、进程控制 进程控制是进程管理中最基本的功能，主要包括创建、终止进程；进程运行中的状态转换 进程控制一般是由 OS 内核中的一组原语来实现的 原语是由若干条指令组成的，用于完成一定功能的一个过程。是“原子操作”，即一个操作中的所有动作要么全做，要么全不做，换言之，是一个不可分割的基本单位，在执行过程中不允许被中断 3.1 操作系统内核 1. 支撑功能 中断处理 时钟管理 原语操作 2. 资源管理功能 进程管理 存储器管理 设备管理 3.2 进程的创建 1. 进程图 进程图是用于描述一个进程的家族关系的有向树。 子进程可以继承父进程所拥有的资源。 当子进程被撤消时，应将其从父进程那里获得的资源归还给父进程。 在撤消父进程时，也必须同时撤消其所有的子进程。 2. 引起创建进程的事件 用户登录。分时系统中，用户通过终端登录成功后，系统将为用户建立一个进程。 作业调度。将作业调入内存后，创建进程。 提供服务。例如：I/O请求，打印进程等。 应用请求。基于应用进程的需求，由它自己创建一个新进程，以便使新进程以并发运行方式完成特定任务。 3. 进程的创建 调用进程创建原语步骤： 申请空白PCB。 为新进程分配资源。 初始化进程控制块。 初始化标识信息。 初始化处理机状态信息。使程序计数器指向程序的入口地址，使栈指针指向栈顶； 初始化处理机控制信息：进程的状态、优先级。 将新进程插入就绪队列，启动调度。 3.3 进程的终止 1. 引起进程终止的事件 正常结束。 异常结束： 越界错误。 保护错。 非法指令。 特权指令错。 运行超时。 等待超时。 算术运算错、被0除： I/O故障。 外界干预 操作员或操作系统干预。 由于某种原因，例如，发生了死锁，由操作员或操作系统终止该进程； 父进程请求终止该进程； 当父进程终止时，OS 也将他的所有子孙进程终止。 2. 进程的终止过程 根据被终止进程的PID找到它的PCB，从中读出该进程的状态。 若被终止进程正处于执行状态，应立即终止该进程的执行，重新进行调度。 若该进程还有子孙进程，立即将其所有子孙进程终止。 将被终止进程所拥有的全部资源，归还给其父进程，或者归还给系统。 将被终止进程的PCB从所在队列中移出 3.4 进程的阻塞和唤醒 1. 引起进程阻塞和唤醒的事件 向系统请求共享资源失败。 等待某种操作的完成：如I/O操作时进程进入阻塞状态，I/O完成后，被中断处理程序唤醒。 新数据尚未到达。处理数据的进程A阻塞，输入数据的进程B完成后去唤醒A。 无新工作可做, 如此时使用sleep（）进入休眠 2. 进程阻塞过程 正在执行的进程，当发现上述某事件时，由于无法继续执行，于是进程便通过调用阻塞原语block把自己阻塞； 把进程控制块中的现行状态由“执行”改为阻塞，并将PCB插入阻塞队列； 转调度程序进行重新调度，将处理机分配给另一就绪进程，并进行切换 3. 进程唤醒过程 当被阻塞进程所期待的事件出现时，则由有关进程（比如，用完并释放了该 I/O 设备的进程）调用唤醒原语 wakeup()，将等待该事件的进程唤醒。 唤醒原语执行的过程是：首先把被阻塞的进程从等待该事件的阻塞队列中移出，将其 PCB 中的现行状态由阻塞改为就绪，然后再将该 PCB 插入到就绪队列中。 3.5 进程的挂起与激活 进程的挂起：当出现了引起进程挂起的事件时（比如，用户进程请求将自己挂起，或父进程请求将自己的某个子进程挂起），系统将利用挂起原语suspend( )将指定进程挂起或处于阻塞状态的进程挂起 进程挂起的过程 首先检查被挂起进程的状态， 若处于活动就绪状态，便将其改为静止就绪； 对于活动阻塞状态的进程，则将之改为静止阻塞； 然后将被挂起进程的PCB复制到指定的内存区域。 进程的激活过程 当发生激活进程的事件时，例如，父进程或用户进程请求激活指定进程，系统将利用激活原语active( )将指定进程激活。 系统利用激活原语active( )将指定进程激活： 激活原语检查该进程的现行状态，若是静止就绪，便将之改为活动就绪； 若为静止阻塞，便将之改为活动阻塞。 四、进程的同步 4.1 进程同步的基本概念 进程同步机制的主要任务，是对多个相关进程在执行次序上进行协调，使并发执行的诸进程之间能按照一定的规则（或时序）共享系统资源，并能很好的相互合作，从而使程序的执行具有可再现性。 两种形式的制约关系 1）间接相互制约关系 并发执行的进程在使用共享资源时的关系，资源的互斥。 2）直接相互制约关系 多个进程为完成同一项任务而相互合作的关系。 临界资源 许多硬件资源例如打印机、磁带机等，都属于临界资源，诸进程间应采取互斥方式，实现对这种资源的共享 临界区 在每个进程中访问临界资源的那段代码称为临界区 临界区使用原则 空闲让进。如果临界区空闲，则只要有进程申请就立即让其进入。 忙则等待。每次仅允许一个进程处于临界区。 有限等待。进程只能在临界区内逗留有限时间，不得使其他进程在临界区外无限期等待。 让权等待。当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态。 4.2 硬件同步机制 关中断 利用 Test-and-Set 指令实现互斥 4.3 信号量机制 两个或多个进程可以通过传递信号进行合作，可以迫使进程在某个位置暂时停止执行（阻塞等待），直到它收到一个可以“向前推进”的信号（被唤醒）。 相应地，将实现信号灯作用的变量称为信号量。 信号量按照功能来分：互斥信号量和资源信号量。 互斥信号量：用于申请或释放资源的使用权，常初始化为1。 资源信号量：用于申请或归还资源，可以初始化为大于1的正整数，表示系统中某类资源的可用个数。 按照信号量机制的发展分为： 整形信号量 定义为一个整型量 ,仅能通过两个标准的原子操作 wait（S）和signal（S）来访问。又称为P、V操作。 123wait（S）： while S＜=0 do no-op S：=S--；signal（S）： S：=S++； 记录型信号量 记录型信号量机制，则是一种不存在“忙等”现象的进程同步机制。 记录型信号量的数据结构: 1234567891011121314typedef strust { int value； // value的初值表示系统中某类资源的数目， value的初始值&gt;1时，称为资源信号量， value的初始值=1时，称为互斥信号量 struct process_control_block *list；//信号量的阻塞队列} semaphore;wait（semaphore * S ）{ S-&gt;value--; if (S-&gt; value＜0) block（S-&gt;list）; //该进程阻塞, 进入s.list队列，“让权等待”； }signal(semaphore * S) { S-&gt; value++; // value的绝对值表示已阻塞的进程的数目。 If(S-&gt;value &lt;=0) wakeup(S-&gt;list); // 唤醒队首进程，并从队列中移出。} S-&gt; value ≥ 0 ，表示还可执行wait(s)而不会阻塞的进程数（可用资源数）。 每执行一次wait(s)操作，就意味着请求分配一个单位的资源 S-&gt; value &lt; 0 ，表示已无资源可用，因此请求该资源的进程被阻塞。 此时， S-&gt; value的绝对值等于该信号量阻塞队列中的等待进程数。 执行一次signal操作，就意味着释放一个单位的资源。 当仅有两个并发进程共享临界资源时，互斥信号量仅能取值0、1、－1。其中， S-&gt; value =1, 表示无进程进入临界区 S-&gt; value =0，表示已有一个进程进入临界区 S-&gt; value = - 1,则表示已有一进程正在等待进入临界区 当用s来实现n个进程的互斥时， S-&gt; value的取值范围为1～－（n-1） AND 型信号量 AND同步机制的基本思想：将进程在整个运行过程中需要的所有资源，一次性全都地分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源，也不分配给他。 原子操作：要么全部分配到进程，要么一个也不分配 . 在wait操作中，增加了一个“AND”条件，故称为AND同步，或称为同时wait操作 123456789101112131415161718192021Swait（S1，S2，···，Sn ） {while(TRUE) { if(Si&gt;=1 &amp;&amp;…&amp;&amp;Sn&gt;=1){ for(i=1;i&lt;=n;i++) Si--; break; }else {place the process in the waiting queue associated with the first Si found with Si＜1 ， and set the program count of this process to the beginning of Swait operation } }}Ssignal（S1，S2，···，Sn） while(TRUE) { for (i=1;i&lt;=n;i++) { Si++; Remove all the process waiting in the queue associated with Si into the ready queue。 } }} 信号量集 在记录型信号量机制中，wait(S)或signal(S)操作仅能对信号量施以加1 或减1 操作，意味着每次只能获得或释放一个单位的临界资源。 在每次分配时，采用信号量集来控制，可以分配多个资源。 12345678910111213Swait（S1，t1，d1，…，Sn，tn，dn）（满足ti≥ di） if S1 ≥t1 and…and Sn≥tn then for i：=1 to n do Si：＝Si一di； endfor else Place the executing process in the waiting queue of the first Si with Si＜ti and set its program counter to the beginning of the Swait operation。 endif Ssignal（S1，d1，···，Sn，dn） for i：=1 to n do Si:= Si十di； Remove all the process waiting in the queue associated with Si into the ready queue endfor； 4.4 信号量的应用 1. 利用信号量实现进程互斥 为使多个进程能互斥地访问某临界资源，只须为该资源设置一互斥信号量mutex，并设其初始值为1，然后将各进程访问该资源的临界区CS置于wait（mutex）和signal（mutex）操作之间即可。 2. 利用信号量实现前驱关系 在进程 P1 中使用 S1;signal(S); 在进程 P2 中，用 wait(S);S2; 则只有在进程 P1 执行完 S1 后进程 P2 才能成功执行 S2 4.5 管程机制 需要知道管程也是一种进程同步的机制。 其他管程相关的内容为自学内容。 五、经典进程的同步问题 5.1 生产者-消费者问题 生产者与消费者是一个广义的概念，可以代表一类具有相同属性的进程。 生产者和消费者进程共享一个大小固定的缓冲区 一个或多个生产者生产数据，并将生产的数据存入缓冲区， 并有一个消费者从缓冲区中取数据。 必须使生产者和消费者互斥进入缓冲区。即，某时刻只允许一个实体（生产者或消费者）访问缓冲区，生产者互斥消费者和其它任何生产者。 生产者不能向满缓冲区写数据，消费者也不能在空缓冲区中取数据，即生产者与消费者必须同步。 123456789101112131415161718192021222324252627 int in=0，out=0;Item buffer[n];Semaphore mutex=1,empty=n,full=0;Void proceducer() { do { producer an item nextp; … wait（empty）； wait（mutex）； buffer[in]：=nextp； in：=（in十1）% n； signal（mutex）； signal（full）；} while(TRUE);} void consumer() { do{ wait(full); wait（mutex）； nextc ：=buffer[out]； out：= （out十1）% n; signal（mutex）； signal（empty）； consumer the item in nextc; … } while(TRUE)} 注意 进程应该先申请资源信号量，再申请互斥信号量，顺序不能颠倒。 对任何信号量的wait与signal操作必须配对。同一进程中的多对wait与signal语句只能嵌套，不能交叉。 对同一个资源信号量的wait与signal可以不在同一个进程中。 wait与signal语句不能颠倒顺序，wait语句一定先于signal语句。 5.2 哲学家就餐问题 五个哲学家五只筷子，哲学家循环做着思考和吃饭的动作，吃饭程序是：先取左边筷子，再取右边筷子，再吃饭，再放筷子。 利用记录型信号量解决 为每个筷子设一把锁（信号量，初值为1） 每个哲学家是一个进程。 123456789101112Do{ wait（chopstick[i]）;取左筷子； wait(chopstick[(i+1)%5])；取右筷子；… eat;… signal(chopstick[i]);放左筷子 signal (Chopstick[(i+1)% 5]；放右筷子；… think;…} while[TRUE]; 这可能导致死锁 利用 AND 信号量解决 在哲学家进餐问题中，要求每个哲学家先获得两个临界资源(筷子)后方能进餐，这在本质上就是前面所介绍的AND同步问题，故用AND信号量机制可获得最简洁的解法,且可避免死锁 12345678910Do {…think；…Sswait(chopstick[(i+1) %5]，chopstick[i])；…eat；…Ssignat(chopstick[(i+1) % 5]，chopstick[i])；} while[TRUE]; 5.3 读/写者问题 该问题为多个进程访问一个共享数据区，如数据库、文件、内存区及一组寄存器等的数据问题建立了一个通用模型 若干读进程只能读数据，若干写进程只能写数据。 1）允许多个读者进程可以同时读数据； 2）不允许多个写者进程同时写数据，即只能互斥写数据； 3）若有写者进程正在写数据，则不允许读者进程读数据。 当一个读者正在读数据时，另一个读者也需要读数据，应允许第二个读者进入，同理第三个及随后更多的读者都被允许进入。 现在假设一个写者到来，由于写操作是排他的，所以它不能访问数据，需要阻塞等待。如果一直都有新的读者陆续到来，写者的写操作将被严重推迟。 该方法称为“读者优先”。即，一旦有读者正在读数据，允许多个读者同时进入读数据，只有当全部读者退出，才允许写者进入写数据。用信号量实现的具体过程见图 利用记录型信号量解决读者-写者问题 规则：只要有一个Reader进程在读，便不允许Writer进程去写。 为实现Reader与Writer进程间在读或写时的互斥而设置了一个互斥信号量Wmutex。 仅当Readcount=0, 表示尚无Reader进程在读时，Reader进程才需要执行Wait(Wmutex)操作。若wait(Wmutex)操作成功，Reader进程便可去读，相应地，做Readcount+1操作。 同理，仅当Reader进程在执行了Readcount减1操作后其值为0时，才须执行signal(Wmutex)操作，以便让Writer进程写。 又因为Readcount是一个可被多个Reader进程访问的临界资源，因此，应该为它设置一个互斥信号量rmutex。 1234567891011121314151617181920212223Semaphore rmutex=1,wmutex=1; int readcount=0; // 表示正在读的进程数目 void reader() { do{ wait(rmutex); // 保护Readcount变量同时只能被一个读者使用 if (readcount==0) wait(wmutex); //表示尚无Reader进程在读时，允许读，互斥写者 Readcount++; signal(rmutex); … perform read operation; … wait(rmutex); readcount--； if （readcount==0）signal(wmutex); //没有读者进程执行时，以便让Writer进程写。 signal(rmutex); } while(true);}Void writer() { do { wait(wmutex); perform write operation; signal(wmutex); } while(true); 六、进程间通信 低级通信：进程之间的互斥和同步，由于其所交换的信息量少而被归结为低级通信。 高级通信：是指用户可直接利用操作系统所提供的一组通信命令高效地传送大量数据的一种通信方式。 信号量机制作为同步工具是卓有成效的，但作为通信工具，则不够理想， 主要表现在下述两方面： (1) 效率低，生产者每次只能向缓冲池投放一个产品(消息)，消费者每次只能从缓冲区中取得一个消息； (2) 通信对用户不透明。 6.1 进程通信的类型 共享存储器系统—共享数据结构，共享存储区通信方式。 管道通信 消息传递方式 客户机—服务器系统—网络通信，套接字、RPC 1. 共享存储器系统 基于共享数据结构的通信方式。诸进程公用某些数据结构，借以实现诸进程间的信息交换。 如在生产者—消费者问题中，就是用有界缓冲区这种数据结构来实现通信的，这种通信方式是低效的，只适于传递相对少量的数据。 基于共享存储区的通信方式。由操作系统在内存中划分出一块区域作为共享存储区。 进程在通信前向系统申请共享存储区中的一个分区。 然后，申请进程把获得的共享存储分区连接到本进程上，此后便可象读/写普通存储器一样地读/写共享存储分区。 该方式下，通信进程之间的同步与互斥访问共享存储区可以由操作系统实现。 2. 管道（Pipe）通信 所谓“管道”，是指用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件，又名pipe文件。 向管道(共享文件)提供输入的发送进程(即写进程)， 以字符流形式将大量的数据送入管道； 而接受管道输出的接收进程(即读进程)，则从管道中接收(读)数据。由于发送进程和接收进程是利用管道进行通信的，故又称为管道通信。 这种方式首创于UNIX系统，由于它能有效地传送大量数据，因而又被引入到许多其它操作系统中。 为了协调双方的通信，管道机制必须提供以下三方面的协调能力 互斥，即当一个进程正在对pipe执行读/写操作时，其它(另一)进程必须等待。 同步，指当写(输入)进程把一定数量(如4 KB)的数据写入pipe，便去睡眠等待， 直到读(输出)进程取走数据后，再把他唤醒。当读进程读一空pipe时，也应睡眠等待，直至写进程将数据写入管道后，才将之唤醒。 确定对方是否存在，只有确定了对方已存在时，才能进行通信。 3. 消息传递系统 消息通信实现方法： 直接通信 间接通信 信箱 消息缓冲队列通信 6.2 消息传递通信的实现方式 1. 直接通信方式 这是指发送进程利用OS所提供的发送命令，直接把消息发送给目标进程。通常，系统提供下述两条通信命令(原语)： Send(Receiver, message); 发送一个消息给接收进程； Receive(Sender, message); 接收Sender发来的消息； 例如，原语Send(P2, m1)表示将消息m1发送给接收进程P2; 而原语Receive(P1，m1)则表示接收由P1发来的消息m1。 由于没有一个机构管理消息，因此发送方和接收方之间在程序设计时需要考虑同步问题。可能出现三种情况： 发送进程阻塞，接收进程阻塞，二者之间无缓冲时。 发送进程不阻塞，接收进程阻塞。 发送进程和接收进程均不阻塞。 2. 间接通信方式 信箱 进程之间的通信，需要通过某种中间实体（如共享数据结构等）来完成。 信箱的创建和撤消。进程可利用信箱创建原语来建立一个新信箱。创建者进程应给出信箱名字、信箱属性(公用、私用或共享)；对于共享信箱， 还应给出共享者的名字。当进程不再需要读信箱时，可用信箱撤消原语将之撤消。 消息的发送和接收。当进程之间要利用信箱进行通信时，必须使用共享信箱，并利用系统提供的下述通信原语进行通信。 Send(mailbox, message); 将一个消息发送到指定信箱； Receive(mailbox, message); 从指定信箱中接收一个消息； 信箱可由操作系统创建，也可由用户进程创建，创建者是信箱的拥有者。据此，可把信箱分为以下三类： 私用信箱 用户进程可为自己建立一个新信箱，并作为该进程的一部分。信箱的拥有者有权从信箱中读取消息，其他用户则只能将自己构成的消息发送到该信箱中。这种私用信箱可采用单向通信链路的信箱来实现。 当拥有该信箱的进程结束时，信箱也随之消失。 公用信箱 它由操作系统创建，并提供给系统中的所有核准进程使用。进程既可把消息发送到该信箱中，也可从信箱中读取发送给自己的消息。显然，公用信箱应采用双向通信链路的信箱来实现。通常，公用信箱在系统运行期间始终存在。 共享信箱 它由某进程创建，在创建时或创建后，指明它是可共享的，同时须指出共享进程(用户)的名字。信箱的拥有者和共享者，都有权从信箱中取走发送给自己的消息。 在利用信箱通信时，在发送进程和接收进程之间，存在以下四种关系： 一对一关系。这时可为发送进程和接收进程建立一条两者专用的通信链路，使两者之间的交互不受其他进程的干扰。 多对一关系。允许提供服务的进程与多个用户进程之间进行交互，也称为客户/服务器交互(client/server interaction) 一对多关系。允许一个发送进程与多个接收进程进行交互，使发送进程可用广播方式，向接收者(多个)发送消息。 多对多关系。允许建立一个公用信箱，让多个进程都能向信箱中投递消息；也可从信箱中取走属于自己的消息。 6.3 直接消息传递系统实例 消息缓冲队列通信机制： 发送进程利用send原语将消息直接发送给接收进程； 接收进程则利用receive原语接收消息。 1. 消息缓冲队列通信机制中的数据结构 消息缓冲区。在消息缓冲队列通信方式中，主要利用的数据结构是消息缓冲区。它可描述如下： Typedef struct message_buffer{ sender; 发送者进程标识符 size; 消息长度 text; 消息正文 struct message_buffer *next; 指向下一个消息缓冲区的指针 } PCB中有关通信的数据项。 在PCB中增加用于对消息队列进行操作和实现同步的信号量，并将它们置入进程的PCB中。在PCB中应增加的数据项可描述如下： typedef struct processcontrol_block { … struct message_buffer *mq; 消息队列队首指针 semaphore mutex; 消息队列互斥信号量 semaphore sm; 消息队列资源信号量 … } 2. 发送、接收原语 发送进程在利用发送原语发送消息之前，应先在自己的内存空间，设置一发送区a，把待发送的消息正文、发送进程标识符、消息长度等信息填入其中，然后调用发送原语，把消息发送给目标(接收)进程。 发送原语首先根据发送区a中所设置的消息长度a.size来申请一缓冲区i，接着，把发送区a中的信息复制到缓冲区i中。为了能将i挂在接收进程的消息队列mq上，应先获得接收进程的内部标识符j，然后将i挂在j.mq上。 由于该队列属于临界资源， 故在执行insert操作的前后，都要执行wait和signal操作。 12345678910111213141516171819202122232425262728void send(receiver, a) getbuf(a.size,i); //根据a.size申请缓冲区； i.sender∶ =a.sender; // 将发送者标识符复制给i // 将发送区a中的信息复制到消息缓冲区之中； i.size∶ =a.size; copy(i.text,a.text); i.next∶ =0; getid(PCBset, receiver.j); 获得接收进程内部标识符； wait(j.mutex); insert(j.mq, i); 将消息缓冲区插入消息队列； signal(j.mutex); signal(j.sm); //消息队列资源信号量加1 end void receive(b) { j∶ =internal name; // j为接收进程内部的标识符； wait(j.sm); //首先申请消息队列资源性信号量，从而才有权获得一个消息； wait(j.mutex); remove(j.mq, i); //将消息队列中第一个消息移出； signal(j.mutex); b.sender∶ =i.sender; // 将消息缓冲区i中的信息复制到接收区b; b.size∶ =i.size; copy(b.text,i.text); //将缓冲区i中的信息复制到接收区b； releasebuf(i); //释放消息缓冲区； } 七、线程 20世纪80年代中期，人们又提出了比进程更小的能独立运行的基本单位——线程（Threads）；以提高程序并发执行的程度，进一步提高系统的吞吐量。 线程能比进程更好地提高程序的并行执行程度，充分地发挥多处理机的优越性，在多处理机0S中也都引入了线程，以改善OS的性能。 7.1 线程的引入 为使程序能并发执行，系统还必须进行以下的一系列操作。 1) 创建进程 2) 撤消进程 3) 进程切换 由于进程是一个资源的拥有者，因而在创建、撤销和切换中，系统必须为此付出较大的时间和空间的开销。 进程的概念体现出两个特点： 资源所有权：一个进程包括一个保存进程映像的虚地址空间，并且随时分配对资源的的控制或所有权，包括内存、I/O通道、I/O设备、文件等。 调度／执行：进程是被操作系统调度的实体。 调度并分派的部分通常称为线程或轻便进程（lightweight process），而资源所有权的部分通常称为进程。 7.2 进程和线程的比较 线程具有许多传统进程所具有的特征，所以又称为轻型进程(Light-Weight Process) ，相应地把传统进程称为重型进程(Heavy-Weight Process)，传统进程相当于只有一个线程的任务。 在引入了线程的操作系统中，通常一个进程都拥有若干个线程，至少也有一个线程。 从调度性、并发性、系统开销和拥有资源等方面对线程和进程进行比较。 1) 调度 在传统的操作系统中，进程作为拥有资源和独立调度、分派的基本单位。而在引入线程的操作系统中，则把线程作为调度和分派的基本单位，而进程作为资源拥有的基本单位。 在同一进程中，线程的切换不会引起进程的切换，但从一个进程中的线程切换到另一个进程中的线程时，将会引起进程的切换。 并发性 在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，使得操作系统具有更好的并发性，从而能更加有效地提高系统资源的利用率和系统的吞吐量。 例如，在一个未引入线程的单CPU操作系统中，若仅设置一个文件服务进程，当该进程由于某种原因而被阻塞时，便没有其它的文件服务进程来提供服务。 在引入线程的操作系统中，则可以在一个文件服务进程中设置多个服务线程。当第一个线程等待时，文件服务进程中的第二个线程可以继续运行，以提供文件服务；当第二个线程阻塞时，则可由第三个继续执行，提供服务。显然，这样的方法可以显著地提高文件服务的质量和系统的吞吐量。 拥有资源 一般而言，线程自己不拥有系统资源(也有一点必不可少的资源)，但它可以访问其隶属进程的资源，即一个进程的代码段、数据段及所拥有的系统资源，如已打开的文件、I/O 设备等，可以供该进程中的所有线程所共享。 独立性 同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得多。 系统开销 由于一个进程中的多个线程具有相同的址空间，在同步和通信的实现方面线程也比进程容易。在一些操作系统中，线程的切换、同步和通信都无须操作系统内核的干预。 支持多处理机系统 可以将一个进程中的多个线程分配到多个处理机上，使他们并行执行，加速进程的完成。 7.3 线程的状态和控制块 线程运行状态 如同传统的进程一样，在各线程之间也存在着共享资源和相互合作的制约关系，致使线程在运行时也具有间断性。线程在运行时，也具有下述三种基本状态： 执行状态，表示线程正获得处理机而运行； 就绪状态， 指线程已具备了各种执行条件，一旦获得CPU便可执行的状态； 阻塞状态，指线程在执行中因某事件而受阻，处于暂停执行时的状态。 线程控制块 TCB 每个线程也有个控制块，包含的内容有： 标识符 一组寄存器 线程运行状态 优先级 线程专有存储区 信号屏蔽 堆栈指针 线程的创建和终止 在多线程OS环境下，应用程序在启动时，通常仅有一个线程在执行，该线程被人们称为“初始化线程”。在创建新线程时，提供相应的参数，如指向线程主程序的入口指针、堆栈的大小，以及用于调度的优先级等。在线程创建函数执行完后，将返回一个线程标识符供以后使用。 终止线程的方式有两种：一种是在线程完成了自己的工作后自愿退出；另一种是线程在运行中出现错误或由于某种原因而被其它线程强行终止。 多线程 OS 中的进程 在多线程OS中，进程是作为拥有系统资源的基本单位，通常的进程都包含多个线程并为它们提供资源，但此时的进程就不再作为一个执行的实体。 多线程OS中的进程有以下属性： (1) 作为系统资源分配的单位。 (2) 可包括多个线程。 (3) 进程不是一个可执行的实体 线程间的同步和通信 互斥锁是一种比较简单的、用于实现进程间对资源互斥访问的机制。由于操作互斥锁的时间和空间开锁都较低， 因而较适合于高频度使用的关键共享数据和程序段。互斥锁可以有两种状态， 即开锁(unlock)和关锁(lock)状态。 八、线程的实现 8.1 线程的实现方式 1. 内核支持线程（KST） 内核支持线程，也都同样是在内核的支持下运行的，即无论是用户进程中的线程，还是系统进程中的线程，他们的创建、撤消和切换等，也是依靠内核实现的。 此外，在内核空间还为每一个内核支持线程设置了一个线程控制块， 内核是根据该控制块而感知某线程的存在的，并对其加以控制。 内核线程运行于内核态。 内核支持线程的主要缺点是： 对于线程切换而言，其模式切换的开销较大，在同一个进程中，从一个线程切换到另一个线程时，需要从用户态转到内核态进行，切换完毕要从内核态返回用户态. 这是因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的，系统开销较大。 2. 用户级线程 用户级线程仅存在于用户空间中。对于这种线程的创建、 撤消、线程之间的同步与通信等功能，都无须利用系统调用来实现。 对于用户级线程的切换，通常是发生在一个应用进程的诸多线程之间，这时，也同样无须内核的支持。由于切换的规则远比进程调度和切换的规则简单，因而使线程的切换速度特别快。可见，这种线程是与内核无关的。 采用线程的优点: 在一个已有进程中创建一个新线程比创建一个全新进程所需的时间少。 终止一个线程比终止一个进程花费的时间少。 线程间切换比进程间切换花费的时间少。 线程提高了不同的执行程序间通信的效率。同一个进程中的线程共享存储空间和文件，它们无需调用内核就可以互相通信。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://20021123.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://20021123.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"操作系统 第一章 操作系统引论","slug":"操作系统-第一章-操作系统引论","date":"2023-06-25T07:14:29.000Z","updated":"2023-06-25T07:15:49.246Z","comments":true,"path":"2023/06/25/操作系统-第一章-操作系统引论/","link":"","permalink":"https://20021123.xyz/2023/06/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/","excerpt":"","text":"第一章 操作系统引论 一、操作系统的目标和作用 1.1 操作系统的目标 方便性：操作系统使计算机更易于使用 有效性：操作系统允许以更有效的方式使用计算机系统资源。（提高系统资源利用率、提高系统的吞吐量） 可扩展性：在操作系统中,允许有效地开发，测试和引进新的系统功能 开放性：实现应用程序的可移植性和互操作性,要求具有统一的开放的环境 1.2 操作系统的作用 OS 是用户与计算机硬件系统之间的接口：OS 处于用户与计算机硬件系统之间，用户通过OS来使用计算机系统 OS 作为计算机系统资源的管理者 处理机管理 存储器管理 I/O 设备管理 文件管理 OS 实现了对计算机资源的抽象： 对于一个完全无软件的计算机系统(即裸机)，它向用户提供的是实际硬件接口(物理接口)，用户必须对物理接口的实现细节有充分的了解，并利用机器指令进行编程，因此很难使用。 通过 OS 的 I/O 管理实现了对计算机资源的抽象，帮助用户对硬件资源的使用和管理 1.3 操作系统的发展动力 不断提高计算机资源利用率 方便用户 器件的不断更新换代 计算机体系结构的不断发展 不断提出新的应用需求 二、操作系统的发展过程 2.1 未配置操作系统的计算机系统 人工操作方式：人工控制 脱机输入输出方式：在一台外围机的控制下，把纸带(卡片)上的数据(程序)输入到磁带上。当CPU需要这些程序和数据时，再从磁带上将其高速地调入内存 2.2 单道批处理系统 单道批处理系统：系统对作业的处理都是成批进行的，且在内存中始终仅存一道作业运行，运行结束或出错，才自动调另一道作业运行，故称为单道批处理系统 主要特征：自动性，顺序性，单道性 主要优点：减少人工操作，解决了作业的自动接续 主要缺点：平均周转时间长，没有交互能力 2.3 多道批处理系统 多道程序的概念： 在内存中存放多道作业运行，运行结束或出错，自动调度内存中的另一道作业运行 多道程序带来的好处： 提高CPU的利用率。 提高内存和I/O设备利用率。 增加系统吞吐率。 主要特征：多道性、无序性、调度性 主要优点：提高了资源利用率和吞吐能力 缺点：平均周转时间长，无交互能力 需解决的问题： 处理机管理：分配和控制CPU。 存储器管理：为每道程序分配必要的内存空间。 I/O设备管理：I/O设备的分配与操纵。 文件管理：文件的存取、共享和保护。 作业管理：如何组织作业运行。 2.4 分时系统 分时系统是指，在一台主机上连接了多个带有显示器和键盘的终端，同时允许多个用户通过自己的终端，以交互方式使用计算机，共享主机中的资源。 分时系统能很好地将一台计算机提供给多个用户同时使用，提高计算机的利用率。还可以满足用户对人---机交互的需求。 特点 多路性：一个主机与多个终端相连 交互性：以对话的方式为用户服务 独占性：每个终端用户仿佛拥有一台虚拟机 及时性：用户的请求能在很短的时间内获得响应 2.5 实时系统 所谓实时系统：是计算机及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时设备和实时任务协调一致的运行 多路性：能对多个对象进行控制。 独立性：独立运行，不混淆，不破坏。 交互性：仅限于访问系统中某些特定的专用服务程序。 可靠性：高可靠性，应具有过载防护能力。 及时性：不同的系统要求不一样，控制对象必须在截止时间内完成。 2.6 微机操作系统的发展 单用户单任务操作系统 MS-DOS 单用户多任务操作系统 Android、Windows 多用户多任务操作系统 UNIX OS、Linux 三、操作系统的基本特征 3.1 并发 并发是最重要的特征，其它特征都以并发为前提 并行性：是指两个或多个事件在同一时刻发生。 并发性：是指两个或多个事件在同一时间间隔内发生。 在多道程序环境下，并发性是指在一段时间内，宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。 3.2 共享 共享：是指系统中的资源可供内存中多个并发执行的进程共同使用。 互斥共享方式： 把在一段时间内只允许一个进程访问的资源，称为临界资源。 系统中的临界资源可以提供给多个进程使用，但一段时间内仅允许一个进程使用，称为互斥共享方式。 同时访问方式： 一段时间内，多个进程可以同时使用这个资源。 从微观上看，多个进程交替互斥地使用系统中的某个资源。例如磁盘。 3.3 虚拟 是指通过某种技术把一个物理实体变为（映射为）若干个逻辑上的对应物，用于实现虚拟的技术称为虚拟技术。 虚拟处理机技术：分时实现 虚拟设备技术：SPOOLING技术（第五章） 虚拟磁盘技术 虚拟存储器技术：虚拟存储器（第四章） 3.4 异步 多道程序环境下程序（进程）以异步的方式执行，每道程序在何时执行、各自执行的顺序、完成时间都是不确定的，也是不可预知的。 1.4 操作系统的主要功能 处理机管理（CPU） 存储器管理 设备管理 文件管理 操作系统与用户之间的接口 1.5 操作系统的体系结构 5.1 传统操作系统结构 1. 无结构操作系统 在早期开发操作系统时，设计者只是把他的注意力放在功能的实现和获得高的效率上，缺乏首尾一致的设计思想。 OS是为数众多的一组过程的集合，各过程之间可以相互调用，在操作系统内部不存在任何结构，因此，有人把它称为整体系统结构。 缺陷： 设计出的操作系统既庞大又杂乱，缺乏清晰的程序结构。 编制出的程序错误很多，给调试工作带来很多困难；增加了维护人员的负担。 2. 模块化 OS 结构 使用分块结构的系统包含若干 module（模块）；其中，每一块实现一组基本概念以及与其相关的基本属性。 块与块之间的相互关系： 所有各块的实现均可以任意引用其它各块所提供的概念及属性。 优点 提高了OS设计的正确性、可理解性和可维护性。 增强了0S的可适应性。 加速了OS的开发过程。 缺点: 对模块的划分及对接口的规定要精确描述很困难 从功能观点来划分模块时，未能将共享资源和独占资源加以区别； 3. 分层结构 OS 使用分层系统结构包含若干 layer（层）；其中，每一层实现一组基本概念以及与其相关的基本属性。 层与层之间的相互关系： - 所有各层的实现不依赖其以上各层所提供的概念及其属性，只依赖其直接下层所提供的概念及属性； - 每一层均对其上各层隐藏其下各层的存在。 优点 易保证系统的正确性 易扩充和易维护性 缺点 系统效率低 5.2 客户/服务器（Client/Server Mode）简介 1. C/S 模式的由来、组成和类型 C/S 系统主要由三部分组成 客户机 服务器 网络系统 2. C/S 之间的交互 一次完整的交互过程可分为以下四步 客户发送请求信息 服务器接收信息 服务器回送消息 客户机接收消息 3. C/S 模式的优点 数据的分布处理和存储 便于集中管理 灵活性和可扩充性 易于改编应用软件 4. 缺点 不可靠性 瓶颈问题 5.3 面向对象程序设计技术简介 软工讲过，略 5.4 微内核 OS 结构 所谓微内核技术，是指精心设计的、能实现现代OS核心功能的小型内核，它与一般的OS(程序)不同， 它更小更精炼，它不仅运行在核心态，而且开机后常驻内存， 它不会因内存紧张而被换出内存 微内核所提供的功能: 操作系统的另一部分是内核，用来处理客户和服务器之间的通信， 即由内核来接收客户的请求，再将该请求送至相应的服务器；同时它也接收服务器的应答， 并将此应答回送给请求客户。 优点 提高了系统的可扩展性 增强了系统的可靠性 可移植性好 提供了对分布式系统的支持 缺点 运行效率有所降低： 消息传递开销+模式切换开销","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://20021123.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://20021123.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"数据库原理及应用","slug":"数据库原理及应用","date":"2023-06-07T17:42:48.000Z","updated":"2023-06-07T17:44:25.289Z","comments":true,"path":"2023/06/08/数据库原理及应用/","link":"","permalink":"https://20021123.xyz/2023/06/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/","excerpt":"","text":"关系模型 关系模型是一种采用关系二维表的数据结构形式存储实体及其实体间联系的数据模型。关系模型采用具有关系特征的二维表来组织与存储数据，并采用关系运算来操作数据。通常把具有关系特征的二维表称为“关系。具体来讲，关系是一种由行和列组成的、用于组织存储实体数据的二维表，满足 表中每行存储实体的一个实例数据 表中每列表示实体的一项属性 表中单元格只能存储单个值 表中不允许有重复行 表中不允许有重复列 表中行顺序任意 表中列顺序任意 关系模型的基本概念 定义1：域指一组具有相同数据类型的值的集合。关系模型用域表示实体属性的取值范围。通常用 表示某个域 定义2：给定一组域，这组域的笛卡尔积为 其中每一个向量 称为一个 元组，简称元组。向量中的每个 称为分量。 定义3：关系是 笛卡尔积元组集合中有特定意义的子集合。它表示为 其中 为关系的名称， 分别为 关系的属性， 为关系属性的个数，称为“元数”或“度数” 关系特性 在关系的数学定义中，关系可以是一个无限的原阻击和。此外笛卡尔积不满足交换律。这些特性不适合数据库实际应用处理要求，因此，需要对关系特性进行如下限制与约束 无限元组集合的关系在数据库系统中无实际意义。关系模型中的关系必须是有限的元组集合 为了使关系中的属性列可允许任意顺序，可给个属性列定义不同列;,b;消除元组属性列的有序性 关系模型的组成 数据结构 在关系模型中，采用具有关系特征的二维表数据结构来组织存储数据。一个关系数据库由若干关系表组成，并且表之间存在一定的关联 操作方式 关系模型中，对关系表的数据操作按照集合关系运算方式进行。常用的关系运算包括选择、投影、连接、除、并、交、差等数据查询操作，也包括插入、更新、删除等数据操作 数据约束 在关系模型中，关系模型的数据约束包括实体完整性约束、参照完整性约束和用户自定义约束 关系模型的操作 并运算 关系 与 并运算的结果集合由属于 或属于 的元组组合而成，其运算结果仍为 元关系 其中， 为元组 差运算 关系 与 差运算的结构有属于 且不属于 的所有元组组成，其运算结果仍为 元关系 交运算 关系 与 的交运算结构集合由既属于 又属于 的所有元组组成，其结果关系仍为 元关系 广义笛卡尔积 假设 有 个属性， 有 个属性，则关系 和 的广义笛卡尔积是一个 列 的元组集合。若 有 个元组， 有 个元组，则其广义笛卡尔积有 个元组 关系运算的数学符号定义 设关系模式为 ， 表示的是 是 的一个元组， 则表示元组 中对应属性 的一分量 设 ，其中 是 中的一部分，则 成为部分属性列或部分域列。 则表示 去掉 后剩余的部分列， 表示元组 在部分属性列 上各分量的集合 设 为 元关系， 为 元关系。若 ，则 表示元祖的连接，它是一个 列的元组，前 个来自 后 个来自 给定一个关系 ， 分别为 的属性组。当 时， 在 中的像集记为 该式表示 中属性组 上值为 的各元组在 上分量的集合 选择运算 选择运算是在关系 中选择出满足给定条件 的元祖集，记作 其中 表示选择条件，是一个值为“真”或“假”的逻辑表达式； 是 中任意一个元组，若代入 的结果为真，则这个元组就是 的一个元组，反之则不在结果集 投影运算 投影运算是从关系 中选择出部分属性列组成一个新的关系，记作 式中， 为 的部分属性列 连接运算 连接 连接是 和 的笛卡尔积中选取满足比较关系 的元组集合，组成新的关系，记作 式中， 分别为关系 上度数相等且有可以比较的属性组， 为比较运算符。当其取 时，又称为等值连接运算 自然连接 自然连接是一种特殊的等值连接运算，它要求两个关系中进行比较的分量必须是相同的属性组，而且还要在结果中去除重复列 外连接 左外连接：用空值填补与左侧关系不匹配的右侧关系元组 右外连接：同理 全外连接：同时完成左右两边 除运算 给定关系 和关系 中， 分别为部分属性组。 和 中的 可以由不同属性名，但必须来自相同的域集。 与 的除运算得到一个新的关系 ，记为 SQL 语句 数据定义、数据操纵、数据查询 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657CREATE DATABASE DB;CREATE TABLE Student( StudentID VARCHAR(20) PRIMARY KEY, NAME VARCHAR(20) NOT NULL, Birth DATE NOT NULL, Sex CHAR(2) NOT NULL CHECK(Sex IN('男','女')), Grade INT DEFAULT 2);CREATE TABLE Plan( ID SERIAL NOT NULL, CID CHAR(4) NOT NULL, TID CHAR(4) NOT NULL, FOREIGN KEY(CID) REFERENCES Course(CID), CONSTRAINT CoursePlan_PK PRIMARY KEY(CID, TID));ALTER TABLE Student ADD Email VARCHAR(20);CREATE INDEX BirthDay_Idx ON Student(Birth);INSERT INTO Student VALUES('1','张三','2021-04-01'，'男',2);UPDATE StudentSet Email='123@qq.com'where id = 1;DELETE FROM Studentwhere Name='张三';SELECT * FROM Student WHERE Birth BETWEEN '2000-01-01' AND '2000-12-31'ORDER BY Major ASC;SELECT COUNT(DISTINCT Major) as 专业数 FROM Student;SELECT Major as 专业, COUNT(SID) as 学生人数FROM StudentGroup BY MajorHAVING COUNT(*)&gt;3WHERE Sex='男';Select * from TeacherWHERE CID IN ( SELECT CID FROM College WHERE CName='计算机学院');SELECT C.CNAME, T.TNAME, P.CROOM, S.CNAMEFROM Course as C JOIN Plan as P ON C.CID=P.CIDJOIN Teacher AS T ON P.TID=T.TIDLEFT JOIN College AS S ON S.CID=T.CID; 数据控制语言 12CREATE ROLE User_Student_2021090922011 LOG IN INHERIT;GRANT SELECT, UPDATE ON Student_2021090922011 TO User_Student_2021090922011; 视图 1234CREATE VIEW BasicView asSELECT * FROM TEACHER;SELECT * FROM BasicView; 存储过程 1234567891011121314151617181920212223242526272829303132CREATE OR REPLACE FUNCTION Pro_CurrentSale(OUT total_qty INTEGER, OUT total_amount money) AS $$DECLAREtoday DATE := CURRENT_DATE;BEGINSELECT SUM(sale_qty), SUM(sale_amount) INTO total_qty, total_amountFROM SaleWHERE sale_date = today;END;$$ language plpgsql;DO $$DECLARE qty INTEGER; amount money;BEGIN call pro_currentsale(qty,amount); RAISE NOTICE '今日销售数量：%，销售金额：%。', qty, amount;END;$$ LANGUAGE plpgsql;-- -----------------------CREATE OR REPLACE FUNCTION count_failing_students()RETURNS TABLE (课程号 VARCHAR(20), 不及格人数 BIGINT) AS $$BEGINRETURN QUERYSELECT CID, COUNT(*) AS 不及格人数FROM GRADEWHERE Score &lt; 60GROUP BY CID;END;$$ LANGUAGE plpgsql; 触发器 12345678910111213141516171819202122232425262728CREATE OR REPLACE FUNCTION Tri_InsertSale() RETURNS TRIGGER AS $$BEGIN UPDATE Book SET stock_qty = stock_qty - NEW.sale_qty WHERE book_id = NEW.book_id; RETURN NEW;END;$$ LANGUAGE plpgsql;CREATE TRIGGER Tri_InsertSaleAFTER INSERT ON SaleFOR EACH ROWEXECUTE FUNCTION Tri_InsertSale();-- ------------------------------CREATE OR REPLACE FUNCTION grade_update_trigger_function()RETURNS TRIGGER AS $$BEGIN-- 插入修改前数据INSERT INTO GradeLOG ( 操作用户 , 学号 , 课程号 , 修改时间 , 修改前成绩 修改后成绩)VALUES (current_user, OLD.SID, OLD.CID, current_timestamp, OLD.Score, NEW.Score);RETURN NEW;END;$$ LANGUAGE plpgsql; CREATE TRIGGER grade_update_triggerAFTER UPDATE ON GRADEFOR EACH ROWEXECUTE FUNCTION grade_update_trigger_function(); E-R 模型 实体 实体是对现实世界中描述事物数据对象的抽象概念，通常使用两层矩形方框表示，并在顶层方框注明实体名称，下栏显示实体属性 作为标识符的属性需加上下划线。若是复合标识符，则构成复合标识符的所有属性都需加下划线。 联系 可以使用联系表示一个或多个实体之间的关联关系，用形似鸟脚的连线符号表示实体之间的联系 最小基数为 0/1 可以表示为圈或线 继承性分类 半圆：非互斥继承联系 半圆+X：互斥继承联系 半圆+横线：完整继承联系 半圆+横线+X：非完整继承联系 标识符依赖实体 若弱实体的标识符含有所依赖实体的标识符，则该弱实体称为标识符依赖弱实体，连线在弱实体一侧有一个三角形。而非标识符依赖实体的联系连线符号，在弱实体一侧仅为基本鸟足符号 数据库规范化设计 第一范式 在关系数据库中，第一范式是对关系标的基本要求。 第一范式指关系表的属性列不能重复，并且每个属性列都是不可分割的基本数据项 例如学生表中”联系方式“可能为邮箱或电话，不满足 1NF 范式，进行拆分即可 第二范式 第二范式要求关系表中的所有数据都要和该关系表的主键有完全函数依赖。若一个关系中的某些属性数据只和主键的一部分存在依赖关系，则不符合第二范式 例如关系 (A,B,N,O,P) 的复合主键为 (A,B) 那么 N，O，P 这三个非键属性都不存在只依赖 A 或 B 的情况，则该关系满足第二范式 第三范式 第三范式要求关系先满足 2NF，并且所有非主键属性均不存在传递函数依赖 例如学生（学号，系名，住址）有属性传递依赖学号→系名→住址，所以学号→住址。不满足 3NF，需要拆分为“学生”，“系信息”等新关系 巴斯-科德范式 BCNF 范式要求关系中所有函数依赖的决定因子必须是候选键 第四范式 当一个关系满足 BCNF 范式并消除了多值依赖时，满足第四范式 第五范式 若一个关系为消除其中连接依赖，进行投影分解，所分解的各个关系均包含原关系的一个候选键，则这些分解后的关系满足 5NF ODBC 使用 SQL 作为访问数据的标准，提供了最大限度的互操作性，应用程序可以通过 ODBC 访问不同的数据库管理系统 组成部分 ODBC 数据库应用程序：用高级语言和 ODBC 函数编写的应用程序，用于访问数据库。主要任务是向 BMS 发出请求和处理数据库返回的结果 驱动程序管理器：被包含在 ODBC32.dll 中，对用户透明。任务是管理 ODBC 驱动软件，为应用程序加载、调用和卸载 DB 驱动程序，是 ODBC 中最重要的部件 DBMS 驱动程序：提供了 ODBC 和数据库之间的接口，PostgreSQL 驱动程序封装在 posqlodbcx.dll 文件中 数据源：用于链接 DB 驱动程序与 DBS。数据源包含数据库位置和数据库类型等信息，实际是一种数据连接的抽象 JDBC 用于 Java 应用程序连接数据库的标准方法，是一种用于执行 SQL 语句的 Java API，可以为多种关系数据库提供统一的访问 JDBC 主要分为两部分：面相应用开发人员的应用开发 API 接口和面相数据库厂商的驱动程序开发者的 API 接口 JDBC 是一个类的集合，实现了 JDBC 所定义的类和接口，提供了一个能实现 java.sql.Driver 接口的类 访问数据库的步骤 加载 Java 包 java.sql.* 中的核心类和接口 创建数据库连接对象 创建 Statement 对象 调用Statement 对象的相关方法执行相对应的 SQL 语句 处理数据库的返回结果 关闭数据库连接 NoSQL CAP 在分布式的环境下设计和部署系统时，有3个核心的需求，CAP对应： ① 一致性（Consistency）任何一个读操作总是能读取到之前完成的写操作结果，也就是在分布式环境中，多点的数据是一致的。 ② 可用性（Availability）每一个操作总是能够在确定的时间内返回，也就是系统随时都是可用的。 ③ 分区容忍性（Partition Tolerance）在出现网络分区（比如断网）的情况下，分离的系统也能正常运行 BASE • Basically Available --基本可用；系统能够基本运行，一直提供服务。 • Soft-state --软状态/柔性事务。\"Soft state\" 可以理解为\"无连接\"的, 而\"Hard state\" 是\"面向连接\"的；系统不要求一直保持强一致状态。 • Eventual Consistency --最终一致性 系统在某个时刻达到最终一致性。 • BASE定义为CAP中AP的衍生，在分布式环境下， BASE是数据的属性，BASE强调基本的可用性，按照功能划分数据库. 5V Volume 超量 Velocity 高速 Variety 异构 Veracity 真实 Value 价值 NoSQL 分类 四种 类型 部分代表 特点 列族数据库 HbaseCassandraHypertable 顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势。 文档数据库 MongoDBCouchDB 文档存储一般用类似json的格式存储，存储的内容是文档型的。这样也就有有机会对某些字段建立索引，实现关系数据库的某些功能。 键值数据库 Tokyo Cabinet / TyrantBerkeley DBMemcacheDBRedis 可以通过key快速查询到其value。一般来说，存储不管value的格式，照单全收。 图数据库 Neo4JFlockDBInfoGrid 图形关系的最佳存储。使用传统关系数据库来解决的话性能低下，而且设计使用不方便。","categories":[{"name":"总结","slug":"总结","permalink":"https://20021123.xyz/categories/%E6%80%BB%E7%BB%93/"},{"name":"数据库","slug":"数据库","permalink":"https://20021123.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://20021123.xyz/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"数字图像处理","slug":"数字图像处理","date":"2023-06-07T17:41:33.000Z","updated":"2023-06-07T17:42:25.490Z","comments":true,"path":"2023/06/08/数字图像处理/","link":"","permalink":"https://20021123.xyz/2023/06/08/%E6%95%B0%E5%AD%97%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/","excerpt":"","text":"一、数字图像处理基础 数字图像的定义 像素组成的二维排列，可以用矩阵表示 数字图像由二维的元素组成，每一个元素具有一个特定的位置 和幅值 ，这些元素就称为像素 对于单色（灰度）图像而言，每个像素的亮度用一个数值来表示，通常数值范围在 到 之间， 表示黑、 表示白，其它值表示处于黑白之间的灰度 彩色图像可以用红、绿、蓝三元组的二维矩阵来表示。通常，三元组的每个数值也是在 到 之间， 表示相应的基色在该像素中没有，而 则代表相应的基色在该像素中取得最大值 像素的定义 数字图像由二维的元素组成，每一个元素具有一个特定的位置 和幅值 ，这些元素就称为像素 图像的采样和量化 大多数传感器的输出是连续电压波形 为了产生一幅数字图像，需要把连续的感知数据转化为数字形式，包括两种处理：取样和量化 取样：图像空间坐标的数字化 量化：图像函数值（灰度值）的数字化 数字图像的表示 二维离散亮度函数： ， 说明图像像素的空间坐标 函数值 代表了在点 处像素的灰度值 二维矩阵： 说明图像的宽和高。 矩阵元素 ，的值，表示图像在第 行，第 列的像素的灰度值； 表示几何位置 图像描述信息：如图像高度和宽度等信息 图像数据：顺序存放的连续数据 BMP格式： 位图文件头 位图信息头 调色板 图像数据 图像的质量 层次 灰度级：表示像素明暗程度的整数量 例如：像素的取值范围为 ，就称该图像为 个灰度级的图像 层次：表示图像实际拥有的灰度级的数量 例如：具有 种不同取值的图像，可称该图像具有 个层次 图像数据的实际层次越多，视觉效果就越好 对比度 指一幅图像中灰度反差的大小对比度=最大亮度/最小亮度 亮度 尺寸大小 细微层次 颜色饱和度 所谓的饱和度，指的其实是色彩的纯度，（也有叫彩度的）纯度越高，表现越鲜明，纯度较低，表现则较黯淡。如果说雪的颜色是最白的，那么可以说它的饱和度就是 了，那么同样是白色的东西，越没有雪那么白的我们就可以说它的饱和度越低。 像素的一些基本关系 相邻像素 4 邻域 用 表示像素 的 4 邻域 D 邻域 对角上的点 用 表示像素 的 D 邻域 8 邻域 4 邻域的点＋D 邻域的点 邻接与连通性 4 连通：对于具有值 的像素 和 ，如果 在集合 中，则称这两个像素是 4 邻接的 8 连通：对于具有值 的像素 和 ，如果 在集合 中，则称这两个像素是 8 邻接的 m 连通 对于具有值V的像素 和 ，如果: 在集合 中，或 在集合 中，并且 与 的交集没有值 的像素则称这两个像素是 m 邻接的，即 4 邻接和 D 邻接的混合邻接。 通路：如果从 点到 点，其中的每个点与前后都是 K 邻接的（K 代表 4、8、m），则说这两个点之间存在一条K通路，n是这个通路的长度，如果 和 是重合的，那么说这是一条闭合通路。 连通：对于图像中的某一个像素子集 U 和其中的两个点 和 ，如果 和 之间有一个有 U 中全部元素构成的通路，那就说 和 是连通的。 连通性是描述区域和边界的重要概念 两个像素邻接的两个必要条件是： 两个像素的位置是否相邻 两个像素的灰度值是否满足特定的相似性准则（或者是否相等） 距离 定义：对于像素 、 和 ，分别具有坐标 ， 和 ，如果 （，当且仅当 ） 则称 D 是距离函数或度量 欧式距离定义 对于这个距离计算法，具有与 距离小于等于某个值 的像素是：包含在以 为圆心，以 为半径的圆平面 距离（城市距离） 具有与 距离小于等于某个值r的那些像素形成一个菱形 距离（棋盘距离） 具有与 距离小于等于某个值r的那些像素形成一个正方形 二、空间域图像增强 图像处理分为两大类： 空间域：对原始图像的像素直接处理 变换域： 原始图像变换到变换域 变换域处理 反变换回到空间域 空间域增强： 是原图像 是处理后的图像 是作用于 的操作，定义在 的邻域 空间域增强的简化形式： 是 在任意点 的灰度级 是 在任意点 的灰度级 图像增强的目的与意义 好看 对于人，更容易直接发现图像的特征 对于机器，更容易后续处理 改善图像的视觉效果 强调图像的整体或局部特性，更易获得图像中的有用信息 基本概念 图像增强分为两类： 空间域增强：对图像的像素直接处理 频域增强：修改图像的傅里叶变换 点运算 图像反转 为图像的灰度级。作用：黑的变白，白的变黑 对数变换 有时原图的动态范围太大，超出某些显示设备的允许动态范围，如直接使用原图，则一部分细节可能丢失。解决办法是对原图进行灰度压缩，如对数变换 幂次变换 提高灰度级，在正比函数上方，使图像变亮 降低灰度级，在正比函数下方，使图像变暗 分段线性变换 对比度拉伸：提高图像处理时灰度级的动态范围 灰度级切片 关心范围指定较高值，其它指定较低值 关心范围指定较高值，其它保持不变 位平面切片 假设图像中每个像素的灰度级是 ，这可以用 位来表示，假设图像是由 个 位平面组成，范围从位平面 到位平面 。其中，位平面 包含图像中像素的最低位，位平面 包含像素的最高位 作用 通过对特定位提高亮度，改善图像质量 较高位（如前 位）包含大多数视觉重要数据 较低位（如后 位）对图像中的微小细节有作用 分解为位平面，可以分析每一位在图像中的相对重要性 代数运算 算术运算 加 去除叠加性噪声 生成图像叠加效果 减 显示两幅图像的差异，检测同一场景两幅图像之间的变化 如：前景检测 去除不需要的叠加性图案 图像分割：如分割运动的车辆，减法去掉静止部分，剩余的是运动元素和噪声 乘 图像的局部显示 用二值蒙板图像与原图像做乘法 除:一幅图像取反和另一幅图像相乘 逻辑运算 非 获得一个阴图像 获得一个子图像的补图像 与 求两个子图像的相交子图 或 合并子图像 异或 获得相交子图像 直方图运算 图像直方图的定义1 一个灰度级在范围 ， 的数字图像的直方图是一个离散函数 是图像中灰度级为 的像素个数 是第 个灰度级， 由于 的增量是 ，直方图可表示为： 即图像中不同灰度级像素出现的次数 图像直方图的定义2 其中 是图像中的像素总数 第二种定义 使函数值正则化到 区间，成为实数函数 函数值的范围与像素的总数无关 给出灰度级 在图像中出现的概率密度统计 直方图均衡化 希望一幅图像的像素占有全部可能的灰度级且分布均匀，能够具有高对比度 使用的方法是灰度级变换： 基本思想是把原始图的直方图变换为均匀分布的形式，这样就增加了像素灰度值的动态范围，从而达到增强图像整体对比度的效果 满足下列两个条件： 在区间 中为单值且单调递增 当 时， 条件 1 保证原图各灰度级在变换后仍保持次序 条件 2 保证变换前后灰度值动态范围的一致性 对于离散值 变换函数的离散形式为 对于范围 的图像，可以采用 或 空间滤波器 空间滤波和空间滤波器的定义 使用空间模板进行的图像处理，被称为空间滤波。模板本身被称为空间滤波器 平滑空间滤波器的作用 模糊处理:去除图像中一些不重要的细节 减小噪声 平滑空间滤波器的分类 线性滤波器：均值滤波器 非线性滤波器 最大值滤波器：用像素领域内的最大值代替该像素 中值滤波器：用像素领域内的中间值代替该像素 强迫突出的亮点（暗点）更象它周围的值，以消除孤立的亮点（暗点） 在去除噪音的同时，可以比较好地保留边的锐度和图像的细节（优于均值滤波器） 能够有效去除脉冲噪声：以黑白点叠加在图像上 最小值滤波器：用像素领域内的最小值代替该像素 锐化滤波器 锐化滤波器的主要用途 突出图像中的细节，增强被模糊了的细节 印刷中的细微层次强调。弥补扫描对图像的钝化 超声探测成像，分辨率低，边缘模糊，通过锐化来改善 图像识别中，分割前的边缘提取 锐化处理恢复过度钝化、暴光不足的图像 尖端武器的目标识别、定位 锐化滤波器的分类 二阶微分滤波器－拉普拉斯算子 一阶微分滤波器－梯度算子 Roberts交叉梯度算子 Prewitt梯度算子 Sobel梯度算子 三、彩色图像处理 彩色基础知识 三原色 红色（Red）、绿色（Green）、蓝色（Blue） 原色相加可产生二次色 深红色：红＋蓝 青色：绿＋蓝 黄色：红＋绿 彩色空间 RGB CCD 技术直接感知 R,G,B 三个分量 是图像成像、显示、打印等设备的基础 CMY CMY（青、深红、黄）、CMYK（青、深红、黄、黑） 运用在大多数在纸上沉积彩色颜料的设备，如彩色打印机和复印机 CMYK 打印中的主要颜色是黑色 等量的 CMY 原色产生黑色，但不纯 在 CMY 基础上，加入黑色，形成 CMYK 彩色空间 HSI 色调、饱和度、亮度 两个特点： I 分量与图像的彩色信息无关 H 和 S 分量与人感受颜色的方式是紧密相连的 将亮度（I）与色调（H）和饱和度（S）分开，避免颜色受到光照明暗（I）等条件的干扰，仅仅分析反映色彩本质的色调和饱和度 广泛用于计算机视觉、图像检索和视频检索 YIQ Y 指亮度（Brightness）,即灰度值 I 和 Q 指色调，描述色彩及饱和度 用于彩色电视广播，被北美的电视系统所采用（属于 NTSC 系统） Y 分量可提供黑白电视机的所有影像信息 YUV Y 指亮度,与 YIQ 的 Y 相同 U 和 V 也指色调，不同于 YIQ 的 I 和 Q 用于彩色电视广播，被欧洲的电视系统所采用（属于 PAL 系统） Y 分量也可提供黑白电视机的所有影像信息 YCbCr Y 指亮度,与 YIQ 和 YUV 的 Y 相同 Cb 和 Cr 由 U 和 V 调整得到 JPEG 采用的彩色空间 伪彩色处理 什么叫伪彩色图像处理? 也叫假彩色图像处理 根据一定的准则对灰度值赋以彩色的处理 区分：伪彩色图像、真彩色图像、单色图像 为什么需要伪彩色图像处理? 人类可以辨别上千种颜色和强度，只能辨别二十几种灰度 怎样进行伪彩色图像处理？ 强度分层技术 把一幅图像描述为三维函数（x,y,f(x,y)） 分层技术：放置平行于(x,y)坐标面的平面 每一个平面在相交区域切割图像函数 灰度级到彩色转换技术 对任何输入像素的灰度级执行3个独立变换 个变换结果分别送入彩色监视器的红、绿、蓝三个通道产生一幅合成图像 全彩色图像处理 全彩色图像处理研究分为两大类： 分别处理每一分量图像，然后，合成彩色图像 直接对彩色像素处理： 个颜色分量表示像素向量。令 c 代表 RGB 彩色空间中的任意向量 彩色变换 选择的彩色空间决定 的值，如 RGB 彩色空间，, 表示红、绿、蓝分量；CMYK，则 彩色图像平滑和尖锐化 令 表示在 RGB 彩色图像中定义一个中心在 的邻域的坐标集，在该邻域中 RGB 分量的平均值为 RGB 彩色空间，分别计算每一分量图像的拉普拉斯变换 彩色分割（把一幅图像分成区域） HSI彩色空间分割——直观 H色调图像方便描述彩色 S饱和度图像做模板分离感兴趣的特征区 I强度图像不携带彩色信息 RGB彩色空间——直接 令z代表RGB空间中的任意一点，a是分割颜色样本集的平均颜色向量 是距离阈值，小于则 和 相似，反之则不然 四、频率域滤波 傅里叶变换及其反变换 傅里叶级数，在时域是一个周期且连续的函数，而在频域是一个非周期离散的函数。 傅里叶变换，则是将一个时域非周期的连续信号，转换为一个在频域非周期的连续信号 欧拉公式 一维 FT 及其反变换 连续函数 的傅里叶变换 傅里叶变换的反变换 离散函数 其中 的傅里叶变换 的反变换 由欧拉公式得 二维 DFT 一个图像尺寸为 的函数 反变换 位置的傅里叶变换值为 即 的均值，原点 的傅里叶变换是图像的平均灰度。 称为频率谱的直流分量(系数)，其它 值称为交流分量(交流系数)。 幅度谱和相位谱 幅度谱 ##### 相位谱 幅度谱又叫频率谱，在图像增强中主要关心的对象。 频域下每一点 的幅度， 可用来表示该频率的波在叠加中所占的比例。 直接反映频率信息，频率滤波的主要信息 傅里叶变换的性质 线性性质 平移性 当 即如果需要将频域的坐标原点从显示屏起始点（0，0）移至显示屏的中心点只要将f(x,y)乘以(-1)x+y因子再进行傅里叶变换即可实现。 周期性 共轭对称性 旋转不变性 该性质表明，若f(x,y)旋转θ0角度，则F(u,v)也旋转相同角度，反之亦然。 快速傅里叶变换（FFT） 五、图像增强 频率域滤波 当从变换的原点移开时，低频对应着图像的慢变化分量，如图像的平滑部分 进一步离开原点时，较高的频率对应图像中变化越来越快的灰度级，如边缘或噪声等尖锐部分 空间域乘法可以通过频率域的卷积获得 空间域和频率域中的滤波器组成了傅里叶变换对 给出在频率域的滤波器，可以通过反傅里叶变换得到在空间域对应的滤波器，反之亦然 滤波在频率域中更为直观，但在空间域一般使用更小的滤波器模板 可以在频率域指定滤波器，做反变换，然后在空间域使用结果滤波器作为在空间域构建小滤波器模板的指导 高斯频率域低通滤波器函数 对应空间域高斯低通滤波器为 高斯频率域高通滤波器函数 对应空间域高斯高通滤波器为 频率域平滑（低通）滤波器 低通滤波器：使低频通过而使高频衰减的滤波器 被低通滤波的图像比原始图像少尖锐的细节部分而突出平滑过渡部分 对比空间域滤波的平滑处理，如均值滤波器 边缘和噪声等尖锐变化处于傅里叶变换的高频部分 平滑可以通过衰减高频成分的范围来实现 理想低通滤波器 截断傅里叶变换中的所有高频成分，这些高频成分处于指定距离 之外 结论：半径 越小，模糊越大；半径 越大，模糊越小 振铃现象 巴特沃斯低通滤波器(BLPF) 不同于 ILPF，BLPF 变换函数，在通带与被滤除的频率之间没有明显的截断 当 时， (最大值是1，当 ) 可用于平滑处理，如图像由于量化不足产生虚假轮廓时，常可用低通滤波进行平滑以改进图像质量。通常BLPF的平滑效果好于ILPF（振铃现象）。 高斯低通滤波器(GLPF) 其中 是点 距原点的距离，使 GLPF 不能达到有相同截止频率的二阶 BLPF 的平滑效果 GLPF 没有振铃 如果需要严格控制低频和高频之间截至频率的过渡，选用 BLPF，代价是可能产生振铃 低通滤波器的应用实例：模糊,平滑等 字符识别：通过模糊图像，桥接断裂字符的裂缝 印刷和出版业：从一幅尖锐的原始图像产生平滑、柔和的外观，如人脸，减少皮肤细纹的锐化程度和小斑点 处理卫星和航空图像：尽可能模糊细节，而保留大的可识别特征。低通滤波通过消除不重要的特征来简化感兴趣特征的分析 频率域锐化（高通）滤波器 高通滤波器：使高频通过而使低频衰减的滤波器 被高通滤波的图像比原始图像少灰度级的平滑过渡而突出边缘等细节部分 对比空间域的梯度算子、拉普拉斯算子 理想高通滤波器 振铃问题十分明显 巴特沃思高通滤波器 高斯高通滤波器 频率域的拉普拉斯算子 原点从 平移到 ，所以滤波函数平移为 从原始图像中减去拉普拉斯算子部分，形成 的增强图像 钝化模板、高频提升滤波和高频加强滤波 为什么要进行高频提升和高频加强？ 高频滤波后的图像，其背景平均强度减小到接近黑色（因为高通滤波器滤除了傅里叶变换的零频率成分: ） 解决办法：把原始图像加到过滤后的结果，如拉普拉斯算子增强，这种处理称为高频提升过滤 钝化模板(锐化或高通图像)：从一幅图像减去其自身模糊图像而生成的锐化图像构成。在频率域，即从图像本身减去低通滤波（模糊）后的图像而得到高通滤波（锐化）的图像 高频提升过滤 当 即高通过率；当 ，累加图像本身 因此高频提升过滤可定义为 高频提升加强 用图像的高频成分进行增强 增加a的目的是使零频率不被滤波器过滤 当 时转化为高频提升过滤 当 ，高频得到加强 六、图像复原 图像退化/复原过程的模型 什么是退化？ 成像过程中的”退化”，是指由于成像系统各种因素的影响，使得图像质量降低 引起图像退化的原因 成像系统的散焦 成像设备与物体的相对运动 成像器材的固有缺陷 外部干扰等 图像复原概述 与图像增强相似，图像复原的目的也是改善图像质量 图像增强主要是一个主观过程，而图像复原主要是一个客观过程 图像增强被认为是一种对比度拉伸，提供给用户喜欢接收的图像；而图像复原技术追求恢复原始图像的最优估值 图像复原技术可以使用空间域或频率域滤波器实现 图像复原可以看作图像退化的逆过程，是将图像退化的过程加以估计，建立退化的数学模型后，补偿退化过程造成的失真 在图像退化确知的情况下，图像退化的逆过程是有可能进行的 但实际情况经常是退化过程并不知晓，这种复原称为盲目复原 由于图像模糊的同时，噪声和干扰也会同时存在，这也为复原带来了困难和不确定性 噪声模型 数字图像的噪声主要来源于图像的获取和传输过程 图像获取的数字化过程，如图像传感器的质量和环境条件 图像传输过程中传输信道的噪声干扰，如通过无线网络传输的图像会受到光或其它大气因素的干扰 一些重要的噪声 高斯噪声 瑞利噪声 伽马（爱尔兰）噪声 指数分布噪声 均匀分布噪声 脉冲噪声（椒盐噪声） 高斯噪声 高斯噪声的概率密度函数（PDF）由下式给出 均匀分布噪声 脉冲噪声（椒盐噪声） 如果 或 为零，则脉冲噪声称为单极脉冲 如果 或 均不为零，则脉冲噪声称为双极脉冲噪声或椒盐噪声 脉冲噪声可以为正，也可为负 标定以后，脉冲噪声总是数字化为最大值（纯黑或纯白） 通常，负脉冲以黑点（胡椒点）出现，正脉冲以白点（盐点）出现 几种噪声的运用 高斯噪声源于电子电路噪声和由低照明度或高温带来的传感器噪声 瑞利噪声对于表征远距离成像噪声有用 伽马分布和指数分布用于表征激光成像噪声 脉冲噪声用于成像中的短暂停留中，如错误的开关操作 样本噪声图像和它们的直方图 上述噪声图像的直方图和它们的概率密度函数曲线对应相似，前面5种噪声的图像并没有显著不同，但它们的直方图具有明显的区别 周期噪声 周期噪声是在图像获取中从电力或机电干扰中产生 周期噪声可以通过频率域滤波显著减少 空间域滤波复原（唯一退化是噪声） 当唯一退化是噪声时 噪声项未知，不能从 或 减去噪声 可以选择空间滤波方法进行图像复原 图像复原的空间滤波器 均值滤波器 算术均值滤波器、几何均值滤波器、谐波均值滤波器、逆谐波均值滤波器 算术均值滤波器和几何均值滤波器适合于处理高斯或均匀等随机噪声 谐波均值滤波器适合于处理脉冲噪声 缺点：必须事先知道噪声是暗噪声还是亮噪声，以便于选择合适的Q符号 顺序统计滤波器 中值滤波器、最大值滤波器、最小值滤波器、中点滤波器、修正后的阿尔法均值滤波器 在相同尺寸下，比起均值滤波器引起的模糊少；对单极或双极脉冲噪声非常有效 自适应滤波器 自适应局部噪声消除滤波器、自适应中值滤波器 行为变化基于由 矩形窗口 定义的区域内图像的统计特性 与前述滤波器相比，性能更优，但也增加了算法复杂性 频率域滤波复原（削减周期噪声） 图像复原的频率域滤波器 带阻滤波器 带阻滤波器：阻止一定频率范围内的信号通过而允许其它频率范围内的信号通过，消除或衰减傅里叶变换原点处的频段 理想带阻滤波器 巴特沃思带阻滤波器 高斯带阻滤波器 带通滤波器 带通滤波器：允许一定频率范围内的信号通过而阻止其它频率范围内的信号通过 陷波滤波器 阻止或通过事先定义的中心频率邻域内的频率 由于傅里叶变换是对称的，陷波滤波器必须以关于原点对称的形式出现 如果陷波滤波器位于原点处，则以它本身形式出现 陷波带通滤波器 通过包含在陷波区的频率 当 时，陷波带通滤波器变为低通滤波器 七、图像压缩 基本概念 为什么需要图像压缩 图像的数据量通常很大，对存储、处理和传输带来许多问题（对比视频） 不断扩大的图像应用 一般分为两类： 无损压缩：在压缩和解压缩过程中没有信息损失 有损压缩：能取得较高的压缩率，但压缩后不能通过解压缩恢复原状 其它：如根据需要，既可进行无损，也可进行有损压缩的技术；准无损技术 图像压缩的理论基础 信息论 图像处理的概念和技术 压缩方法 预测编码方法（对应空域方法） 变换编码方法（对应频域方法） 数据冗余的概念 数据是用来表示信息的。如果不同的方法为表示给定量的信息使用了不同的数据量，那么使用较多数据量的方法中，有些数据必然是代表了无用的信息，或者是重复地表示了其它数据已表示的信息，这就是数据冗余的概念。 相对数据冗余的定义 如果 和 代表两个表示相同信息的数据集合中所携载信息单元的数量，则 表示的数据集合的相对数据冗余 定义为： 称为压缩率，定义为 n1相对于n2 对应的情况 n1 = n2 1 0 第1种表达相对第2种表达不含冗余数据 n1 &gt;&gt; n2 ∞ 1 第1种数据集合包含相当多的冗余数据 n1 &lt;&lt; n2 0 ∞ 第2种数据集合包含相当多的冗余数据 三种基本的数据冗余 编码冗余 像素间冗余 心理视觉冗余 如果能减少或消除上述三种冗余的1种或多种冗余，就能取得数据压缩的效果 什么是编码冗余？ 如果一个图像的灰度级编码，使用了多于际需要的编码符号，就称该图像包含了编码冗余 如果用8位表示黑白二值图像的像素，我们就说该图像存在编码冗余，因为该图像的像素只有两个灰度，用一位即可表示。 如果用于表示每个 值的比特数为 ，则表达每个像素所需的平均比特数为 什么是像素间冗余？ 反映图像中像素之间的相互关系 因为任何给定像素的值可以根据与这个像素相邻的像素进行预测，所以单个像素携带的信息相对较少 对于一幅图像，很多单个像素对视觉的贡献是冗余的。它的值可以通过与它相邻的像素值为基础进行预测 什么是心理视觉冗余？ 人眼感觉到的图像区域亮度不仅取决于该区域的反射光，例如根据马赫带效应，在灰度值为常数的区域也能感觉到灰度值的变化 这是由于眼睛对所有视觉信息感受的灵敏度不同。在正常视觉处理过程中各种信息的相对重要程度不同 有些信息在通常的视觉过程中与另外一些信息相比并不那么重要，这些信息被认为是心理视觉冗余的，去除这些信息并不会明显降低图像质量 由于消除心理视觉冗余数据会导致一定量信息的丢失，所以这一过程通常称为量化 心理视觉冗余压缩是不可恢复的，量化的结果导致了数据有损压缩 保真度准则 图像压缩可能会导致信息损失，如去除心理视觉冗余数据 需要评价信息损失的测度以描述解码图像相对于原始图像的偏离程度，这些测度称为保真度准则 常用保真度准则分为两大类： 客观保真度准则 主观保真度准则 客观保真度准则 当所损失的信息量可以用编码输入图像与编码输出图像的函数表示时，它就是基于客观保 真度准则的 常用的两种客观保真度准则 均方根误差 均方信噪比 令 表示输入图， 表示先压缩后解压的近似，则 与 的误差定义为 均方根误差 均方信噪比 均方根信噪比 图像压缩模型 信源编码器：减少或消除输入图像中的编码冗余、像素间冗余及心理视觉冗余 转换器：减少像素间冗余 量化器：减少心理视觉冗余，该步操作是不可逆的 符号编码器：减少编码冗余 并不是每个图像压缩系统都必须包含这3种操作，如进行无误差压缩时，必须去掉量化器 符号解码器：进行符号编码的逆操作 反向转换器：进行转换器的逆操作 信道是有噪声的或易产生误差时，信道编码器和信道解码器对整个编解码过程非常重要 由于信源编码器的输出数据一般只有很少的冗余，所以它们对输出噪声很敏感 汉明（Hamming）编码：在编了码的码字后面增加足够的比特位以保证各个正确的码字之间至少有一定数量的比特位不相同 信息论基础 信道是连接信源和用户的物理媒介。它可以是电话线、无线传播、导线或 internet 每个信源输出的平均信息，也称为信源的熵为 如果信源符号的出现是等可能性的，则上述熵被最大化，此时信源提供最大信息量 无损压缩 无误差压缩的必要性 在医疗或商业文件的归档，有损压缩因为法律原因而被禁止 卫星成像的收集，考虑数据使用和所花费用，不希望有任何数据损失 X光拍片，信息的丢失会导致诊断的正确性 无误差压缩技术 减少像素间冗余 减少编码冗余 无误差压缩 变长编码 即把最短的码字赋予出现概率最大的灰度级，减少编码冗余 霍夫曼（Huffman）编码 将需要考虑的符号概率排序，并将最低概率的符号联结为一个单一符号 对每个化简后的信源进行编码，从最小的信源开始，一直编码到原始的信源 其它变长编码 算术编码 LZW 编码 位平面编码 无损预测编码 霍夫曼编码 ①将信源符号按出现概率从大到小排成一列，然后把最末两个符号的概率相加，合成一个概率。 ②把这个符号的概率与其余符号的概率按从大到小排列，然后再把最末两个符号的概率加起来，合成一个概率。 ③重复上述做法，直到最后剩下两个概率为止。 ④从最后一步剩下的两个概率开始逐步向前进行编码。每步只需对两个分支各赋予一个二进制码，如对概率大的赋予码元 0，对概率小的赋予码元 1。 其它接近最佳的变长编码：为什么需要？ 当对大量符号进行编码，构造霍夫曼编码比较复杂 对 J 个信源符号，需要进行 J-2 次信源化简和 J-2 次编码分配 对 256 个灰度级图像，需要 254 次信源化简和 254 次编码分配 考虑牺牲编码效率以减少编码构造的复杂性 算术编码 算术编码是信息保持型编码，它不像哈夫曼编码，无需为一个符号设定一个码字; 算术编码分为固定方式和自适应方式两种编码; 选择不同的编码方式，将直接影响到编码效率; 自适应算术编码的方式，无需先定义概率模型，适合于无法知道信源字符概率分布的情况; 当信源字符出现的概率比较接近时，算术编码效率高于哈夫曼编码的效率，在图像通信中常用它来取代哈夫曼编码; 实现算术编码算法的硬件比哈夫曼编码复杂。 LZW编码 消除像素间冗余 是由 Lemple 和 Ziv 最早提出，然后由 Welch 充实的有专利保护的 LZW 算法 将原始数据中的重复字符串建立一个字串表，然后用该重复字串在字串表中的索引替 代原始数据达到压缩的目的 一个由 8 位组成的文件可以被编成 12 位的代码。在 ＝ 个可能的代码中，＝ 个 代表所由可能的单个字符（8位），剩下的 3840 个代码分配给压缩过程中出现的字符串 每当表中没有的字符串第一次出现时，它就被原样保存，同时将分配给它的代码也保存 之后，当这个串再次出现时，只将它的代码保存，这就去掉了文件冗余信息 不但字符串表是在压缩过程中动态生成，而且字符串表也不必保存在压缩文件里，因为 解压缩算法可以由压缩文件中的信息重构 使用 LZW 的文件格式包括 GIF，TIFF 和 PDF 等。 优点 与字符出现频率无关，能有效利用字符出现频率冗余度进行压缩. 无附加信息，字典是自适应生成的，有较大改进空间。 缺点 适用范围是原始数据串中有大量的子串多次重复出现。如果重复不多，反而会增加数据。 给不同的码字分配固定长度的整数，并且不考虑信息源的概率分布 无损预测编码(Lossless Predictive Coding) 去除像素冗余。 认为相邻像素的信息有冗余。当前像素值可以用先前的像素值来获得。 用当前像素值fn，通过预测器得到一个预测值，对当前值和预测值求差。对差编码，作为压缩数据流中的下一个元素。 八、形态学图像处理 概述 用数学形态学（也称图像代数）表示以形态为基础对图像进行分析的数学工具 基本思想是用具有一定形态的结构元素去度量和提取图像中的对应形状以达到对图像分析和识别的目的 形态学图像处理的数学基础和所用语言是集合论 形态学图像处理的应用可以简化图像数据， 保持它们基本的形状特性，并除去不相干的结构 形态学图像处理的基本运算有 4 个：膨胀、腐蚀、开操作和闭操作 集合论基础知识 复习集合的并、交、补、差 集合B的反射B ，定义为 即关于原集合原点对称 集合 平移到点 表示为 ，定义为 膨胀与腐蚀 腐蚀就是将图像的边缘缩小些。目的是将目标的边缘的“毛刺”踢除掉。作用是消除物体边界点，目标缩小，可以消除小于结构元素的噪声点； 膨胀就是将图像的边缘扩大些。目的是将目标的边缘或者是内部的坑填掉。作用是将与物体接触的所有背景点合并到物体中，使目标增大，可添补目标中的空洞。 腐蚀 被 腐蚀定义为 对Z中的集合A和B，B对A进行腐蚀的整个过程如下： 用结构元素B，扫描图像A的每一个像素 用结构元素与其覆盖的二值图像做“与”操作 如果都为1，结果图像的该像素为1，否则为0。腐蚀处理的结果是使原来的二值图像减小一圈。 使用腐蚀消除图像的细节部分，产生滤波器的作用 膨胀 被 膨胀定义为 用结构元素B，扫描图像A的每一个像素 用结构元素与其覆盖的二值图像做“或”操作 如果都为0，结果图像的该像素为0。否则为1 使用膨胀可以桥接文字裂缝 原始图像 膨胀 腐蚀 开操作与闭操作 开操作 使图像的轮廓变得光滑，断开狭窄的间断和消除细的突出物 使用结构元素B对集合A进行开操作，定义为： 含义：先用B对A腐蚀，然后用B对结果膨胀 闭操作 同样使图像的轮廓变得光滑，但与开操作相反，它能消除狭窄的间断和长细的鸿 沟，消除小的孔洞，并填补轮廓线中的裂痕 使用结构元素B对集合A进行闭操作，定义为： 含义：先用B对A膨胀，然后用B对结果腐蚀 形态学的主要应用 边界提取 定义为 九、图像分割 概述 分割的目的：将图像划分为不同区域 三大类方法 根据区域间灰度不连续搜寻区域之间的边界，在间断检测、边缘连接和边界检测介绍 以像素性质的分布进行阈值处理，在阈值处理介绍 直接搜寻区域进行分割，在基于区域的分割中介绍 在对图像的研究和应用中，人们往往仅对图像中的某些部分感兴趣，这些部分一般称为目 标或前景 为了辨识和分析目标，需要将有关区域分离提取出来，在此基础上对目标进一步利用，如 进行特征提取和测量 图像分割就是指把图像分成各具特性的区域并提取出感兴趣目标的技术和过程 特性可以是灰度、颜色、纹理等，目标可以对应单个区域，也可以对应多个区域 图像分割算法一般是基于亮度值的不连续性和相似性 不连续性是基于亮度的不连续变化分割图像，如图像的边缘 根据制定的准则将图像分割为相似的区域，如阈值处理、区域生长、区域分离和聚合 间断检测 点检测 使用如图所示的模板，如果 ，则在模板中心位置检测到一个点 基本思想：如果一个孤立点与它周围的点不同，则可以使用上述模板进行检测。 注意：如果模板响应为0，则表示在灰度级为常数的区域 线检测 4个线检测模板 第一个模板对水平线有最大响应 第二个模板对 方向线有最大响应 第三个模板对垂直线有最大响应 第四个模板对 方向线有最大响应 用R1,R2,R3和R4分别代表水平、、垂直和 方向线的模板响应，在图像中心的点，如 则此点被认为与在模板 i 方向上的线更相关 边缘检测 一组相连的像素集合，这些像素位于两个区域的边界上 一阶导数可用于检测图像中的一个点是否在边缘上 二阶导数可以判断一个边缘像素是在边缘亮的一边还是暗的一边 一条连接二阶导数正值和负值的虚构直线将在边缘中点附近穿过零点 一阶导数使用梯度算子，二阶导数使用拉普拉斯算子 梯度算子 图像 在 的梯度定义为下列向量 Roberts 交叉梯度算子 梯度计算由两个模板组成，第一个求 得梯度的第一项，第二个求得梯度的第二项，然后求和，得到梯度。 两个模板称为 Roberts 交叉梯度算子 Prewitt梯度算子 Sobel梯度算子 权值2用于增加中心点的重要性 结论 Prewitt和Sobel算子是计算数字梯度时最常用的算子 Prewitt模板比Sobel模板简单，但Sobel模板能够有效抑制噪声 拉普拉斯算子 图像函数的拉普拉斯变换定义为 拉普拉斯算子总结 缺点： 拉普拉斯算子对噪声具有敏感性 拉普拉斯算子的幅值产生双边缘 拉普拉斯算子不能检测边缘的方向 优点： 可以利用零交叉的性质进行边缘定位 可以确定一个像素是在边缘暗的一边还是亮的一边 拉普拉斯算子与平滑过程一起利用零交叉找到边缘 是标准差，上式称为高斯型的拉普拉斯算子 LoG 高斯型拉普拉斯算子总结 高斯型函数的目的是对图像进行平滑处理 拉普拉斯算子的目的是提供一幅用零交叉确定边缘位置的图像 平滑处理减少了噪声的影响 对比二阶拉普拉斯算子和一阶Sobel梯度算子 缺点 边缘由许多闭合环的零交叉点决定 零交叉点的计算比较复杂 优点 零交叉点图像中的边缘比梯度边缘细 抑制噪声的能力和抗干扰性能较好 边缘连接和边界检测 为什么需要边缘连接？ 由于噪声、照明等产生边缘间断，使得一组像素难以完整形成边缘 因此，在边缘检测算法后，使用连接过程将间断的边缘像素组合成完整边缘 局部处理 分析图像中每个边缘点(x,y)的一个邻域内的像素，根据某种准则将相似点进行连接，由 满足该准则的像素连接形成边缘 如何确定边缘像素的相似性 边缘像素梯度算子的响应强度 如果 则 邻域内坐标为 的边缘像素，在幅度上相似于 的像素 边缘像素梯度算子的方向 如果 则 邻域内坐标为 的边缘像素，在角度上相似于 的像素 Hough 变换 方程 在参数 k-b 平面上是一条直线 图像 x-y 平面上的一个像素点对应参数平面上的一条直线 对于边界上的n个点的点集，找出共线的点集和直线方程。 对于任意两点的直线方程： 构造一个参数 ， 的平面，从而有如下结论： xy 平面上的任意一条直线 ，对应在参数 ab 平面上都有一个点 过 xy 平面一个点 的所有直线，构成参数 ab 平面上的一条直线 如果点 与点 共线，那么这两点在参数 ab 平面上的直线将有一个交点,具有相同的 a 和 b 在参数 ab 平面上相交直线最多的点，对应的 xy 平面上的直线就是我们的解 阈值处理 基础 阈值处理操作 是 的灰度级， 表示该点的局部性质，如以 为中心的邻域的局部灰度级 阈值处理后的图像 定义为 标记为 1 的像素对应于对象，标记为 0 的像素对应于背景 当 T 仅取决于 ，阈值称为全局的 当 T 取决于 和 ，阈值是局部的 当 T 取决于空间坐标 和 ，阈值就是动态的或自适应的 基本全局阈值 选择一个T的初始估计值 用T分割图像，生成两组像素： 由所有灰度值大于 的像素组成，而 由所有灰度值小于或等于 的像素组成 对区域 和 中的所有像素计算平均灰度值 µ 和 µ 计算新的阈值 重复步骤 2 到 4，直到逐次迭代所得的 值之差小于事先定义的参数 基本自适应阈值 单一全局阈值存在的问题：不均匀亮度图像无法有效分割 方法 将图像进一步细分为子图像，并对不同的子图像使用不同的阈值处理 解决的关键问题：如何将图像进行细分和如何为得到的子图像估计阈值 自适应阈值：取决于像素在子图像中的位置 最佳全局和自适应阈值 假设一幅图像仅包含两个主要的灰度级区域。令 表示灰度级值，则两个灰度区域的直方图可以看作它们概率密度函数（PDF）的估计 是两个密度的和或混合。一个是图像中亮区域的密度，另一个是暗区域的密度 如果 已知或假设，则它能够确定一个最佳阈值（具有最低的误差）将图像分割为两个可区分的区域 混合 PDF 是 错分类的概率为 为找到出错最少的阈值，把 对 求微分使结果等于 ，得到 解出 ，即为最佳阈值 若 ，则最佳阈值位于曲线 的交点处 基于区域的分割 基本概念 目标：将区域R划分为若干个子区域 R1,R2,…,Rn，这些子区域满足5个条件： 完备性 连通性：每个 都是一个连通区域 独立性：对于任意 单一性：每个区域内的灰度级相等 互斥性：任两个区域的灰度级不等， 区域生长 根据图像的不同应用选择一个或一组种子，它或者是最亮或最暗的点，或者是位于点簇中心的点 选择一个描述符（条件） 从该种子开始向外扩张，首先把种子像素加入结果集合，然后不断将与集合中各个像素连通、且满足描述符的像素加入集合 上一过程进行到不再有满足条件的新结点加入集合为止 区域分离与合并 对图像中灰度级不同的区域，均分为四个子区域 果相邻的子区域所有像素的灰度级相同，则将其合并 反复进行上两步操作，直至不再有新的分裂与合并为止 算法实现：实际应用中还可作以下修改： 的定义为： 区域内多于 的像素满足不等式 ， 其中： 是区域 中第 个点的灰度级， 是该区域的平均灰度级， 是区域的灰度级的标准方差。 当 时，将区域内所有像素的灰度级置为","categories":[{"name":"总结","slug":"总结","permalink":"https://20021123.xyz/categories/%E6%80%BB%E7%BB%93/"},{"name":"图形学","slug":"图形学","permalink":"https://20021123.xyz/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"},{"name":"图形学","slug":"图形学","permalink":"https://20021123.xyz/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"图形与动画","slug":"图形与动画","date":"2023-06-07T17:40:06.000Z","updated":"2023-06-07T17:52:57.149Z","comments":true,"path":"2023/06/08/图形与动画/","link":"","permalink":"https://20021123.xyz/2023/06/08/%E5%9B%BE%E5%BD%A2%E4%B8%8E%E5%8A%A8%E7%94%BB/","excerpt":"","text":"一、计算机动画 动画：运动（活动）的画面（图像） 动画是通过连续播放一系列画面，给人的视觉造成连续变化的效果 二维动画：通过设计和绘制二维图形或图像而生成的动画 三维动画：通过构造并直接控制三维模型运动而生成的动画 动画片的基本原理和基本概念 视觉暂留原理：人的眼睛看到一幅画或一个物体后，大约在 秒内不会消失 利用视觉暂留原理，在一幅画还没有消失前播放下一幅画，就会给人造成一种流畅的视觉变化效果 帧：动画中每幅画 现在电影的播放速度：24 帧/秒 计算机动画是图形学和艺术相结合的产物。它综合利用计算机科学、艺术、数学、物理学和其它相关学科的知识用计算机生成绚丽多彩的连续的虚拟真实画面。 给人们提供了一个充分展示个人想象力和艺术才能的新天地。 计算机动画得以迅速发展，并形成一个巨大的产业，与影视、游戏的重大需求和推动是密不可分的。 计算机动画应用 影视动画片 影视特效动画 广告动画 游戏动画 医疗卫生 科学可视化以及教育 军事训练和作战演习模拟 二、三维对象的表示 边界表示法 多面体 多面体表示–使用一组包围对象表面的多边形 三维图形建模中运用边界表示是最普遍的形式 边界表示方法： 为覆盖对象表面的每一多边形给出一组顶点 顶点坐标和边的信息以及多边形表面法向量等其他信息存入一张表中 多边形的几何数据： 顶点表 边表 面片表 曲面 二次曲面（quadric surface） –表面使用二次方程进行描述 常见二次曲面： 球面 椭球面 环面 抛物面 双曲面 超二次曲面 超二次曲面是二次曲面的一般化表示 超二次曲面通过将额外参数插入二次方程而形成，便于调整对象的形状 常见超二次曲面： 超椭圆 超椭圆球 样条表示 样条–通过一组指定点集而生成平滑曲线的柔性带 样条曲线（spline curve）-由多项式曲线段连接而成的曲线，在每段的边界处满足特定的连续性条件 样条曲面（spline surface）-通过两组样条曲线生成 应用： 设计曲线和曲面形状、对象的动画路径 典型计算机辅助设计：汽车车身设计、飞机和航天机表面的设计、船体设计 通过控制点可得到曲线的大致形状 插值样条曲线（interpolate）-曲线通过每个控制点 用于数字化绘图或指定动画路径 逼近样条曲线（approximate ）-部分或者全部控制点不在生成的曲线上 作为设计工具来构造对象形体 凸壳 凸壳（convex hull）-包含一组控制点的凸多边形边界 凸壳的作用： 给出了曲线或曲面的坐标范围 样条以凸壳为界，保证了对象形态平滑地沿控制点前进 参数连续性条件 0 阶参数连续性 C0-曲线相连 1 阶参数连续性 C1-两条相邻曲线段的方程在相交点处有相同的一阶导数 交点处有相同的切线 2 阶参数连续性 C2-两条相邻曲线段的方程在相交点处有相同的一阶和二阶导数 交点处的切向量变换率相同 三次样条插值方法 思路：给出一组控制点，利用三次多项式拟合每对控制点之间的曲线，通过设置两条曲线段交点处平滑条件求解得到所有系数 为什么用三次多项式？ 计算效率：需要较少的计算和存储空间，并且较为稳定 灵活性：可模拟任意曲线形状 作用：多用于建立对象运动路径或提供实体表示和绘画，也可用于设计物体形状 Bézier曲线 线性 Bézier 曲线 给定点 ，线性贝塞尔曲线只是一条两点之间的直线 线上任意点坐标： 等同于线性插值 二次 Bézier 曲线 二次 Bézier 曲线的路径由给定点控制点 确定： 三次 Bézier 曲线 三次贝塞尔曲线的路径由给定点控制点 确定： $$ $$ 递归定义方式 混合函数 是 Bernstein 多项式 Bézier 曲线性质 Bézier 曲线总是落在控制点的凸壳内 混合函数值为正且其总和为 Bézier曲面 使用两组正交的 Bézier 曲线设计一个曲面 B 样条 B 样条多项式次数可独立于控制点数目 B 样条允许局部控制曲线或曲面 B 样条比 Bézier 更复杂 实体构造法 扫描表示法 扫描表示法–通过平移、旋转及其他对称变换来构造三维对象 方法：指定一个二维形状，在空间区域内移动该形状 路径： 描述路径的曲线函数 沿路径移动的距离 形状： 沿扫描线改变剖面的形状和大小 平移扫：垂直于二维集合进行扫过 旋转扫：绕某一轴线旋转某一角度 广义扫：二维几何集合沿一条空间曲线的集合扫过 结构实体几何法 使用集合操作（并、交或差操作）来组合多个三维对象 空间分区表示 定义 描述内部性质，将包含一个对象的空间区域划分成一组较小的、非重叠的连续实体 常用于三维医学成像 八叉树 八叉树（octree ）-分层树形结构，用于显示对象内部结构 每次使用与笛卡尔坐标平面对齐的三个相互垂直的平面对场景进行分割 构造出树形结构后，要求每一个结点对应于一个三维空间区域 构造 将三维空间区域分成八等份，并且在树上的每个节点处存储8个数据元素（体元） 每个体元若为一个均质子区域，则存储该子区域的特征值，如颜色、材质、密度等 否则，需进一步分解为8个子立方体 分解直至所有小立方体单元均质，或已分解到规定的分解精度为止 优点 提供了存储有关物体内部信息的方便表示 利用了空间相关性，减少了三维物体的存储需求 BSP 树 BSP 树-二叉空间分割树（Binary space partitioning），每次将空间分成两部分 自适应空间细分，每次将一个场景根据适合于对象空间分布的平面分成两部分 优点： 减少场景树的表示深度 减少了搜索树的时间 基于物理的建模方法 基于物理的建模–对象形状和表面特征随着对象运动或受到邻近物体影响而改变 非刚性物体，如绳、布料或软橡皮球使用基于物理的建模 另外，流体，如水流、烟雾的建模 三、关键帧动画 基本概念 关键帧动画技术是传统动画和计算机动画制作的常用技术 关键帧（原画）-动画制作过程中，由动画设计师绘制出动画的一些关键画面 一般需要很高的经济成本，而且要求动画设计师具有丰富的经验 中间插画制作–在关键帧之间需要补充插入一些画面，使得关键帧能够连贯起来 一般远远低于关键帧制作的经济成本，通常由助理动画师或者其他美术人员或者计算机自动完成 关键帧动画技术-研究如何制作填充与关键帧之间的画面，使得整个动画更加合理流畅 实现方法：插值技术 插值对象： 空间数据 对象的颜色、透明度 相机的焦距 线性插值 设物体在第 1 个关键帧中的位置为 ，在第 2 个关键帧中的位置为 ，则物体在中间帧中的位置为： 线性插值（颜色） 设物体初始颜色值为 ，最终的颜色值为 ，则中间结果线性插值的颜色为： 基于颜色线性插值的关键帧插值算法常常用于实现各种影视在镜头切换时的淡入淡出效果 非线性插值 中间帧变化模式为非线性： 插值样条 Hermite插值等 逼近样条 Bézier样条 B样条 利用二次Bézier曲线进行关键帧插值 点 、 和 共同构成了一条二次 Bézier 曲线的控制顶点 对象在中间帧的位置计算公式为： 如果在两个关键帧中需要插入 个中间帧，则令 物体的运动方向 如果给定对象在起始位置和目标位置处的坐标𝑃0𝑃1和速度方向𝑉0𝑉1，而且要求必须满足一定的速度大小 则利用 Hermite 曲线进行关键帧插值： 控制插值点移动速度 通常需要通过确定中间帧的帧数来控制过渡的时间以及表现角色的运动快慢和精神面貌等 如果中间帧的帧数较少，则通常具有较快的运动速度 如果中间帧的帧数较多，则通常具有较慢的运动速度 目标：如何使得对象按照用户确定的移动特性在指定轨迹上运动：即建立从时间t 到对象坐标位置p 的关系 求得对象移动的路径长度s与路径方程参数u的关系： 进而推导出特定弧长s所对应的u值： 设定对象移动的路径长度s与时间t关系： 求得对象移动的路径长度s与路径方程参数u的关系 方法： 解析求解方案-任意空间点之间弧长通过积分求解 大多数曲线不适用 数值求解近似求解 对曲线进行超采样进而构造一个表格记录弧长与参数的关系 通过高斯求积估算弧长 弧长计算方法-前向差分法 对参数 和弧长 进行采样：如 取 ，得到不同采样点 通过计算邻接顶点间的线性距离，逼近弧长 创建一个路径长度 与路径方程参数 的关系表： 索引 路径方程参数值 路径长度 0 0.00 0.000 … … … 8 0.40 0.720 9 0.45 0.800 … … … 14 0.70 0.944 15 0.75 0.959 已知 求对应的 求 时曲线弧长 已知 求对应的 求弧长 对应的参数 优点： 易于实现、直观且具有较高的计算速度 缺点： 弧长以及参数值的插值计算将在一定程度上引入误差 解决方法： 对曲线实施超采样，从而减少误差的产生 修改插值方案，采用高阶插值计算降低误差，但增加了计算复杂度 应在速度和精度之前作出某种权衡 速度控制-实现易入易出 速度控制 匀速运动 自定义 常见：易入/易出（ease-in/ease-out）：对象从静止位置处加速运动并达到最大速度，最终减速运动至静止处 距离-时间函数 满足约束条件： 距离-时间函数在 上呈现出单调性 距离-时间函数在 上保持连续性 实现易入/易出移动控制特性的方法 正弦插值 使用正弦曲线 作为实现方案 将 映射到 将函数范围 映射到 运动方式：缓慢启动、加速、减速 由于斜率处于不断变化中，因而移动过程中呈现出加速或减速状态 很少呈现匀速状态 正弦片段+直线 用户定义数据值 和 ，希望物体在 实现加速运动， 实现匀速运动， 实现减速运动 通过整合正弦曲线段和直线完成 正弦曲线 直线 ， 正弦曲线 归一化：每项除以 一元三次多项式 缺点：未提供匀速的控制方式 均匀加速度 最简单的非易入/易出模型 加速度为0 速度恒定 易入/易出模型 假设加速度开始和结束阶段非零 中间阶段加速度为零 $$ v= 假设时间值等于，由距离时间关系 1= v_0t_1+v_0(t_2-t_1)+ v_0(1-t_2) 得最大速度 v_0= $$ 基于正弦函数方案实现起来较为直观 但与加速度-时间函数以及速度-时间函数比，该方案缺乏灵活性 加速度-时间函数以及速度-时间函数可使用户对最终的移动效果具有较好的控制力 变形的基本思想 变体（变形）（Morphing）–关键帧技术重要的手段 变体是已知源对象和目标对象的前提条件下构造一系列中间对象，从而使得从源对象通过这些中间对象光滑地变化到目标对象 图像变体：如果源对象和目标对象是两幅二维的图像 图形变体：如果源对象和目标对象是由图形组成 不论是图像变体还是图形变体，都是使对象形状变形–形状之间的转换操作 多数动画设计人员通常需要对形状实施精准控制： 确定对象的关键形状 关键形状之间采用插值计算完成，进而生成形状之间的平滑变换 主要思想： 确定对象上每个点相对于局部坐标系统的坐标 对局部坐标系统实施变形操作 将对象上每个点重新映射到新的局部坐标系统 基于网格的图像变体技术 目标 设源图像和目标图像分别为 和 ，需要计算对于任意的实数 ， 所对应的中间帧图像 当 时，；当 时，； 当 从 匀速地变换到 时，中间帧图像 从图像 逐渐变换到 方法 为图像 和 建立在拓扑上的一一对应的四边形网格 通过交互方式，分别为图像 和 选取特征点，使得图像 的特征点和图像 的特征点一一对应 连接图像 的特征点形成四边形网格，连接图像 的特征点形成四边形网格图像 的四边形网格和图像B的四边形网格存在一一对应关系 每个四边形网格为一个独立的局部坐标系 中间帧图像的四边形内部及边界上的点 定义为两次线性插值 中间帧图像的四边形网格的顶点位置、颜色计算公式为 总结 基于网格的图像变体算法运算结果的质量取决于最初建立的源图像A和目标图像B的四边形网格的质量 四边形网格越精细，则变体结果的图像质量一般也越高 四边形网格应当包含图像的尖点和拐点等关键点 四边形网格一般要求是凸四边形，如果出现凹四边形，则可进一步分成凸四边形 缺点：算法灵活性不够 自由变形 FFD基本思想： 自由变形方法在变形过程中并不是直接操作几何模型，而是把几何模型嵌入到变形空间，然后通过操作变形空间来使得嵌入其中的几何模型发生变形 模仿泥巴或塑料等柔性体的变形，将需要变形的物体或物体的某部分嵌入到类似于泥巴或塑料的柔性体中，然后假设物体也是非常柔软的，会随着物体外围柔性体的变形而发生变形 FFD实现： 将物体全部或部分嵌入到网格中 然后通过对网格的变形（即改变网格顶点的位置）控制物体的变形 二维网格对应 grid 三维网格对应 lattice 二维自由变形具体算法 将物体嵌入到一个平行四边形 将平行四边形沿着边的方向划分为𝑚×𝑛个网格，也称为控制网格 各个格子的顶点称为网格的控制顶点 当移动这些控制顶点时，网格发生变形，从而带动嵌入的物体的变形 算法关键在于求得物体任意点 在网格内部的坐标 ；当网格发生形变时，坐标 不变，通过控制顶点新位置以及 Bezier 插值重构该点新位置坐标 令 网格内部任意一点Q的网格参数坐标 为： 点 在变形后的新坐标位置为 三维自由变形 三维自由变形可看作是二维自由变形的扩展 主要思想： ①将整个物体或物体所需要发生变形的部分嵌入到一个平行六面体中 ②给平行六面体内部及其边界上的每个点分配一个固定的网格参数坐标 ③通过移动控制顶点，引起物体的变形 网格参数坐标计算公式 四、基本光照模型 光源 光源(light source) –任意发出辐射能量的对象 光源可以是发光体和反射体的混合 光源属性： 位置 发射光颜色 发射方向 光源形状 光源分类 点光源–指一个无限小的点，所有光向四周平均地散射光 适用范围： 比对象小得多的光源 离场景不是太近的大光源 无穷远光源 光源在无限远放射 在任何位置，放射方向都是一致的，可以模拟类似太阳的光线 辐射强度衰减 光强度随着光源距离 衰减 离光源距离为 处光辐射强度按照 衰减 问题： 接近光源时，会产生过大的强度变化 当 很大时，变化又太小 改进 综上 光源在无穷远处光源是局部光源 方向光源和投影效果 对局部光源稍加修改可产生方向光源 方向光源–对象位于光源的方向范围 内才能得到光照 Vlight – 光源方向的单位向量 Vobj – 光源位置到一个对象位置的方向向量 角强度衰减 沿着圆锥轴光强最大，离开时强度减弱 方向光源角强度衰减函数： ：衰减指数 基本光照模型 反射 漫反射：表面将光向各个方向发散出去（粗糙表面） 镜面反射：反射光汇集中在一部分区域（光滑表面） 环境光（背景光）-场景中各个表面的反射光生成的光照效果 环境光：设定场景一般亮度级 环境光 入射光在各个方向以相同强度发散而与观察者位置无关 对于背景光效果，假定每一表面都使用对场景设定的环境光 来照明 物体在该点处光强度为 漫反射 当强度为Il的光源照射一个表面时，从该光源来的入射光总量依赖于表面与光源的相对方向 漫反射光强度 L 为指向点光源的单位方向向量 镜面反射 在光滑表面上看到的高光 镜面反射是由接近镜面反射角的一个汇聚区域内，入射光的全部或绝大部分成为反射光所导致的 V–指向视点的单位向量 理想的反射体–V与R的夹角为0，仅当V与R重合时才能观察到反射光 反射方向分布在向量 R 周围的有限范围内 较光滑表面的镜面反射范围较小 粗糙的对象表面有较大的反射范围 Phong 镜面反射模型 镜面反射光强度与 成正比 ：镜面反射参数，光滑表面较大，粗糙表面较小 ： 夹角 ：镜面反射系数，由镜面表面材质属性，以及其他因素（极性、入射光线颜色）决定 使用向量L与V间的半角向量H来计算镜面反射范围，可以得到简化的 Phong 模型： 只需要用 替代 经验性估算 来替代 总结 对于单点光源，光照表面上某点处的漫反射和镜面反射为 透射模型 透明表面–可透过该表面看到其后面的东西，如窗玻璃 透明对象表面同时产生反射光和折射光 折射角 计算根据 Snell 公式： 折射方向向量 T 假设： 不考虑折射导致的路径平移 各对象间的折射率不变 折射角=入射角 对象表面的折射光强 ：到达该点背后的光强 ：该点的透射系数 对象表面的总光强 ：该点反射的光强 五、全局光照 局部光照 计算对象表面和射向它的光线之间的交点处光照强度 只考虑特定对象（光源）和直接射向它的光线 全局光照 从其他对象反射出来的光线 产生更真实的光照效果 需要付出大量额外计算的代价 两大算法： ①光线跟踪法：从视点出发做出经过图像平面上每个像素的光线并射回到场景中，以此为基础来计算表面的明暗效果 ②辐射度算法：更加准确的模型。考虑场景中光源与对象表面间辐射能量的传递来计算光强度 光线跟踪算法 光源跟踪(ray tracing) –跟踪光线在场景中的反射和折射，并计算他们对光强的作用 优点： 生成高度真实感图形 缺点： 计算量大的惊人 光线跟踪算法是一种高度视相关的方法，因为进入场景并被跟踪的光线是从投影参考点出发的，如果观察者位置发生了变化，光线就全部都要重新计算和跟踪 如果场景中任何一个对象的位置改变了，就会引起光线反射的过程改变，从而导致部分甚至所有的光线必须重新计算 基本光线跟踪算法 为光线跟踪算法建立一个投影参考点在z轴、投影平面为xy平面的坐标系统 从投影参考点出发，穿过每个像素中心进入场景 计算与该光线相交的所有表面，找到最近的交点（可见面） 计算该光线在此交点上反射和折射光强度 构造二叉光线跟综树 构造停止条件： 该光线不和任意表面相交 该光线与一个光源相交且该光源不是一个反射面 该树达到最大允许深度 一个像素的二叉树建立完毕，从树的末端开始累积强度贡献 树的每一节点的表面强度因离开父节点表面的距离而衰减并加入到父节点表面的强度中 光强度逐级衰减 待解决问题 漫反射物体表面反射光方向任意 采用 Monte Carlo 方法采样 仍然存在问题： 计算开销太大！ 反射光呈指数级增长 解决方案： 反射光线数N=1 结果：画面充满噪声 对每条光线多次采样 SPP (samples per pixel)增加 无限循环 解决方案： 在第二次反射回来结束 但是存在能量损失 解决方案： 俄罗斯轮盘赌Russian Roulette 光线与对象表面求交计算 光线由初始位置 和单位向量 描述： 计算 光线-球面求交 球面上任意点 满足方程 带入光线方程，令 若 小于 ，则无交点 若 大于 ，则选取最小值 光线-多面体求交 多面体求交计算相对于球体复杂得多，一般利用包围体进行求交测试 具体来说： 若光线与包围体相交，则需测试： 其中， 为多面体表面法向量 通过上述测试找到多面体的前表面 求解所有前表面与光线交点 减少对象求交计算量 方法一：将相邻对象用一个包围盒（包围球）包起来 测试光线与包围体的交点 如果没有交点，则无须对被包围对象进行求交测试 分层包围盒（扩展）：将几个包围体包在一个更大的包围体中，首先测试最外层的包围体，然后根据需要逐个测试各层的包围体 方法二：空间分割法 将整个场景包含在一个立方体中 将立方体逐次分割直至每个子立方体所包含的对象表面或表面数目小于等于一个预定的最大值 跟踪穿过立方体的光线，仅需对包含表面的单元执行求交测试。光线所交的第一个对象表面记为可见面 该过程继续直到找到一个相交的对象表面或光线射出包围场景的立方体 六、纹理映射 纹理映射（texture mapping）-纹理模式映射到对象表面上 种类： 2D映射（2D mapping） 3D映射（3D mapping） 方法： 建立像空间和纹理空间映射关系 纹理坐标0到1.0 2D 映射 Map shape: planar Map shape 是一个平面 对于物体上每个点 ，抛掉其中一个分量，得到二维坐标 ，利用该值查找 texture map 中对应值 Map Shape: Cylinder 用一个形状将物体包裹起来，如圆柱体： 物体表面坐标 转换为圆柱体坐标 –对应于 texture map 中 坐标 –对应于 texture map 中 坐标 Map Shape : Sphere 球体： 物体表面坐标 转换为球面坐标 纬度–对应于 texture map 中 坐标 经度–对应于 texture map 中 坐标 Map Shape：Box 3D 映射 利用对象每个点 直接计算纹理颜色，不再使用 map shape 等同于将物体从一个石块中雕刻出来 函数 将产生对象每个点 到纹理映射，因此又称为 procedural texture 凹凸映射 纹理图案的光照细节的设定通常与场景中光照方向无关 纹理映射无法模拟粗糙表面物体 凹凸映射（bump mapping）：通过修改物体表面法向量来影响表面阴影的计算 使用扰动函数并在光照模型计算中使用扰动法向量 令 表示一个参数曲面上的点 和 – 关于参数 和 的偏导数 增加一个小的扰动函数（凹凸函数），在表面法向量 方向上增加凹凸效果： 偏导的近似 扰动的表面法向量为 如何指定凹凸映射函数b？ ①定义一个解析表达式 ②定义一个凹凸表来快速查找 七、关节动画 基本概念 关节–如果两个刚体互相连接且能够发生相对运动，则这两个刚体的关联部分称为关节 常见的关节 旋转关节 滑动关节 关节链–将一系列依次相连的刚体通过关节连接而成的开链 image-20230607110308011 链杆–关节链中每一段刚体 基结点–关节链的起点 末端影响器–关节链的自由末端(End effector) 状态空间–关节链结构所有可能形态的向量空间 状态向量–状态空间中的向量 关节链结构的自由度（Degree of freedom -DOF）–状态空间的维度，完全确定关节链结构状态所需的独立变量个数 正向运动学 研究如何从给定的状态向量计算各个链杆的位置（包括各个关节的位置），尤其是末端影响器的位置 动画师通过直接指定关节处的关节运动参数来控制物体的运动 二维的关节链为例，各个关节链均在一个平面上运动 各个链杆均只能绕着各自的起点运动 设关节链的基节点位置固定在全局坐标系的原点 链杆的方向为从链杆的起点到终点的方向 三链杆关节链 逆向运动学 逆向动力学研究的内容与正向运动学研究的内容恰好相反 逆向动力学是一种目标驱动技术，即研究如何从末端位置计算状态向量的位置 意义：动画设计者只需要控制末端位置，而不需要控制整个关节链结构，系统求解满足要求的关节，从而简化动画设计 方法 解析法求解简单系统：设法推导出具体的求解公式，并分析解的合理性，从而选取合理的解 如果关节链的逆向求解过于复杂，则直接采用一些数值计算方法进行求解，如Jacobian方案，CCD方案 大多数计算机动画中的相关问题，解析方案较复杂，不适合采用解析型求解方案 解决方法： 利用牛顿迭代法求解 即已知末端影响器的位置x和y，求解、2和。令 方程组的 Jacobian 矩阵 为 $$ = $$ 其中 牛顿迭代法 求得矩阵 的广义逆矩阵 Cyclic-Coordinate Descent (CCD) 循环坐标下降：通过逐步调整关节角度，实现最小化末端影响器与目标位置之间的距离 方便快速 链杆 通过旋转多少度尽可能接近目标位置 ？ 旋转 度达到新位置 链杆 通过旋转多少度尽可能接近目标位置 ？ 旋转 度达到新位置 链杆 通过旋转多少度尽可能接近目标位置 ？ 上述过程不断迭代，当 C 与 P 接近或者达到一定的迭代次数 层次结构建模 单个关节链结构通常不足以描述人体或动物等角色的运动 通常将人体或动物等角色分解成若干个关节链结构，并形成树状的层次结构，称为骨架树 首先将人体骨骼抽象成为关节和链杆组成的模型 然后选取其中的某个关节作为根节点，建立骨架树 骨架树建立后，通过关节链的正向运动学和逆向运动学求解骨架树的正向和逆向运动 八、物理动画基础 什么是物理动画？ 追溯现象本身的物理根源，借助其本身较为精确的物理描述才能真实再现其外在的视觉现象 基于物理的计算机动画的迅速发展： 计算机硬件的不断发展，计算能力不断增强 算法的不断改进 在市场方面，不管是电影特效，还是视频游戏，人们对于基于物理的计算机动画的需求也很强烈 物理动画包含哪些内容？ 物理模拟技术 刚体动力学模拟(rigid body dynamics simulation) 研究刚性物体在外力作用下的运动表现形式 刚体：在任何情况下其形状和大小都不发生任何变化的物体，即在刚体内任何两点的距离永远保持不变 刚体动力学模拟多涉及物体的平移、旋转以及碰撞的效果 柔体动力学模拟(soft body dynamics simulation) 用于逼真再现变形物体（或软组织）的运动状态 柔体：对象上任意两个点的相对距离不固定，但是相对距离变化通常满足一定的约束条件 柔软的有机材料，如肌肉，脂肪，头发和植被，以及其它可变形的无机材料如衣服和织物 计算机动画中提供的模拟方法只提供直观可信的仿真，而不涉及精确的科学或工程模拟 流体动力学模拟(fluid dynamics simulation) 流体： –某些物体无法采用刚体或者柔体模拟的方法进行模拟，而这些物体在自然界中颇为常见 –此类对象的运动规律往往比较难于描述。比如：水流、云彩以及火焰等对象的运动描述 –如何对这些特殊对象运动建模以及找到其在某些特定条件下的近似运动方案是流体动力学模拟考虑的问题 碰撞侦测(collision detection) 当物体在环境中运动时，如果该环境并非无限空旷，那么对象迟早会和周围环境的对象发生碰撞。在计算机动画中，如果未对此采取任何处理，那么就会出现对象穿越现象 为了使得生成动画真实可信，需要准确模拟对象间的交互行为。比如刚体间碰撞，柔体间碰撞（布料与环境中对象的碰撞，头发之间相互碰撞）以及流体之间相互碰撞 实现物理动画的关键因素？ 根据已知物理运动规律来模拟物体运动 动画制作更注重运动的整体质量，不涉及物体的位置和方向的精准控制 可信度胜过精准度 计算机动画产生原理 要生成一段运动物体的动画，只需要间隔小段时间重新计算这个物体的位置并在画面上绘制物体，当画面连续播放时，就能看到连续运动的物体了 生成物体运动状态的信息是计算机动画的关键 运动学模拟 已知物体 位置矢量p(t) 速度矢量v(t) 加速度矢量a(t) 计算下一个模拟时间的状态： 存在问题： ①我们不知道如何积分这些量？ ②我们不知道 后力的状态，自然也不知道 后速度 无法用蒙特卡洛法求积分 可采用数值积分的方式来处理 显式（前向）欧拉积分 辛欧拉积分 优势： 物体能量（动能+势能）长期维持稳定 在某个值附近波动 依赖于时间步长 隐式（后向）欧拉 优势： 物体能量（动能+势能）一直减小(因为在用 ) 近似，舍去了第二项及以后的值 考试题：求解 解： 移项，得 于是得 改进的欧拉 实例：一个简单的物理动画 实现一个简单的自由落体运动 已知物体的信息如下： 初始位置： 初始速度： 初始加速度： 运动模糊 产生原理 照相机或者摄像机能够记录下影像都是依赖于曝光 曝光是指场景中的光线投射在胶片上，引起化学反应，最终产生图片 但是如果在曝光的过程中，场景发生变化或者长时间曝光，则就会产生模糊的画面 运动模糊出现在长时间曝光或场景内的物体快速移动的情形里。 优点 在动画中加入运动模糊后能使运动变得更平滑，场景更逼真 缺乏运动模糊是计算机动画不真实的原因之一，因为计算机产生的图像“棱角分明”，很注目，以致削弱了运动效果 模拟方法 保留每帧绘图结果 每帧画一个半透明的黑色长方形，将前面绘图结果变暗 九、粒子系统 特殊的视觉效果或者现象，如： 火、爆炸、烟、水流、火花、落叶、云、雾、雪、尘、流星尾迹或者发光轨迹 这些现象用其它传统的计算机动画渲染技术难以实现模拟 物体具有共同的特征： 在外观上呈现出一定的不规则性、不确定性和随机性 同一物体在不同时刻会具有不同的形状，甚至差别很大 常用的欧几里得几何学方法很难再适用于这一类物体外观形态的描述 物体内部运动规律具有一定的复杂性，其运动过程较难把握和控制，特别是当受到外力作用时，其运动的不确定性和随机性更加突出 什么是粒子系统？ 粒子系统是最实用的过程动画技术之一，是影视特技游戏、图形学中生成视觉特效的一种主要方法。 粒子系统采用了一套完全不同于以往的造型、绘制方法来构造、绘制景物，造型和动画巧妙地连成一体。 景物被定义为由成千上万个不规则的、随机分布的粒子所组成，而每个粒子均有一定的生命周期，它们不断改变形状、不断运动。 随后被广泛应用于模拟模糊不规则物体。Reeves 首先应用粒子系统模拟了星球燃烧时的景象，并在其后对烟花进行了模拟 应用 云彩 烟雾 流动的水(瀑布、水花) 爆炸、碎片、尘土 火(火花) 喷泉 烟花 下雪、下雨、落叶 大群体 草、发丝 粒子系统的定义 粒子系统可看作由大量的微小物质组成的系统，这些微小物质按一定规则运动（变化）这些微小物质称为粒子（particle） 粒子的定义 粒子带有运动状态； 粒子是独立的，粒子之间互不影响(不碰撞、没有力) 。由于粒子之间的碰撞计算量很大并且对于大多数模拟来说没有必要，所以很少使用粒子之间的碰撞；但不是绝对！ 粒子有生命周期，生命结束后会消失； 粒子形状可以设为任意形状，比如可设定为球体，三角形等形状 粒子若处于聚集状态，粒子不向其它粒子投射阴影 粒子只向其它环境投射阴影 粒子不反射光 粒子的基本属性 运动属性 位置 速度 加速度 渲染效果 生命值 粒子颜色 粒子大小 粒子系统生成过程 生成（发射）粒子 模拟粒子状态变化 模拟粒子受力运动 模拟粒子老化 模拟粒子与环境的交互（如：碰撞） 渲染粒子 粒子系统更多的应用 更复杂的粒子系统 对于每一帧，根据一个控制的随机过程生成粒子： 用户可控制每帧的平均粒子数和其概率分布 粒子数可以是时间的函数 方法一： 粒子数: 其中，m为平均粒子数; rand() 返回 之间的随机数 v 为方差； 方法二： 粒子数: 其中，m为平均粒子数; rand() 返回 之间的随机数 v 为方差； A 为物体的屏幕面积(Screen Area) 在该方法中，新生成的粒子数以依赖于物体在屏幕上的投影面积。 颜色和透明度可以是时间（其剩余的生命周期、其高度等）的函数 形状可以是速度的函数 粒子上的力 粒子对力做出反应 粒子上的力可以是一元力(unary force)、粒子的偶力(particle pair force)或环境力 一元力 重力(Gravity) 粘性阻力(viscous drag) 粒子的偶力 可表示为弹簧阻尼器 环境力 根据粒子与环境的关系来得到 粒子的绘制 把每个粒子当成一个点光源 把每个粒子绘制成一个小的图元； 把映射到同一像素的颜色相加； 把每个粒子建模为一个带纹理的广告牌(textured billboard) 纹理多边形面向视点 把每个粒子看成元球，绘制整个元球系统(用于模拟水等液态效果) 粒子的碰撞检测 判断一个粒子是否与物体发生碰撞 当且仅当 时，粒子与平面发生碰撞 十、弹性网络 什么是弹性对象? 通过施加在对象上的力（如挤压或者拉伸），可改变物体的形状 有可能随着力的消失返回初始形态 对象上的两个点的相对距离不固定，但是相对距离变化满足一定的约束条件 哪些是弹性对象？ 布料 头发 果冻 如何实现弹性对象? image-20230607113716332 image-20230607113721544 将一个弹性对象看作由无数个质点构成的物体，质点之间有边作为连接 那么这个弹性对象能够发生形变，一定是因为连接质点的边具有发生弹性形变的性质 弹性网络 弹簧-质量模型 当外部力作用于对象时，作用力会使得质点产生运动，由于质点之间通过弹簧连接，质点之间相互运动产生弹力并作用于其它质点；同时作用力还会反馈到初始移动的质点 作用力将沿弹簧边传播，进而使对象富有弹性，并在顶点之间产生持续的相对偏移 将对象的顶点作为质点，连接质点的边作为弹簧进行建模 质点一般具有质量，质点质量大小总和等于对象质量大小 弹簧静止时长度可定义为原始边长 弹性系数由用户设定 弹簧-质量-阻尼系统 由于弹簧在没有阻力的情况下，会持续摆动，那么这就会造成弹性对象在受到外力作用后不断发生形变，永不停止 为了防止这种现象出现，我们在弹簧上另外附加一个阻尼系统，使得弹簧弹力逐渐减弱 简单弹性对象的实现–摆动的绳子 已知： : 弹性系数 : 相邻质点相距平衡位置的位移 ：弹簧位于稳定状态时，相邻质点间距离 ：阻尼系数 弹力： 阻尼力： 两个质点所受弹力和阻尼力一定位于这两个质点连线方向 推导步骤： 将质点速度值从三维空间投影至一维空间（质点连线方向） 在质点连线方向上计算弹力、阻力 复杂弹性对象的实现 假设绳子一端固定悬挂起来，另一端可自由运动，绳子一部分与地面接触 地面以上部分： 重力以及空气阻力的影响 地面上的质点： 在地面运动时，质点与地面产生相互作用，如质点与地面摩擦力 质点与地面冲撞时，损失部分动能，同时地面对其产生反作用力 重力 空气摩擦力 当物体在某一介质以某一速度行进时，介质的黏度会阻止物体运动 所施加的力大小一般与物体速度成正比，方向与速度相反。如：空气摩擦力计算大小和速度相关： ：空气摩擦系数 质点与地面摩擦力 – 只考虑动摩擦力 – 动摩擦力近似计算: 已知物体速度向量 质点与地面相互作用力 质点与地面冲撞时，能量会被地面吸收 用一个反作用力（Absorption force）来近似表示能量的损失 质点与地面冲撞时，质点与地面冲撞时， 地面对其产生排斥力 - 假设地面具有弹性，质点与地面接触时，地面会产生形变，进而对质点施加反作用力 - 将地面看作一个弹簧系统，产生排斥力（ repulsion force） ：地面排斥力系数 ：地面高度 ： 坐标 应用 1D：绳子-&gt;头发 《GPU Gems》hair animation 爱丽丝的发丝-《爱丽丝惊魂记：疯狂再临》 2D：布料 image-20230607114442321 3D：果冻、面团 image-20230607114451089 弹簧-质量模型改进 弹性物体运动受到其结构影响 现有结构存在问题： 无法抵抗错切方向上施力 无法抵抗折叠形变 改进方案： 增加抵抗错切方向上施力的弹簧 解决折叠形变 红色弹簧弹性系数弱于蓝色弹簧 十一、高级物理效果 布料建模 布料模拟方法 布料建模 模拟质点运动 计算质点受力 除了弹力以外其他受力：重力… 根据受力更新质点运动状态 韦尔莱法积分 渲染 韦尔莱法（Verlet）积分 韦尔莱积分算法是一种用于求解牛顿运动方程的数值方法。1967 年法国物理学家 Loup Verlet 将其应用于分子动力学计算，从此韦尔莱算法流行起来，被广泛应用于分子动力学模拟以及视频游戏中 韦尔莱算法的优点： 数值稳定性比简单的欧拉方法高很多 可以简单地加入各种约束(constraint) - 可以简单地加入各种约束(constraint) - 对于弹性网络，另一约束就是弹簧距离（相邻质点的距离），在Verlet积分下，此距离约束可以模拟弹簧 - Verlet积分法隐式处理了物体的速度和加速度 - 对于物体运动只要考虑在适当的时候改变它们的位置就行了，这样游戏中用户若选中一个物体，把它移动到某个位置 Verlet 方法在精度与速度之间取得了前所未有的平衡，越来越多游戏使用这种方法来模拟物体以及人体运动效果 在实际使用当中，适当修改系数，含简单阻尼效果 约束 假设质点位置向量为 和 ，质点间向量为： 向量 长度为 质点间变形距离为 那么要让质点回到原位，需要进行如下操作更新位置 松弛法 求解方程： 松弛法求解： 定义 ： 那么 给定一个初始值 ，那么 经过若n次迭代， 接近真实值。 给定 的线性方程组 把 分解为对角部分 和剩余部分 ，重写方程为 松弛过程为 减少开方运算时间 泰勒公式 时， 是弹簧平衡长度 带入 十二、水面模拟 真实感水体的渲染和模拟，一直是计算机图形学和游戏开发领域的核心难点之一。 水体渲染中，最核心的部分为波形的模拟技术，即如何模拟出逼真的水面波浪的流动变化。 按时间分布，近50年水体波形渲染的主流技术发展可以总结列举如下： 凹凸纹理贴图（Bump Mapping）[Schachters1980] 正弦波（Sinusoids Wave）[Max 1981] 分形噪声（Fractal noise）[Perlin1985] 水面模拟步骤 水面建模 模拟水面运动 物理模型描述水面的状态，比如能够描述水面的波动、涟漪等 水面渲染 特殊的光学效果，如反射、折射以及菲捏尔效果 菲捏尔效果 视线垂直于表面时，反射较弱，而当视线非垂直表面时，视线与表面法线夹角越大，反射越明显 水面建模 水面外观与地形外观非常相似，不同点在于水面外观高度是随着时间变化的 首先将平面看作普通的均匀网格，每一个网格点(x, y)对应一个水面高度值 水面是动态的随着时间变化的，因此其网格高度值是一个与时间相关的函数H (x, y, t) 模拟水面运动 假设水面开始静止不动 在某一位置有一振动源作简谐振动，振动产生的波向四周传播 水面在任意位置 处高度 就与传播到此的波的幅度相关 根据该振源信息以及时间 ，可推导出距离该振源任意位置处水面高度随时间的大小，即 简单模型（2D） 假设某振源位于一维坐标系下原点处 振动产生的波沿着x轴方向传播 位于 处点在时刻 水面高度为 与 时刻传播到此处的波的幅度有关 要知道位于 处点在时刻 水面高度为 推导出位于振源在 时刻振幅 为波从振源传播到 所需时间 振源处发出的波沿着 轴传播。已知波的传播速度为 ，波长为 波传播至处时间为： 振源处振幅随时间变化函数为 ：振幅大小 ：波的振动周期 在 时刻，距离振源距离 处振幅大小为 已知波速为 ，波长 ，带入 令 ，上式写为 完整模型（3D） 二维平面上某点 处振幅大小随时间的变化关系 波长（Wavelength——L）：连续两个波峰之间的距离 振幅（Amplitude——A）：平面到波峰的距离 波转播速度（Speed——S）：波峰每秒移动距离 波浪传播方向（Direction——D）：垂直于波阵面的向量 法向量 已知水面上任意点坐标 该点 方向的偏导为 该点 方向的偏导为 得法向量 $$ 而 $$ 其中 波浪的种类 定向波浪： 波的传播方向D为定值 圆形波浪： 每一点处波浪传播方向需要重新计算 若已知振源位置向量C，位于网格点(x, y)处的波浪传播方向D为： 两种波浪适用场合： 对于大面积水体（如海面），定向波浪比较适用于表达受风吹动的水面 对于小的水池，通常产生波动的振源通常不是风，较常见的如水滴滴落，此时用圆型波浪模拟水面比较合适 多个振源 让水面运动更加真实： 通常水面运动看作一系列正弦波的叠加 已知根据第i个正弦波推导的水面方程为： 合并后水面方程为 法向量等类似处理即可 更真实的模型 幂指数模型 新模型 方向偏导分别为 $$ $$ k 值越大，波峰更突兀，波谷更宽 Gerstener Waves ：控制波浪陡峭程度的参数 每个网格点（x, y）在X和Y方向发生了位移，而高度值是相同的 当 时，即正弦波模型 当 时 $$ P(x,y,t)= $$ 给出非常尖锐的波峰 在模拟时应避免将 值设置过大，否则会在波峰顶部产生环 法线计算 参数设置 对于深水区的波浪，波长和波相位满足如下关系","categories":[{"name":"总结","slug":"总结","permalink":"https://20021123.xyz/categories/%E6%80%BB%E7%BB%93/"},{"name":"图形学","slug":"图形学","permalink":"https://20021123.xyz/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"},{"name":"图形学","slug":"图形学","permalink":"https://20021123.xyz/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"软件工程","slug":"软件工程","date":"2023-02-25T04:34:14.000Z","updated":"2023-02-25T09:01:44.000Z","comments":true,"path":"2023/02/25/软件工程/","link":"","permalink":"https://20021123.xyz/2023/02/25/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/","excerpt":"","text":"一、软件工程概述 1.1 软件的概念和特点 定义 软件程序数据文档 程序 按事先设计的功能和性能需求执行的指令序列 数据 程序正常操纵信息的数据结构 文档 与程序开发、维护、使用有关的图文材料 特征 软件是开发的或者是工程化的，并不是制造的 软件生产是简单的拷贝 软件会多次修改 软件开发环境对产品影响较大 软件开发时间和工作量难以估计 软件的开发进度几乎没有客观衡量标准 软件测试非常困难 软件不会磨损和老化 软件维护易产生新的问题 分类 按软件功能分为 系统软件 支撑软件 应用软件 按服务对象分 项目软件 产品软件 发展 软件的发展过程大致可分为四个阶段。 从上世纪50年代中期到60年代中期，为个体化发展阶段，软件往往只是为解决某个实际问题而专门编写的程序，开发者即使用者。 从60年代中期到70年代中期，是作坊式发展阶段，早期软件作坊缺乏组织管理，程序编写结合了一定的说明。 从70年代中期到80年代的中期，是工程化发展的阶段，软件公司化运作，更加产品化、系列化、标准化、工程化，文档被引入软件的内涵。 从80年代中期到现在，软件的发展呈现产业化特点，市场更加广阔，品类更加丰富，产品生态链愈加完整。 1.2 软件危机的产生 软件危机的定义 在计算机软件的开发和维护过程中所遇到的一系列严重问题 项目超出预算 项目超过计划完成时间 软件运行效率很低 软件质量差 软件通常不符合要求 项目难以管理并且代码难以维护 软件不能交付 软件危机的产生原因 客观：软件本身特点 逻辑部件 规模庞大 主观：不正确的开发方法 忽视需求分析 错误认为：软件开发=程序编写 轻视软件维护 消除软件危机的途径 对计算机软件有正确的认识：软件≠程序 充分认识软件开发不是某种个体劳动的神秘技巧，而是组织良好、管理严密、个类人员协同配合、共同完成的工程项目 推广使用在实践中总结出来的开发软件的成功技术和方法。开发和使用更好的软件工具 1.3 软件工程的概念和发展过程 软件工程的概念 IEEE 将软件工程定义为 应用系统化的、学科化的、定量的方法，来开发、运行和维护软件，即将工程应用到软件 对 1. 中各种方法的研究 目标 在给定的时间和预算中，按照用户需求，开发易修改、高效、可靠、可维护、适应力强、可移动、可重用的软件 软件工程三要素 工具 软件工程工具，为软件工程的过程和方法提供自动化或半自动化的工具支持。 将若干工具集成起来，与软件工程数据库和计算机系统构成一个支持软件开发的系统称“计算机辅助软件工程(CASE)”，系统中某一工具的信息加工结果可以作为另一工具的输入。集成的软件工程工具再加上人的因素构成了软件工程环境。比如建模工具Rational Rose、编程工具Visual Studio、测试工具LoadRunner等。 方法 软件工程方法，是完成软件工程项目的技术手段。它支持项目计划和估算、系统和软件需求分析、设计、编程、测试和维护。软件工程方法依赖一组原则，它贯穿软件工程的各个环节。软件工程方法主要分两类：结构化方法和面向对象方法。 过程 软件工程过程，贯穿软件开发的各个环节，在各环节之间建立里程碑。管理者在软件工程过程中对软件开发的质量、进度、成本进行评估、管理和控制；技术人员采用相应的方法和工具生成软件工程产品（模型、文档、数据、报告、表格等）。 软件工程发展过程 第一代——传统的软件工程 第二代——对象工程 第三代——过程工程 第四代——构件工程 软件工程的七个原则 1.4 软件工程知识体系与职业道德 软件工程的知识体系 软件工程的误解 管理方的误解: M1: 我们已经有一本关于软件生产的标准和过程的书，这还不能让我们学习到需要的知识吗？ R1: 相比最新的大型主机，工作站和PC，这会使我们在做高质量软件开发时花费更多时间。 M2: 如果我们项目进度落后了，可以加入更多的程序员来赶进度。 R2: 软件开发的机制和手工作业不一样。在一个延迟了的软件项目中加入新的开发人员只会让它延迟更多。 M3: 如果我们将软件项目外包给第三方，我们就轻松了，让那个公司去完成它吧。 R3: 如果组织管理方不懂得如何从内部管理和控制软件项目，即使将项目外包也无济于事。 客户方的误解 M1: 对目标的一般陈述就足以开始编程，我们可以今后再补充细节。 R1: 前期糟糕的项目需求定义，是导致软件失败的主要原因。 R2: 项目需求的确在不断变化，但变化所产生的影响是根据变化提出的时间不同而不同的。 开发人员: 软件从业者积累了50 年的编程文化。在早期的软件开发中，编程被视为一种艺术形式。 M1: 一旦我们编程完毕并成功运行，我们的工作就结束了。 R1: “越早开始写代码，我们就会花费越长的时间去完成它”。工业数据显示，软件开发60%-80%的精力将耗费在软件首次提交给用户以后。 M2: 当我的程序运行之前，我没有办法评估它的质量。 R2: 一个最有效的软件质量保证机制应当在项目的正式开始启动时——可以通过技术报告体现。 M3: 唯一可交付的工作成果是一个成功运行的项目程序。 R3: 一个可运行的程序只是软件结构的一部分，它还包含了许多其它因素。 M4: 软件工程将会让我们去创建大量不必要的文档，并且总是使我们的进度放慢。软件工程仅仅是文档而已。 R4: 软件工程并不是创建文档，而是创建质量。更好的质量减少返工的概率。更少返工会让项目更早交付。所有的文档都是提高团队沟通和质量所必须的。 职业道德和责任规范 二、软件过程概念 2.1 软件生命周期 软件生命周期：软件产品或软件系统从设计、投入使用到被淘汰的全过程 2.2 软件过程 软件过程：在工作产品构建过程中，所需完成的工作活动、动作和任务的集合 活动：主要指宽泛的目标，与应用领域、项目大小、结果复杂度或实施软件工程的重要程度没有直接关系 动作：包含主要工作产品生产过程中的一系列动作 任务：关注小而明确的目标，能够产生实际产品 2.3 软件过程模型 软件过程模型是软件开发全部过程、活动和任务的结构框架，它能直观表达软件开发全过程，明确规定要完成的主要活动、任务和开发策略。在软件过程模型框架的约束之下，软件开发才能够有序有效地进行，从而保证软件开发的成功。 软件过程模型也常被称为：软件开发模型、软件生存周期模型、软件工程范型。 2.4 能力成熟度模型 瀑布模型 瀑布模型，英文称之为waterfall model，是第一个软件过程模型，也是极其重要的一个软件过程模型，由Winston Royce于1970年提出。瀑布模型规定了软件工程包括可行性研究、需求分析、总体设计、详细设计、编码、单元测试、系统测试、验收测试、运行与维护等活动，这些活动自上而下、相互衔接、次序固定，如同瀑布流水逐级下落，因此称为瀑布模型。由于瀑布模型规定的软件开发过程与软件生命周期一致，因此瀑布模型也称为经典生命周期模型。 线性模型 阶段间有顺序性和依赖性 推迟实现的观点 以文档为驱动 缺点 增加工作量 早期错误发现晚 开发风险大 不适应需求变化 瀑布模型适用于系统需求明确且稳定、技术成熟、工程管理较严格的场合，如军工、航天、医疗。 V 模型 瀑布模型有一个变种，V模型。在V模型中，处于顶端的是编码，左侧是分析设计阶段，右侧是测试运维阶段。该模型将测试的各个阶段和分析设计的各个阶段关联起来，单元测试验证详细设计，系统测试验证总体设计，验收测试验证需求分析。 原型模型 原型化的目的主要有两点： 明确并完善需求，通过演示原型实现，如图书借阅系统中的主要界面； 研究技术选择方案，通过技术验证原型实现，如智能家居系统中的部分监视和控制。 原型模型包括两个大阶段，原型构建阶段和系统开发阶段 优点 减少需求不明确带来的风险 缺点 构造原型采用的技术和工具不一定主流 快速建立起来的系统加上连续的修改可能导致原型质量低下 设计者在质量和原型中进行折中 客户意识不到一些质量问题 原型模型适用于客户定义一个总体目标集，但是他们并不清楚系统的具体输入输出；或开发者不确定算法的效率、软件与操作系统是否兼容以及客户与计算机交互的方式 增量模型 增量，它是满足用户需求的一个子集，能够完成一定功能、小而可用的软件。这里要注意区分增量和原型的异同。增量和原型都是系统的一部分，但是它们的构建原因和最终结局不同，原型构建是为了明确需求或验证方案，最终可能会被抛弃，而增量则是实际开发过程和最终系统的一部分 增量模型是一种非整体开发的模型，是一种进化式的开发过程 增量模型从部分需求出发，先建立一个不完整的系统，通过测试运行这个系统取得经验和反馈，进一步使系统扩充和完善 如此反复进行，直至软件人员和用户对所设计的软件系统满意为止 增量模型结合了原型模型的基本要素和迭代的特征，采用了基于时间的线性序列，每个线性序列都会输出该软件的一个“增量” 每个增量的开发可用瀑布或快速原型模型 优点 增量概念的引入，使得不需要提供完整的需求，只要有一个增量出现，开发就可以进行，软件能够更早投入市场 在项目初期，由于只开发部分系统，不需要投入太多的人力物力 整个开发过程中，产品逐步交付，软件开发能够较好地适应需求的变化，同时能够看到软件中间产品，提出改进意见，减少返工，降低开发风险 增量模型要求系统具有开放式体系结构，以便于增量的集成，同时也便于软件后期的维护 缺点 每个增量必须提供一些系统功能，这使得开发者很难根据客户需求给出大小适合的增量 其次，软件必须具备开放式体系结构，这在实践中往往是困难的 如果不能进行良好的项目管理，采用增量模型的开发过程很容易退化成边做边改的方式，使软件过程控制失去整体性，从而导致软件开发失败。 增量模型适用于软件开发中需求可能发生变化、具有较大风险、或者希望尽早进入市场的项目 螺旋模型 螺旋模型提出将把开发活动和风险管理结合起来进行风险控制。螺旋模型最显著的特点就是在软件开发过程中加入风险管理。 优点 螺旋模型强调原型的可扩充性和可修改性，原型的进化贯穿整个软件生存周期，这将有助于目标软件的适应能力，支持用户需求的动态变化； 原型可看作可执行的需求规格说明，易于为用户和开发人员共同理解，还可作为继续开发的基础，并为用户参与所有关键决策提供了方便； 由于每个阶段都会进行风险分析和原型化验证，螺旋模型为项目管理人员及时调整管理决策提供了方便，进而可降低开发风险。 缺点 如果每次迭代的效率不高，致使迭代次数过多，将会增加成本并推迟项目交付时间； 使用该模型需要有相当丰富的风险评估经验和专门知识，要求开发队伍水平较高，否则会带来更大风险。 螺旋模型适用于需求不明确或者需求可能发生变化的大型复杂的软件系统。 支持面向过程、面向对象等多种软件开发方法，是一种具有广阔前景的模型。 喷泉模型 喷泉模型是一种以用户需求为动力，以对象为驱动的模型，主要用于描述面向对象的软件开发过程 软件开发早期定义对象，整个开发过程充实和扩充对象 各个阶段使用统一的概念和表示方法，生命周期各阶段无缝连接 各个开发步骤多次反复迭代 优点 喷泉模型的各个阶段没有明显的界限，开发人员可以同步进行开发，可以提高软件项目开发效率，节省开发时间，适应于面向对象的软件开发过程。 缺点 由于喷泉模型在各个开发阶段是重叠的，在开发过程中需要大量的开发人员，因此不利于项目的管理。 喷泉模型要求严格管理文档，使得审核的难度加大，尤其是面对可能随时加入的各种信息、需求与资料的情况。 喷泉模型只适用于面向对象开发 基于构件的开发模型 基于构件的开发模型是近年来得到广泛应用的软件过程模型。由于采用构件技术和重用技术，它改变了大型软件的开发方式，使得软件开发时考虑的焦点不再是实现，而是集成。通过复用和集成已有的构件来实现软件开发。构件是系统中模块化的、可更换的部分。构件是一个相对独立的模块，并且能够被另一个具有相同接口的构件所替换。构件实现特定的功能，并对实现进行封装，暴露一组接口，外界不需要知道构件内部实现的细节，只需要通过接口访问构件提供的服务。 优点 软件复用思想 降低开发成本和风险，加快开发进度，提高软件质量 缺点 模型复杂 商业构件不能修改，会导致修改需求，进而导致系统不能完全符合客户需求 无法完全控制所开发系统的演化 项目划分的好坏直接影响项目结果的好坏 基于构件的开发模型适用于系统之间有共性的情况 统一过程模型 有着举足轻重的作用。统一过程模型是由Rational公司（现已被IBM收购）推出的完整且完美的软件工程方法，在面向对象领域获得了广泛应用。统一过程模型基于面向对象方法学，也就说，它适用于面向对象开发，开发过程中的需求分析和系统设计表示法均采用统一建模语言UML 统一过程模型从三个视角描述软件开发过程：动态视角，静态视角和实践视角。 动态视角描述面向对象开发随时间变化的各个阶段，包括初始阶段、精化阶段、构建阶段和产品化阶段，采用迭代方式开发。 静态视角描述在各个开发阶段所要进行的活动，如业务建模，需求，分析设计，实现，测试等。 实践视角总结了在实际项目开发中建议采用的良好实践，这些实践经过大量实际项目证明，对提高软件开发效率和质量非常有效。 Rational统一过程完整且完美，适合大团队大项目。 敏捷开发过程模型 敏捷开发强调高效工作、快速响应变化，具有敏捷性 敏捷软件过程是基本原理和开发准则的结合 基本原理强调： 客户满意度和较早的软件增量交付，软件开发采用迭代方式，每次迭代产生一个增量，每次交付的周期都很短; 开发团队小但有激情，团队中的每一个人能力都很强，且工作非常有激情，这是保证快速开发的前提； 开发采用非正式的方法，以可工作的软件为目标，适当时候进行结构调整和程序优化； 每次迭代产生的增量都很小，保证每次迭代时间都很短，并且对变化具有敏捷性，能根据变化及时调整； 整体开发过程尽量简单。 开发准则强调： 分析和设计的交付 开发者和客户之间积极持续的交流，客户会派工作人员到开发组，作为客户代表参与开发，使得交流及时和持续，保证敏捷性。 优点 快速响应变化和不确定性 可持续开发速度 适应商业竞争环境下的有限资源和有限时间 缺点 测试驱动开发可能导致通过测试但非用户期望 重构而不降低质量困难 敏捷开发适用于需求模糊且经常改变的场合，适合商业竞争环境下的项目 如何选择软件过程模型 前期需求明确的情况下，尽量采用瀑布模型 用户无系统使用经验，需求分析人员技能不足的情况下，尽量借助原型模型 不确定因素很多，很多东西无法提前计划的情况下，尽量采用增量模型或螺旋模型 需求不稳定的情况下，尽量采用增量模型 资金和成本无法一次到位的情况下，可采用增量模型 对于完成多个独立功能开发的情况，可在需求分析阶段就进行功能并行，每个功能内部都尽量遵循瀑布模型 全新系统的开发必须在总体设计完成后再开始增量或并行 编码人员经验较少的情况下，尽量不要采用敏捷或迭代模型 增量、迭代和原型可以综合使用，但每一次增量或迭代都必须有明确的交付和出口原则 三、需求分析 3.1 需求分析的概念 定义 确定系统必须具有的功能和性能，系统要求的运行环境，并且预测系统发展的前景。 换句话说需求就是以一种清晰、简洁、一致且无二义性的方式，对一个待开发系统中各个有意义方面的陈述的一个集合。 3.2 需求的获取 定义 软件需求的来源 软件工程师收集这些软件需求的方法 需求类型 功能性需求：描述系统应该做什么，即为用户和其它系统完成的功能、提供的服务。 非功能性需求：必须遵循的标准，外部界面的细节，实现的约束条件，质量属性等等 也被称为需求抓取、需求发现和需求获得 3.3 需求分析/管理的过程 需求提炼定义 对应用问题及环境的理解和分析，为问题涉及的信息、功能及系统行为建立模型。将用户需求精确化、完全化，最终形成下一步的需求规格说明书 需求提炼（需求分析）的核心在于建立分析模型。 需求提炼（需求分析）采用多种形式描述需求，通过建立需求的多种视图，揭示出一些更深的问题。 需求提炼（需求分析）还包括与客户的交流以澄清某些易混淆的问题，并明确哪些需求更为重要，其目的是确保所有风险承担者尽早地对项目达成共识并对将来的产品有个相同而清晰的认识。 需求规格说明书 软件需求规格说明书（SRS）——软件系统的需求规格说明，是对待开发系统的行为的完整描述。它包含了功能性需求和非功能性需求。 需求分析工作完成的一个基本标志是形成了一份完整的、规范的需求规格说明书。 需求规格说明书的编制是为了使用户和软件开发者双方对该软件的初始规定有一个共同的理解，使之成为整个开发工作的基础。 需求验证的重要性 如果在后续的开发或当系统投入使用时才发现需求文档中的错误，就会导致更大代价的返工。由需求问题而对系统做变更的成本比修改设计或代码错误的成本要大的多。 3.4 需求分析的任务 建立分析模型：准确地定义未来系统的目标，确定为了满足用户的需求系统必须做什么。 编写需求说明：用《需求规格说明书》规范的形式准确地表达用户的需求。 3.5 软件需求规格文档编制 软件需求规格说明的原则 从现实中分离功能，即描述要“做什么”而不是“怎样实现” 要求使用面向处理的规格说明语言（或称系统定义语言） 如果被开发软件只是一个大系统中的一个元素，那么整个大系统也包括在规格说明的描述之中 规格说明必须包括系统运行环境 规格说明必须是一个认识模型 规格说明必须是可操作的 规格说明必须容许不完备性并允许扩充 规格说明必须局部化和松散耦合 3.6 需求分析模型概述 面向过程分析模型：其基本思想是用系统工程的思想和工程化的方法，根据用户至上的原则，自始自终按照结构化、模块化，自顶向下地对系统进行分析与设计。 面向对象分析模型：由5个层次（主题层、对象类层、结构层、属性层和服务层）和5个活动（标识对象类、标识结构、定义主题、定义属性和定义服务）组成。 3.7 结构化分析方法 面向数据流进行需求分析的方法 结构化分析方法适合于数据处理类型软件的需求分析 具体来说，结构化分析方法就是用抽象模型的概念，按照软件内部数据传递、变换的关系，自顶向下逐层分解，直到找到满足功能要求的所有可实现的软件为止 3.8 数据流图 加工 表示对数据进行的操作, 如“处理选课单” 、“产生发票”等 顶层的加工名就是整个系统项目的名字 尽量最好使用动宾词组，也可用主谓词组 不要使用空洞的动词 外部实体（数据源点/终点） 位于系统之外的信息提供者或使用者,称为外部实体。即存在于系统之外的人员或组织。如“学务科”等 说明数据输入的源点(数据源)或数据输出的终点(数据终点) 起到更好的理解作用，但不是系统中的事物 数据流 表示数据和数据流向, 由一组固定成分的数据组成 如“选课单”由“学号、姓名、课程编号、课程名”等成分组成 数据流可从加工流向加工，也可在加工与数据存储或外部项之间流动；两个加工之间可有多股数据流 用名词,不要使用意义空洞的名词 尽量使用现实系统已有名字 数据存储 表示需要保存的数据流向, 如“ 学生档案”、“课程设置”等 数据存储与加工的方向 “读出 ”、“写入 ” 分层数据流程图中，数据存储一般局限在某一层或某几层 命名方法与数据流相似 画数据流时需注意的问题 不要把控制流作为数据流 不要标出激发条件 几种错误 每个加工至少有一个输入数据流和一个输出数据流 数据流必须要么从某个加工流出、要么流入某个加工，而不能直接从外部项流向数据存储等等。 绘制步骤 绘制数据流图顶层：首先确定系统的输入和输出，画出顶层数据流图 绘制数据流图 1 层：从输入端开始，根据仓库业务工作流程，画出数据流流经的各加工框，逐步画到输出端，得到1层数据流图 绘制数据流图2层：加细每一个加工框 合成总体数据流图 检查与调整数据流图：在分析过程中，由于每个人的经验和思路不尽相同，对数据流图的分解方案可以有多种形式，不是唯一的。对每一张数据流图进行检查，如果太不均衡，就需要进行调整，尽量使分解后的各个软件子系统的复杂性得到均衡，便于今后设计工作的并行开展 3.9 数据流图的改进 检查正确性 数据守恒 数据存储的使用 父图和子图的平衡 提高易理解性 简化加工之间的联系：应尽量减少加工之间输入输出数据流的数目。因为加工之间的数据流越少,各个加工的功能就越相对独立 注意均匀分解 适当命名：名字的意义要明确，容易理解 重新分解：在画第N层时意识到在第N-1层或第N-2层所犯的错误，此时就需要对第N-1层、第N-2层作重新分解 3.10 编写数据字典 编写数据字典，写出系统需求规格说明书，提交审查，并编写测试验收计划、编写初步的用户手册概要。 3.11 什么是对象 在现实世界中有意义的、与所要解决的问题有关系的任何事物都可以作为对象，包括具体的物理实体的抽象、人为的概念、任何有明确边界和意义的东西。 3.12 面向对象的软件开发模型 数据模型（对象模型）:描述系统数据结构的对象模型 行为模型（动态模型）：描述系统控制结构 功能模型：描述系统功能 一个典型的软件系统使用数据结构（对象模型），执行操作（动态模型），并且完成数据值的变化（功能模型）。 3.13 用例图 用例图的基本图形符号 用例建模用于描述系统需求，把系统当作黑盒，从用户的角度，描述系统的场景。主要图形元素有以下几个： 参与者：是指外部用户或外部实体在系统中扮演的角色。可以是一个人、一个计算机子系统、硬件设备或者时间等角色 用例：对一组动作序列的描述，系统通过执行这一组动作序列为参与者产生一个可观察的结果。用例名往往用动宾结构命名。 执行关联： 参与者（Actor ）执行用例（Use Case）之间的关系 用例图建模的过程 确定谁会直接使用该系统。这些都是参与者(Actor)。 选取其中一个参与者。 定义该参与者希望系统做什么，参与者希望系统做的每件事成为一个用例。 对每件事来说，何时参与者会使用系统，通常会发生什么，这就是用例的基本过程。 描述该用例的基本过程。 考虑一些可变情况，把他们创建为扩展用例。 复审不同用例的描述，找出其中的相同点，抽出相同点作为共同的用例。 重复步骤2~7找出每一个用例。 参与者 参与者（actor）是指系统以外的、需要使用系统或与系统交互的东西，包括人、设备、外部系统等。 参与者的三种表示形式 用例 对一组动作序列的描述，系统通过执行这一组动作序列为参与者产生一个可观察的结果 特征为 说明了系统具有的一种行为模式 说明了一个参与者与系统执行的一个相关的事件序列 提供了一种获取系统需求的方法 提供了一种与最终的用户和领域专家进行沟通的方法 提供了一种测试系统的方法 用椭圆形表示 系统和关联 系统：用于界定系统功能范围，描述该系统功能的用例都置于其中，而描述外部实体的参与者都置于其外。 关联：连接参与者和用例，表示参与者所代表的系统外部实体与该用例所描述的系统需求有关。 用例拓展 3.14 用例之间的关系 关联 表示参与者与用例之间的通信，任何一方都可发送或接受消息。 【箭头指向】：指向消息接收方 泛化 就是通常理解的继承关系，子用例和父用例相似，但表现出更特别的行为；子用例将继承父用例的所有结构、行为和关系。子用例可以使用父用例的一段行为，也可以重载它。父用例通常是抽象的。 用例之间的is a kind of 关系，表示用例之间的场景共享；Actor之间的 is a kind of关系，一般描述职责共享。 【箭头指向】：指向父用例 包含 包含关系用来把一个较复杂用例所表示的功能分解成较小的步骤。一个用例可以包含另外一个用例。 【箭头指向】：指向分解出来的功能用例 拓展 扩展关系是指用例功能的延伸，相当于为基础用例提供一个附加功能。由一个用例的扩展点可以扩展出另外一个用例。 【箭头指向】：指向基础用例 包含和拓展的区别 在扩展关系中，一个基本用例执行时，可以执行、也可以不执行扩展用例部分 在包含关系中，在执行基本用例时，一定会执行包含用例部分 关系 功能 表示法 关联 参与者与其参与执行的用例之间的通信途径 扩展 在基础用例上插入基础用例不能说明的扩展部分 泛化 用例之间的一般和特殊关系，其中特殊用例继承了一般用例的特性并增加了新的特性 包含 在基础用例上插入附加的行为，并且具有明确的描述 四、软件设计 4.1 软件设计的概念 软件设计定义为软件系统或组件的架构、构件、接口和其他特性的定义过程及该过程的结果。 作为软件生命周期中的一个活动，软件设计是连接用户需求和软件技术的桥梁，通过它，主要从软件外部视角提出的需求分析才能被转化为软件内部的结构，并且它还要指导后续的软件编码工作。 可以把设计工程活动分为软件架构设计与软件详细设计两种，分别描述软件的概貌与细节。 值得注意的地方是，软件设计大部分的工作为分解设计，也就是将软件映射为各组件；而系列模式设计，可以帮助我们提高相似组件的可复用性。 与需求分析阶段建立分析模型一样，设计阶段也需要建立设计模型。以需求分析阶段建立的数据模型、功能模型和行为模型为输入，设计阶段会建立数据、架构、接口和组件方面的设计模型 设计模型的分类 数据设计 架构设计 接口设计 组件设计 好的设计方案的特点 第一，正确的承上，也就是说正确传递分析模型的结果； 第二，正确的启下，即是说对软件开发后续过程的进行是有帮助的，影响应该是正面的。 第三，从实现的角度给软件一个完整的说明，通过设计方案能够准确的预期未来的产品形态。 设计的质量属性 功能性，指的是软件的功能要完整，符合用户的预期。 易用性，指的是软件要好用，界面对用户友好。可靠性，是指软件不易出错，运行稳定。 性能，主要是指软件的吞吐率和响应时间等等，能运行而且运行流畅。 可支持性，又包含三个属性：扩展性、适应性和可维护性。 扩展性是指软件添加新的功能或升级已有功能是否方便； 适应性是指软件适应新的环境、新的变化是否容易； 可维护性是指程序代码是否易懂、软件维护期间的成本是否更小等等。 设计相关概念 抽象：“忽略具体的信息将不同事物看成相同事物的过程”，包括数据抽象和过程抽象 数据抽象：描述数据对象的冠名数据集合 过程抽象：具有明确和有限功能的指令序列 体系结构：软件的整体结构和这种结构为系统提供概念上完整性的方式，可以使用大量的一种或多种模型来表达 结构模型 框架模型 动态模型 过程模型 功能模型 设计模式：在给定上下文环境中一类共同问题的共同解决方案，它能够为一类相似的问题提供一种共同的解决方案，减少重复求解的工作量 模块化：软件被划分为命名和功能相对独立的多个组件（通常称为模块），通过这些组件的集成来满足问题的需求 信息隐藏：模块定义和设计时应该保证模块内的信息不可以被不需要这些信息的其他模块访问 抽象有助于定义构成软件的过程（或信息）实体。 信息隐藏原则定义和隐藏了模块内的过程细节和模块内的本地数据结构。 一旦实现了信息隐藏，减少了透明调用，那么模块内部的功能显然就相对独立了 功能独立：每个模块只负责需求中特定的子功能，并且从程序结构的其他部分看，该模块具有简单的接口 易于开发：功能被划分，接口被简化 易于维护（和测试）：次生影响有限，错误传递减少，模块重用 定性衡量标准包括 内聚性：模块的功能相对强度 耦合性：模块之间的相互依赖程度 模块独立性强 = 高内聚低耦合 精化：逐步求精的过程 抽象使设计师确定过程和数据，但不局限于底层细节 精化有助于设计者在设计过程中揭示底层细节 重构：不改变组件功能和行为条件下，简化组件设计（或代码）的一种重组技术 检查现有设计的冗余情况、未使用的设计元素、无效或不必要的算法、较差的构建方式或不恰当的数据结构，或任何其他可被更改从而优化设计的问题 数据设计 数据设计（有时也被称为数据架构）构建高层抽象（客户/用户的数据视图）的数据模型、信息模型 体系结构设计 系统需要执行的函数功能组件集（比如数据库有哪些表、程序有哪些类）， 组件之间通信、协同和合作的连接器（比如如何让一个类从数据库里获取数据）， 组件集成构成系统的约束（比如集成之后不同层次的类能否随意访问）， 整体特性的语义模型分析。我们经常会基于一些成熟的体系结构框架来搭建自己的体系结构。 部署设计 部署设计也属于体系架构设计的内容。它需要全盘考虑先前设计方案与QoS需求，平衡取舍相关问题成本，以实现最佳解决方案。提前考虑软件的部署，也有助于提早发现环境对软件带来的约束，从而在设计阶段考虑相应的解决办法。 接口设计（含界面设计） 接口设计其实包含内部接口的设计与外部接口的设计两个方面。 内部接口的设计主要是指内部模块之间进行通信的接口设计，一般会作为架构设计或组件设计的一部分同时进行； 而外部接口包括人机接口以及系统与外部系统的接口。 组件设计 组件设计，分为面向过程与面向对象两种方法。 面向过程的组件设计主要是指函数与模块等的设计内容 面向对象的组件设计主要是指类与操作等的设计内容 4.2 面向过程的设计 变换分析 事务分析 混合结构分析 结构化组件设计 组件级设计也称为过程设计、详细设计，位于数据设计、体系结构设计和接口设计完成之后 流程图 利用各种方块图形、线条及箭头等符号来表达解决问题的步骤及进行的顺序； 是算法的一种表示方式 优点 所有流程一目了然，工作人员能掌握全局。 更换人手时，按图索骥，容易上手。 所有流程在绘制时，很容易发现疏失之处，可适时予以调整更正，使各项作业更为严谨。 盒图（N-S图） PDL（程序设计语言） PDL是一种用于描述功能模块的算法设计和加工细节的语言。称为程序设计语言。它是一种伪码。 伪码的语法规则分为“外语法”和“内语法”。 PDL具有严格的关键字外语法，用于定义控制结构和数据结构，同时它的表示实际操作和条件的内语法又是灵活自由的，可使用自然语言的词汇。 判定表（决策表） 判定表用于表示程序的静态逻辑 在判定表中的条件部分给出所有的两分支判断的列表，动作部分给出相应的处理 要求将程序流程图中的多分支判断都改成两分支判断 4.3 面向对象的设计 架构设计 架构设计的目的是要勾画出系统的总体结构，这项工作由经验丰富的架构设计师主持完成。 构造系统的物理模型 设计子系统 非功能需求设计 进一步细化用例 类：类是包含信息和影响信息行为的逻辑元素。类的符号是由三个格子的长方形组成，有时下面两个格子可以省略。 详细设计一个类 由构件工程师详细设计每个类的属性、方法和关系。 定义类的属性 定义类的操作 定义类之间的关系 UML 顺序图 顺序图描述了对象之间传送消息的时间顺序，用来表示用例中的行为顺序。 顺序图将交互关系表示为一个二维图。即在图形上，顺序图是一张表，其中显示的对象沿横轴排列，从左到右分布在图的顶部；而消息则沿纵轴按时间顺序排序。创建顺序图时，以能够使图尽量简洁为依据布局 对象：顺序图中对象的符号和对象图中对象所用的符号一样。 面向对象设计与结构化设计的过程和方法完全不同，要设计出高质量的软件系统，记住： 对接口进行设计 发现变化并且封装它 先考虑聚合然后考虑继承 类内聚——设计类的原则是一个类的属性和操作全部都是完成某个任务所必须的，其中不包括无用的属性和操作 在面向对象设计中，耦合主要指不同对象之间相互关联的程度。如果一个对象过多地依赖于其它对象来完成自己的工作，则不仅使该对象的可理解性下降，而且还会增加测试、修改的难度，同时降低了类的可重用性和可移植性。 交互耦合： 如果对象之间的耦合是通过消息连接来实现的，则这种耦合就是交互耦合。在设计时应该尽量减少对象之间发送的消息数和消息中的参数个数，降低消息连接的复杂程度。 继承耦合 继承耦合是一般化类与特殊化类之间的一种关联形式，设计时应该适当使用这种耦合。在设计时要特别认真分析一般化类与特殊化类之间继承关系，如果抽象层次不合理，可能会造成对特殊化类的修改影响到一般化类，使得系统的稳定性降低。另外，在设计时特殊化类应该尽可能多地继承和使用一般化类的属性和服务，充分利用继承的优势。 可重用性 软件重用是从设计阶段开始的，所有的设计工作都是为了使系统完成预期的任务，为了提高工作效率、减少错误、降低成本，就要充分考虑软件元素的重用性。重用性有两个方面的含义 尽量使用已有的类，包括开发环境提供的类库和已有的相似的类； 如果确实需要创建新类，则在设计这些新类时考虑将来的可重用性。 五、程序实现 5.1 程序设计语言 程序应该正确、有效、易理解、简单、自然、可拓展、可伸缩 程序设计语言是：人与计算机通信的最基本工具。 特点是：不同的语言适用于不同的应用 发展历程 第一代：机器语言 第二代：汇编语言 第三代：高级程序设计语言 第四代：4GL 5.2 编程习惯 提高可靠性 减少失效性 降低调试、维护成本 可读性 可运行 设计原则 自顶向下 逐步细化 模块化 设计风格 基本要求 可读性要求 正确性与容错性要求 可移植性要求 输入输出要求 重用性要求 5.3 程序的效率 程序的效率：程序的执行速度及程序所需占用的存储空间。 效率是一个性能要求，应当在需求分析阶段给出。软件效率以需求为准，不应以人力所及为准。 影响因素 算法 存储 输入输出 5.4 编码管理 版本管理的意义 目的：标识、控制和追踪软件开发和实施过程中产生的各种软件产品版本。 常见版本命名规则 主版本号 . 子版本号 [. 修正版本号 [. 编译版本号 ]] 面向对象程序设计 概念：对象、类、数据抽象、继承、动态绑定、数据封装、多态性、消息传递 含义：面向对象程序设计是以建立模型体现出来的抽象思维过程和面向对象的方法。 方法：选择程序设计语言、类的实现、方法的实现、用户接口的实现等 六、软件质量保证 6.1 软件质量相关概念 质量控制QC 审查产品相关的各个方面质量的过程 质量保证QA 系统监测和评估工程的各个方面，最大限度提高质量最低标准 软件质量：明确表示是否符合功能和性能要求，明确地记载开发标准和所有专业开发软件的期望的隐性特点 软件质量保证(SQA)：遵照一定的软件生产标准、过程和步骤对软件质量进行评估的活动。 审查：评审既定标准是否得到遵守。如IEEE、ISO、GB/T等 监督：对比文档中描述的执行和实际操作步骤，确保执行过程采取适当步骤和操作方式 审计：确保开发过程使用了恰当的质量控制措施，以符合相应的标准或过程。 软件评审 一个过程或会议期间进行的软件产品的审核，由项目人员、管理人员，用户、客户、用户代表或其他有关各方对一个软件产品进行评论或批准 软件可靠性 是指在给定时间内，特定环境下软件无错运行的概率 6.2 软件测试策略 含义 软件测试策略为软件开发人员、质量保证组织、和客户提供了一个路线图 测试 要求 灵活性：有足够的可塑性来应付所有的大软件系统 严格：保证对项目进程进行合理的计划和跟踪管理 单元测试：主要目的是验证软件模块是否按详细设计的规格说明正确运行。 集成测试：主要目的是检查多个模块间是否按概要设计说明的方式协同工作。 系统测试：主要目的是验证整个系统是否满足需求规格说明。 验收测试：从用户的角度检查系统是否满足合同中定义的需求，以及以确认产品是否能符合业务上的需要。 回归测试 指有选择地重新测试系统或其组件，以验证对软件的修改没有导致不希望出现的影响，以及系统或组件仍然符合其指定的需求。 回归测试可以在所有的测试级别执行，并应用于功能和非功能测试中。 软件测试策略基本步骤 计划与准备阶段 执行阶段 返工与回归阶段 6.3 软件测试技术 单元测试：针对软件设计的最小单位 ─ 程序模块，进行正确性检验的测试工作。 测试内容 模块接口 局部数据结构 边界条件 出错处理 独立路径 测试环境搭建 模块并非独立程序，进行测试时，要考虑它和外界的联系，需用一些辅助模块去做相应模拟 驱动模块：用来模拟被测试模块的上一级模块，相当于被测模块的主程序。 桩模块：模拟被测试的模块所调用的模块，而不是软件产品的组成的部分。 集成测试 含义：将软件集成起来后进行测试。别名：子系统测试、组装测试、部件测试等。 目的：检查诸如两个模块单独运行正常，但集成起来运行可能出现问题的情况。 方法：自顶向下的集成方法、自底向上的集成方法、SMOKE方法 自顶向下的集成方法 基本思想：该集成方式将模块按系统程序结构，沿控制层次自顶向下进行集成。 优点：可以较早地验证主要的控制和判断点。按深度方向，可首先实现和验证一个完整的软件功能。 缺点：是桩模块的开发量较大 适用： 控制结构清晰稳定； 高层接口变化较小； 底层接口未定义或经常可能被修改； 接口控制组件具有较大的技术风险， 需要尽早被验证； 希望尽早能看到产品的系统功能行为。 自底向上的集成方法 基本思想：从软件结构最底层的模块开始，按照接口依赖关系逐层向上集成进行测试。 优点：每个模块调用其他底层模块都已经测试，不需要桩模块； 缺点：必须编写驱动模块；缺陷的隔离和定位不如自顶向下。 适用： 底层接口比较稳定； 高层接口变化比较频繁； 底层组件较早被完成。 系统测试 压力测试 性能测试 功能测试 恢复测试 安全测试 配置测试 兼容性测试 文档测试 易用性测试 测试用例（test case）：是测试输入、执行条件、以及预期结果的集合，是为特定的目的开发的，例如执行特定的程序路径或验证与指定的需求相符合。 主要测试方法 黑盒测试：忽略系统或组件的内部机制，仅关注于那些响应所选择的输入及相应执行条件的输出的测试形式 白盒测试：考虑系统或组件的内部机制的测试形式 灰盒测试：介于白盒测试与黑盒测试之间的一种测试，多用于集成测试阶段，不仅关注输出、输入的正确性，同时也关注程序内部的情况。 白盒测试 对程序模块的所有独立的执行路径至少测试一次； 对所有的逻辑判定，取“真”与取“假”的两种情况都至少测试一次； 在循环的边界和运行界限内执行循环体； 测试内部数据结构的有效性等。 语句覆盖：就是设计若干个测试用例，运行被测程序，使得每一可执行语句至少执行一次。 测试用例的设计格式如下 【输入的(A, B, X)，输出的(A, B, X)】 为图例设计满足语句覆盖的测试用例是: 【(2, 0, 4)，(2, 0, 3)】 分支覆盖：就是设计若干个测试用例，运行被测程序，使得程序中每个判断的取真分支和取假分支至少经历一次。分支覆盖又称为判定覆盖。 【(2, 0, 4)，(2, 0, 3)】覆盖 ace【L1】 【(1, 1, 1)，(1, 1, 1)】覆盖 abd【L2】 或 【(2, 1, 1)，(2, 1, 2)】覆盖 abe【L3】 【(3, 0, 3)，(3, 1, 1)】覆盖 acd【L4】 条件覆盖：设计若干个测试用例，运行被测程序，使得程序中每个判断的每个条件的可能取值至少执行一次。 测试用例 覆盖条件 覆盖组合 【(2, 0, 4), (2, 0, 3)】 (L1) ①, ⑤ 【(2, 1, 1), (2, 1, 2)】 (L3) ②, ⑥ 【(1, 0, 3), (1, 0, 4)】 (L3) ③, ⑦ 【(1, 1, 1), (1, 1, 1)】 (L2) ④, ⑧ 控制流图覆盖测试：是将代码转变为控制流图（CFG），基于其进行测试的技术。 结点：符号○ ，表示一个或多个无分支的PDL语句或源程序语句。 边：箭头，表示控制流的方向。 汇聚节点：在选择或多分支结构中，分支的汇聚处应有一个汇聚结点。 区域：边和结点圈定的区域。对区域计数时，图形外的区域也应记为一个区域。 结点覆盖：对图中的每个节点，至少要有一条测试路径访问该节点。显然，节点覆盖=语句覆盖 边覆盖：对图中每一个可到达的长度小于(无边图)等于1 的路径，中至少存在一条测试路径覆盖。显然，边覆盖包含节点覆盖，且边覆盖也可以实现分支覆盖。 路径覆盖测试：就是设计足够的测试用例，覆盖程序中所有可能的路径 基本路径测试：将覆盖的路径数压缩到一定限度内，程序中的循环体最多只执行一次。 程序的环路复杂性：程序基本路径集中的独立路径条数，这是确保程序中每个可执行语句至少执行一次所必需的测试用例数目的上界。 独立路径：从控制流图来看，一条独立路径是至少包含有一条在其它独立路径中从未有过的边的路径。 计算方法： 为边数， 为点数 黑盒测试 测试对象看做一个黑盒子，测试人员完全不考虑程序内部的逻辑结构和内部特性 只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明 又叫做功能测试或数据驱动测试。 基本思想 把所有可能的输入数据，即程序的输入域划分成若干部分，然后从每一部分中选取少数有代表性的数据做为测试用例。 测试步骤 划分等价类 选取测试用例 等价类：某个输入域的子集合。在该子集合中，各个输入数据对于揭露程序中的错误都是等效的。 有效等价类：对于程序的规格说明来说，是合理的，有意义的输入数据构成的集合。 无效等价类：对于程序的规格说明来说，是不合理的，无意义的输入数据构成的集合。 原则1： 如果输入条件规定了取值范围，或值的个数，则可以确立一个有效等价类和两个无效等价类。 原则2：如果输入条件规定了输入值的集合，或者规定了“必须如何”的条件，这时可确立一个有效等价类和一个无效等价类。 原则3：如果输入条件是一个布尔量，则可以确定一个有效等价类和一个无效等价类。 原则4：如果规定了输入数据的一组值，而且要对每个输入值分别进行处理。可为每一个输入值 确立一个有效等价类，所有不允许的输入值集合为一个无效类。 原则5：如果规定了输入数据必须遵守的规则，则可以确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）。 等价类划分步骤 确定等价类 建立等价类表，列出所有划分出的等价类 为每一个等价类规定一个唯一编号； 设计一个新的测试用例，尽可能多地覆盖尚未被覆盖的有效等价类，重复这一步，直到所有的有效等价类都被覆盖为止； 设计一个新的测试用例，仅覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类都被覆盖为止 例 在某一PASCAL语言版本中规定：“标识符是由字母开头，后跟字母或数字的任意组合构成。有效字符数为不超过8个。” 并且规定：“标识符必须先说明，再使用。” “在同一说明语句中，标识符至少必须有一个。” 输入条件 有效等价类 无效等价类 标识符个数 ≥1个 (1) 0个 (2) 标识符字符数 8个 (3) 0个 (4)；&gt;8个 (5) 标识符组成 字母、数字的任意组合 (6)； 非字母数字字符 (7)；保留字 (8) 第一个字符 字母 (9) 非字母 (10) 标识符使用 先说明后使用 (11) 未说明已使用 (12) 七、软件维护 7.1 软件维护的概念和分类 IEEE/EIA 12207[ISO/IEC2008]中对软件维护的定义是：软件维护是指由于软件产品出现问题或需要改进而对代码及相关文档的修改，其目的是对现有软件产品进行修改的同时保持其完整性。 7.2 软件维护应注意的问题 管理方面 技术方面 维护费用估算 7.3 软件维护技术 程序的理解 软件再工程 软件逆向工程 八、软件项目管理 8.1 软件项目管理概念 软件项目管理的定义 计划、协调、度量、监控、控制及报告等管理方法在软件开发和维护中的具体应用，以保证整个过程是系统的、有原则的、可量化的(IEEE610.12-90)。 软件项目管理是为了使软件项目能够按照预定的成本、进度、质量顺利完成，而对人员（People）、产品（Product）、过程（Process）和项目(Project)进行分析和管理的活动。 软件项目管理的4P要素 人员：招聘、选拔、绩效管理、培训、薪酬、职业发展、组织和工作设计、团队/文化的发展 过程：软件过程提供一个框架，在此框架下可以制定项目开发的综合计划。 产品：策划一个项目以前，应当建立产品的目标和范围，考虑可选的解决方案 项目：理解成功项目管理的关键因素，掌握项目计划、监控和控制的一般方法 8.2 软件度量概念及面向规模的度量 软件度量的目的 软件项目管理的成熟化也需要度量与数字化，目的是持续改进软件过程，并用于项目估算、质量控制、生产率评估等。 软件度量的内容 软件度量的内容主要包括两个方面 一方面是对软件生产率的度量，这包括对项目工作量、项目周期、项目成本等方面的度量， 另一方面是对软件质量的度量，比如产品发布之前发现的缺陷数、产品发布后用户报告的缺陷数、产品的运行速度、可存储的容量、一段时间内累积无效服务时间等 在项目的初期，根据经验对当前软件项目的工作量和时间进行估算，随着项目的进展，将实际花费的工作量和时间与最初估算的工作量和时间进行对比，用于监控与调整项目的进展。无论是生产率度量还是质量度量，由于软件是人脑的创造性工作，不是流水线上提前完全确定可知的作业时间和工作量，这要求我们在进行项目度量时要以行业及组织的历史数据作为软件项目度量的基础。 软件度量的方法 主要是 面向规模的度量 面向功能点的度量 还有 面向对象的度量 面向用例的度量 面向规模的度量 通过对质量和（或）生产率的测量进行规范化而得到的，这些测量是根据开发过的软件的规模得到的。 千行代码（ KLOC ）： 这些代码指的是源代码，通过源代码的行数来直观度量一个软件程序有多大规模 生产率（PM）：PM = L / E, L表示代码总量(单位：KLOC)，E表示软件工作量(单位：人月) 每千行代码的平均成本（ CKL ）：CKL = S / L，S为软件项目总开销 ， L表示代码总量(单位：KLOC) 代码出错率（EQRl）：EQRl = Ne / L，Ne表示代码出错的行数， L表示代码总量(单位：KLOC) 文档与代码比（Dl）：Dl = Pd / L，Pd表示文档页数， L表示代码总量(单位：KLOC) 项目 代码行数（KLOC） 工作量（人月） 成本 （万元） 缺陷代码行数 文档页数 人员 A 12.1 24 168 134 29 3 B 27.2 62 440 321 1224 5 C 20.2 43 314 256 1050 6 以项目A为例： 生产率（PM）= 12.1/24 = 0.51 每千行代码的平均成本（ CKL ）= 168/12.1=13.9 代码出错率（EQRl）=134/12.1= 11.1 文档与代码比（Dl）=29/12.1=2.4 优点 简单易行，自然直观 缺点 依赖于程序设计语言的表达能力和功能 软件开发初期很难估算出最终软件的代码行数 对精巧的软件项目不合适 8.3.面向功能的度量 面向功能度量的概念 面向功能的软件度量基本思想是用软件的功能表示软件的规模，软件包含的功能越多，软件的规模越大。 应用最广泛的是功能点（Function Point, FP）法，前面小节讲的面向规模的度量是以代码行作为度量软件规模的基本单元。 而功能点法以功能点作为度量软件规模的基本单元。由于是以功能点作为度量依据，这种方法容易在项目开发初期就可估算出 ，但和面向规模的度量类似，功能点计算仍然要基于经验公式。 以发生过的历史项目数据作为度量的参考。 功能点法计算公式 UFC (Unadjusted Function Component) : 未调整功能点计数, 5个信息量的“加权和” TCF (Technical Complexity Factor): 技术复杂度因子 Fi: 14个因素的“复杂性调节值” (i =1..14) 0.65, 0.01都是经验常数，现在由国际组织根据大量项目跟踪分析获得。 UFC 相关五类组件 内部逻辑文件（ILF, Internal Logical Files ） 一个用户可识别的逻辑相关的数据组，它在应用程序边界内，由用户输入来维护 它可能是某个大型数据库的一部分或是一个独立的文件 外部接口文件（EIF, External Interface Files） 一个用户可识别的逻辑相关的数据组，但只能被引用，且数据完全存于软件外部，由另一个应用程序进行维护 是机器可读的全部接口（如磁盘或磁带上的数据文件） 是另一个应用程序的内部逻辑文件 外部输入（EI, External Input） 来自于软件外部的数据输入 控制信息(不更新ILF) / 业务逻辑信息（更新ILF） 可来自于一个数据输入屏幕或其他应用程序。 外部输出（EO, External Output） 经过处理的数据，由程序内部输出到外部 从ILF、EIF中取出数据经过一定的组合、计算后得出的输出数据, 如生成报表, 派生数据, 可能更新ILF 用户查询（EQ, External Query） 一个输入输出的组合过程，从一个或多个ILF、EIF中取出数据输出到程序外部 输入过程不更新ILF，输出过程不进行任何数据处理 功能组件类型 简单 中等 复杂 外部输入数（EI） 3 4 6 外部输出数（EO） 4 5 7 外部查询表（EQ） 3 4 6 内部逻辑文件数（ILF） 7 10 15 外部接口文件数（EIF） 5 7 10 外部输入EI数×加权因子(简单=3,平均=4,复杂=6) 外部输出EO数×加权因子(简单=4,平均=5,复杂=7) 外部查询EQ数×加权因子(简单=3,平均=4,复杂=6) 内部逻辑文件ILF数×加权因子(简单=7,平均=10,复杂=15) 外部接口EIF数×加权因子(简单=5,平均=7,复杂=10) UFC ＝ 上述计算值的总和（加权和） 复杂性调节因素 1.系统需要可靠的备份和复原吗？ 2.系统需要数据通信吗？ 3.系统有分布处理功能吗？ 4.性能很关键吗？ 5.系统是否运行在既存的、高度实用化的操作系统环境中？ 6.系统需要联机数据项吗？ 7.联机数据项是否在多屏幕或多操作之间进行切换？ 8.需要联机更新主文件吗？ 9.输入、输出、查询和文件很复杂吗？ 10.内部处理复杂吗？ 11.代码需要被设计成可重用吗？ 12.设计中需要包括转换和安装吗？ 13.系统的设计支持不同组织的多次安装吗？ 14.应用的设计方便用户修改和使用吗？ 复杂性调节因素值Fi 0-没有影响 1-偶有影响 2-轻微影响 3-平均影响 4-较大影响 5-严重影响 面向功能的度量优缺点 优点 与程序设计语言无关, 在开发前就可以估算出软件项目的规模 不足 没有直接涉及算法的复杂度，不适合算法比较复杂的软件系统； 功能点计算主要靠经验公式，主观因素比较多 8.4. 软件项目估算 软件项目估算概念 概念 项目启动之前，软件团队应该估算将要做的工作、所需要的资源、成本、从开始到完成的时间，也即是对这些内容进行预测 策略 项目度量方法为项目估算提供了依据与有效输入 尽量把估算推迟到项目的后期进行 根据已经完成的项目进行估算 三点期望值法 在基于问题的分解估算方法中，通过估计最大值、最小值、最可能值的加权平均值作为期望值来估算 估计期望值最大值最可能值最小值 例如：如果估计系统X规模的最大值为100KLOC，最小值为50KLOC，最可能值为60KLOC，则其估计期望规模为(100+4×60+50)/6 = 65KLOC 例 软件描述(CAD软件) CAD图形软件可接受来自用户的二维和三维几何数据，用户通过界面与CAD软件进行交互，并控制它，该软件具有良好的人机界面设计的特征。所有的几何数据及其支持信息存放在数据库中。开发设计分析模块，以产生所需的输出，这些输出将显示在各种不同的图形化设备上。软件在设计中要考虑与外设进行交互并控制它们，包括鼠标、数字化仪、打印机等。 基于LOC的项目估算 估算出各个子系统的代码行，例如三维几何分析功能的代码行估算范围为： 乐观值a：4600 可能值m：6900 悲观值b：8600 估算值： e = (a + 4m + b)/6 = 6800 子系统 代码行 图形用户界面及其控制机制 2 300 二维几何分析 5 300 三维几何分析 6 800 数据库管理 3 350 计算机图形显示 4 950 外设控制(与打印机、扫描仪等的接口) 2 100 设计分析子系统 8 400 合计 33200 历史数据 平均生产率PM: 620 LOC/PM(620行代码/人月) 每个人月的成本 C = 8000￥ 估算项目成本和工作量 估算工作量 = 总代码行/PM= 33200/620=54人月 估算成本 = 估算工作量 ×每个人月的成本 = 54人月× 8000 = 432000￥ 基于功能点的项目估算 信息域 乐观值 可能值 悲观值 估算计数 加权因子 FP计数 输入数 20 24 30 24 4 96 输出数 12 15 22 16 5 80 查询数 16 22 28 22 4 88 文件数 4 4 5 4 10 40 接口数 2 2 3 2 7 14 总计 318 计算出FP的估算值 FP = (0.65 + 0.01×∑Fi)×CT = 372 历史数据 平均生产率 6.5 FP/PM 每个人月的成本 C = 8000￥(平均月薪) 估算成本和工作量 工作量 58人月 成本 457000￥ 基于过程分解的项目估算 活动 客户沟通 策划 风险分析 工程 构造发布 客户评估 合计(人月) 任务→ 分析 设计 编码 测试 功能↓ UICF 0.5 2.5 0.4 5.0 n/a 8.4 2DGA 0.75 4.0 0.6 2.0 n/a 7.35 3DGA 0.5 4.0 1.0 3.0 n/a 8.5 CGDF 0.5 3.0 1.0 1.5 n/a 6.0 DBM 0.5 3.0 0.75 1.5 n/a 5.75 PCF 0.25 2.0 0.5 1.5 n/a 4.25 DAM 0.5 2.0 0.5 2.0 n/a 5.0 合计 0.25 0.25 0.25 3.5 20.50 4.5 16.5 46.0 工作量 1% 1% 1% 8% 45% 10% 36% 8.5. 基于经验的软件估算 基于回归分析的经验估算模型 通过对以往软件项目中搜集的数据进行回归分析而导出 E=A+B×(ev)C 其中A、B、C是经验常数，E是工作量（人月），ev是估算变量（LOC或功能点） 面向规模的回归分析经验估算模型 E=5.2×(KLOC)0.91 Walston-Felix模型 E=5.5+0.73×(KLOC)1.16 Bailey-Basili模型 E=3.2×(KLOC)1.05 Boehm简单模型 E=5.288×(KLOC)1.047 Doty模型，用于KLOC&gt;9的情况 E=A+B×(ev)C 其中A、B、C是经验常数，E是工作量（人月），ev是估算变量（LOC或功能点） 面向功能点的回归分析经验估算模型 E=-91.4+0.355FP Albrecht和Gaffney模型 E=-37+0.96FP Kemerer模型 E=-12.88+0.405FP 小型项目回归模型 基本COCOMO模型公式及计算方法 COCOMO是指COnstructive COst MOdel，构造性成本模型，Boehm于1981年提出，用于对软件开发项目的规模、成本、进度等方面进行估算 COCOMO模型是一个综合经验模型，模型中的参数取值来自于经验值，并且综合了诸多的因素、比较全面的估算模型 在欧盟国家应用较为广泛 8.6 项目进度计划 项目进度计划概念 定义：对项目进行任务划分，定义任务之间的依赖关系，并进行时间估算和资源分配，确保以最佳的时间与成本输出满足质量要求的产品 价值 有序、可控制地对软件项目进行管理 确保员工保持高生产率 及时交付软件产品 降低软件开发成本 提高客户满意度 及时发布产品新版本 甘特图 显示基本的任务信息 定义并查看任务的工期、开始时间和结束时间 定义并查看任务所分配的资源的信息 可定义任务间的前后关系 里程碑 里程碑显示项目进展中的重大工作完成 里程碑不同于活动：活动是需要消耗资源的，里程碑仅仅表示事件的标记 8.7 WBS分解与任务网络图 定义 工作分解结构（Work Breakdown Structure, WBS）是将项目按照功能或过程进行逐层分解，直到划分为若干内容单一、便于组织管理的单项工作，最终形成的树形结构示意图。 作用 相关成员可直观了解软件项目中的各项任务（活动） 将项目分解为可管理的任务（活动） 作为项目计划与跟踪的基础 任务网格图 定义 任务网络图是项目所有任务（活动）及其之间逻辑关系（依赖关系）的一个图解表示，并从左到右来表示项目的时间顺序。 作用 可以分解任务以及各项任务所需要耗费的时间及成本 可以显式的描绘各个任务间的时序依赖关系 构成 任务网络图是一个有向权重网络图，一般用节点表示事件，弧表示任务（活动） ，弧上的权值表示任务（活动）耗费的时间 8.8 关键路径 关键路径（critical path） 在任务网络图中，从项目开始到项目完成有许多条路径，路径上所有弧权重之和最大的路径（路径最长）叫关键路径。 非关键路径（noncritical path） 在整个任务网络图中非最长的路径都叫非关键路径。 例 （a）此网络中有多少路径? （b）每条路径的长度是多少? （c） 哪一条是关键路径? （d）完成项目的最短时间是多少? 答： 两条：ABCDFHI, ABCEGHI ABCDFHI=19天, ABCEGHI=20天 ABCEGHI 20天 关键路径的意义 关键路径上任何任务（活动）的延长都会导致整个项目周期的延长 如果想缩短项目周期，就必须缩短关键路径的长度 项目经理应该随时关注关键路径上任务（活动）的完成情况以及关键路径是否发生了变化 对WBS中任务的串行与并行安排方式有指导意义 串并行组合方式可能比纯并行对人员安排更合理","categories":[{"name":"总结","slug":"总结","permalink":"https://20021123.xyz/categories/%E6%80%BB%E7%BB%93/"},{"name":"软件工程","slug":"软件工程","permalink":"https://20021123.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"https://20021123.xyz/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"计算机图形学","slug":"计算机图形学","date":"2023-02-25T04:33:11.000Z","updated":"2023-02-25T04:44:56.000Z","comments":true,"path":"2023/02/25/计算机图形学/","link":"","permalink":"https://20021123.xyz/2023/02/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/","excerpt":"","text":"一、问答题 1. 数字图像处理、计算机图形学、模式识别的关系 图像处理 利用计算机对图像进行分析处理，继而再现图像 模式识别 计算机对图形信息进行的识别和分析描述，是从图形（图像）到描述表述的过程 计算机图形学 研究图形的计算机生成和基本图形操作，是从数据描述到图形生成的过程 2. 图形管线的各个阶段工作 image-20230214015150862 3. 传统成像方法与计算机绘制成像的原理 传统成像如小孔成像；外界光通过反射经过角膜进入眼睛最后到达视网膜由内部能量刺激产生神经信号。 计算机将存储在内存中的形状转换成实际绘制在屏幕上的对应的过程称为 渲染。渲染过程中最常用的技术就是光栅化。 4. 计算机图形处理架构（有GPU模式和无GPU模式） 有GPU模式，显示指令和数据通过总线发送到GPU，GPU执行的结果，存储在显存中，视频控制器自主东显存的framebuffer中获取数据进行显示 无CPU模式，所有的指令都在CPU上执行，结果存储在主存储器的特定区域。视频控制器自主根据频率从该内存区域获取数据然后发送到显示端。 5. 简述光栅式扫描显示系统 现代计算机图像学对图像结果的展示是采用点阵像素的方式，类似于数字图像的表达，是标准的栅格方式。 图像的动态显示是以动态扫描的方式来进行，按照一秒多少帧作为帧率，每个帧分为相应的行，每个行又包括相应的像素点。 6. 屏幕分辨率三种描述，扫描频率，带宽计算 光点直径 光点的直径，显示器的物理光点尺寸。 荧光屏上两个相邻的相同颜色磷光点之间的最短距离,单位：mm 水平方向上的光点数×垂直方向上的光点数 r(x×y) 显示器精度dpi 带宽计算 •行频(水平扫描频率) 电子枪每秒在屏幕上扫描过的水平线数，单位: KHz •帧频(重绘率/垂直扫描频率/场频) 每秒钟重复绘制显示画面的次数，单位： Hz •显示带宽 理论带宽 B= r(x) ×r(y)×d ×v 7. GPU 与 CPU 的执行区别 CPU是按照指令队列的方式来执行，只要编写好指令就能够完成几乎所有的任务，包括图形绘制等。 GPU的处理方式不同于CPU，而是按照管线的方式进行，固定的管线流程确定了具体的操作，而相关的指令只是改变管线的参数和属性，获取输入要绘制对象的模型数据。管线根据数据处理分为两个阶段：顶点处理阶段和像素处理阶段。 顶点阶段的处理包括：几何变换，光照运算，裁剪等。经过投影变换之后进入像素处理阶段，包括图元生成，光栅处理以及纹理和buffer的处理等 8. 深度检测与深度buffer的作用机理 在绘制3D场景的时候，我们需要决定哪些部分对观察者是可见的，或者说哪些部分对观察者不可见。 对于不可见的部分，我们应该及早地丢弃，例如在一个不透明的墙壁后的物体就不应该渲染。但是这种方法无法解决物体存在互相重叠的情况如下图。 因而，出现了像素级别的深度缓冲方法：当图元光栅化时，一些插值属性被写入输出缓存中。其中一个属性就是顶点坐标的 z 值，被写入称为深度缓存的缓存中。开始时，深度缓存初始化为可能的最大值，然后光栅化每个图元，对于每个被覆盖的像素，计算它的 z 值，如果 z 值小于深度缓存中的当前值，则用新值替换深度缓存中的值 9. vertex shader 与 fragment shader 分别实现什么样的内容 顶点着色器程序用来描述顶点需要执行的模型变换、视变换、投影变换、光照（Transform and lighting）处理的顶点着色器程序源代码/可执行文件。 在顶点着色器进行的业务处理有： 矩阵变换的计算 计算光照公式生成逐顶点颜色 生成/变换纹理坐标 片元着色器程序是用来描述片段上执行操作(如颜色混合)的片元着色器程序源代码/可执行文件。 在片元着色器的业务处理有： 计算颜色 获取纹素 往像素点中填充颜色值 它可以用于图片/视频中每个像素的颜色填充【比如给视频添加滤镜，实际上就是将视频中每个图片的像素点颜色填充进行修改】 10. shader 编程中，变量标识 uniform，attribute，varying 分别代表什么意思 uniform 变量 uniform 变量是外部 application 程序传递给（ vertex 和 fragment ）shader 的变量。因此它是 application 通过函数 glUniform() 函数赋值的。在（vertex和fragment）shader 程序内部，uniform 变量就像是 C 语言里面的常量（const），它不能被 shader 程序修改。（shader只能用，不能改） uniform变量一般用来表示：变换矩阵，材质，光照参数和颜色等信息。 attribute 变量 attribute 变量是只能在 vertex shader 中使用的变量。（在 fragment shader 中不能声明或引用） 一般用attribute变量来表示一些顶点的数据，如：顶点坐标，法线，纹理坐标，顶点颜色等。 varying 变量 varying 变量是 vertex 和 fragment shader 之间做数据传递用的。一般 vertex shader 修改 varying 变量的值，然后 fragment shader 使用该 varying 变量的值（不能修改）。因此 varying 变量在vertex 和 fragment shader 二者之间的声明必须是一致的。 11. 简述 framebuffer 的概念，以及在渲染的时候的作用 在 OpenGL 以及大部分的渲染管线中，帧缓存（Frame buffer）是在实际渲染之前的最后一个步骤。帧缓存本质上是一块内存或者硬件中的空间，负责保存需要渲染图像的像素相关信息。 帧缓存是一个集合概念，因为帧缓存的内部包括（但不局限于）： 颜色缓存 Color buffer：记录像素颜色信息，很多帖子也将颜色缓冲当作帧缓冲的主体。 深度缓存 Z buffer：记录像素深度值。 模块缓存 Stencil buffer：限制渲染区域，可以和深度缓存一起创造不同的渲染效果 。 帧缓存的存在是为了在渲染到屏幕或者说传到窗口缓冲区之前能对图像进行后期处理 （Post-processing）（反相，灰度，核效果）等其他操作。帧缓存也实现了离屏渲染。 12. bresenham算法 123456789101112131415161718dx = x2 - x1dy = y2 - y1m = dy/dxxi = x1yi = y1pi = 2dy - dxwhile xi != x2 + 1 if Pi &lt; 0 pi = pi + 2dy yi = yi else pi = pi + 2dy - 2dx yi = yi + 1#将下一个像素(x,y)涂色 plot(xi, yi) xi = xi + 1 13. 画图描述圆对称性坐标计算 运用对称性之后，整个圆的产生只需要计算 14. 描述扫描线多边形填充算法流程 扫描线从下向上遍历，即y从小向大的方向遍历 每条扫描线与多边形边之间完成下列四个任务 （1）求交：计算扫描线与多边形各边的交点； （2）排序：把所有交点按x值递增顺序排序； （3）配对：第一个与第二个，第三个与第四个等等；每对交点代表扫描线与多边形的一个相交区间; （4）填色：把相交区间内的象素置成多边形颜色; 15. 利用多边形顶点，创建有序边表，能够描述动态更新的活化边表 把与当前扫描线相交的边称为活化边，并把它们按与扫描线交点x坐标递增的顺序存放在一个链表中,形成活化边表。 活化边表的操作包括插入边、删除边，更新边信息。 活性边表的结点中至少应为对应边保存如下内容： 第 1 项存当前扫描线与边的交点坐标 值； 第 2 项存从当前扫描线到下一条扫描线间 的增量 第 3 项存该边所交的最高扫描线号 ； 第 4 项存指向下一条边的指针（Λ代表一条边的退出，即结束或抛弃） img 扫描线6的活性边表 ： img 扫描线7的活性边表： img 为了方便活性边表的建立与更新，我们为每一条扫描线建立一个新边表（NET）,存放在该扫描线第一次出现的边。也就是说，若某边的较低端点为 ymin，则该边就放在扫描线 ymin 的新边表中。 img 16. 分别用奇偶规则和非零环绕规则判断下列内外区域 奇偶规则 •从任意位置P作不经过顶点的射线 •计算射线穿过的多边形边的数目 •奇数为内部点，否则为外部点 非零环绕规则 •环绕数初始为零 •从位置P作不经过顶点的射线 •多边形边从右至左穿过射线，加1 •多边形边从左至右穿过射线，减1 •非零为内部点；否则为外部点 17. 构造大矩阵实现观察变换 视点从（0,0,0）up(0,1,0)方向z轴负方向，到y轴上一点（0,5,0）向（0,0,0）up（0，0，1）观察变换。 沿平面 对称后，再向 正方向平移 单位（错误，因为左右手坐标系变换了） 应该是 18. 在二维平面上，构造大矩阵实现，绕 轴旋转 45 度角的旋转矩阵 ？ 19. 描述观察变换的坐标变换关系 (Rx, Ry, Rz)表示摄像机的X轴方向向量，(Ux, Uy, Uz)表示摄像机坐标系的Y轴方向，(Dx, Dy, Dz)表示摄像机的视线方向及Z轴。 (Px, Py, Pz)表示摄像机位置的世界坐标。 image-20210526213813353 20. 求视口映射点坐标 已知 ,窗口中一点 ，，求视口中的映射点P' 21. 用 CS 算法对线段进行剪裁 计算直线端点区域编码： c1 和 c2; 判断 c1 和 c2 均为 0000，保留直线 c1 &amp; c2 不为零，同在某一边界外，删除该直线 c1 &amp; c2 为零，需要进一步求解交点 以左、右、下、上为序，找出端点区域码中第一位为1的位，将窗口边界方程 或 或 或 代入直线方程，计算直线与窗口边界的交点，将交点和另一端点形成新的直线，重复上述过程，直至线段保留或删除 已知线段的两个端点 ，，窗口边界 22. 用 LB 算法实现线段剪裁 如果直线在窗口内, 则 计算 判断是否存在 , 如果存在, 进一步判断 ，表示直线平行于窗口某边界 if ，直线完全在窗口外，被剪裁 else 直线在边界内 对 的情形, 用 计算交点所对应的U值 对每条线计算参数 如果 , 则直线在窗口外，否则计算交点坐标 23. 平行投影，透视投影概念 所有投影线都平行的投影叫平行投影。若投影线正交于投影平面，称为正投影。 假如站在一个无限大的窗户后面，用一只眼睛望向外面。可以从每个点到眼睛画一条线，且对于每个看到的点相应的线会穿过窗户。视点（眼睛）称为投影中心 ，窗户所在的平面称为投影平面（图像平面），点 的投影 是过点 和 的连线与平面 的交点，得投影公式 因此 24. 投影的三要素 形体、投影方向或者投射中心以及投影面 25. 主灭点，一点透视，两点透视，三点透视 灭点:将物体的边无限延长时最后消失的点。 因为一点透视只有一个消失点(灭点)所以也叫:平行透视 两点透视有两个消失点(灭点),所以也叫:成角透视。 三点透视在竖直线上有一个灭点 26. 观察体调整 调整目的 投影不是绘制流水线最后一步操作，对于基于光栅化的绘制流水线，所采用的算法应该是以特定视见体位参数，所以一个更简洁高效的选择是在投影和流水线其余部分之间建立一个公共接口。事实上投影总是要求将对应的视见体转换为规范视见体。为 到 的立方体 调整的意义 计算、处理方便快捷 如何调整 Z轴错切+缩放变换，缩放系数随着z的不同而变化 27. 多边形网格模型表示中，基本数据表形式，顶点表，边表，面表 三维对象的表示方法可以分为面表示和体表示 面表示 表示三维对象的表面，包括多边形网格、隐式曲面和参数曲面 体表示 表示三维对象的体积。常用的体数据表示方法包括体素和构造实体几何 顶点表 序号 点坐标 1 x1,y1,z1 2 x2,y2,z2 3 x3,y3,z3 4 x4,y4,z4 5 x5,y5,z5 边表 序号 顶点号 1 v1,v2 2 v2,v3 3 v3,v1 4 v3,v4 5 v4,v5 6 v5,v1 面表 序号 边序号 1 E1,E2,E3 2 E3,E4,E5,E6 28. 用函数描述的二次曲面模型，如球体表面，如何进行绘制 一旦给定函数，图形包将指定曲线方程投影到显示平面上，且沿着投影函数路径绘制像素位置。 对曲面而言，函数式描述通常嵌入到生成曲面的多边形网格逼近中。 通常使用三角形的多边形曲面片可以确保任一多边形的顶点在一个平面上。有四个或四个以上顶点的多边形其顶点可能会不在一个平面上。 由函数式描述而生成的显示曲面的例子有二次曲面和超二次曲面 29. 样条曲线，样条曲面 样条 通过一组指定点集而生成平滑曲线的柔性带。 样条曲线在计算机图形学中的含义 由多项式曲线段连接而成的曲线 在每段的边界处满足特定的连续性条件 样条曲面 使用两组正交样条曲线进行描述 样条在图形学中的应用 设计曲线、曲面 30. 样条曲线的两种类型 插值样条曲线：选取的多项式使得曲线通过每个控制点 逼近样条曲线：选取的多项式不一定使曲线通过每个控制点 31. 凸壳的概念 凸壳 包含一组控制点的凸多边形边界 凸壳的作用 提供了曲线或曲面与包围控制点的区域之间的偏差的测量 以凸壳为界的样条保证了多项式沿控制点的平滑前进 32. 分段连续中连续的定义 参数连续性条件 两个相邻曲线段在相交处的参数导数相等 零阶连续(C0连续)：简单地表示曲线连接 一阶连续(C1连续)：说明代表两个相邻曲线的方程在相交点处有相同的一阶导数（切线） 二阶连续(C2连续)：两个曲线段在交点处有相同的一阶和二阶导数，交点处的切向量变化率相等 几何连续性条件 两个相邻曲线段在相交处的参数导数成比例 零阶连续（G0连续）：与0阶参数连续性相同，即两个曲线必在公共点处有相同的坐标 一阶连续（G1连续）：表示一阶导数在两个相邻曲线的交点处成比例 二阶连续（G2连续）：表示两个曲线段在相交处的一阶和二阶导数均成比例 33. 简述 Bezier 的几个特点 Bezier 多项式次数＝控制点个数-1 Bezier 曲线总是通过第一个和最后一个控制点 Bezier 曲线在第一个控制点 处与直线 相切，在最后一个控制点 处与直线 相切。 Bezier曲线总是落在控制点的凸壳内 保证了曲线沿控制点的平稳前进 34. 漫反射特性，镜面反射特性 漫反射 理想漫反射表面在各个方向以相同强度反射光线，亦称为 Lambert 表面（Lambertian surface）。类似于投影幕布 光的反射量与入射光强度以及夹角有关 考虑到余弦为负的情况，常用 镜面反射 对一般非理想镜面的光滑表面，反射光集中在一个方向范围内，并且反射定律决定的反射方向光强最大。 物体表面越光滑，镜面反射光就越集中于以反射定律决定的反射方向为中心的更小的一个角度范围内，超出这个范围镜面反射光将迅速衰减。 环境光 环境光与光源的方向、位置没有关系； 环境光没有位置或方向上的特征，只有一个颜色亮度值，强度不会衰减。 35. 解释渲染方程 其中 表示 到 的光照强度 表示光照衰减因子，当 互相被遮挡则为 ，否则等于 ， 是两点间距离 是 发射到 的光强 是 发射的光经过 发射之后达到 的光强系数 是场景中所有点的集合 36. Phong 光照模型 漫反射 镜面反射 37. Gouraud 明暗处理 计算顶点法向量， Phong 光照明模型计算顶点的光强 光强插值 38. threejs 的浏览器中的调试，文件路径概念 12const axesHelper = new AxesHelper( 700 ); //创建AxesHelper，700是三条线的长度this.scene.add( axesHelper ); //将AxesHelper加入到场景中 folder/data 当前文件夹的 folder 子目录下的 data 文件 ../folder/data 上层文件夹下的folder 子目录下的 data 文件 /folder/data 根目录下 folder 文件夹下的 data 文件 39. VBO,PBO,FBO 的概念 VBO（Vertex Buffer Object）是指顶点缓冲区对象 VBO 作用是在显存中提前开辟好一块内存，用于缓存顶点数据或者图元索引数据，从而避免每次绘制时的 CPU 与 GPU 之间的内存拷贝，可以改进渲染性能，降低内存带宽和功耗。 FBO（Frame Buffer Object）即帧缓冲区对象，实际上是一个可添加缓冲区的容器，可以为其添加纹理或渲染缓冲区对象（RBO）。 FBO 本身不能用于渲染，只有添加了纹理或者渲染缓冲区之后才能作为渲染目标，它仅且提供了 3 个附着（Attachment），分别是颜色附着、深度附着和模板附着。 PBO （Pixel Buffer Object）是 OpenGL ES 3.0 的概念，称为像素缓冲区对象，主要被用于异步像素传输操作。PBO 仅用于执行像素传输，不连接到纹理，且与 FBO （帧缓冲区对象）无关。 PBO 类似于 VBO（顶点缓冲区对象），PBO 开辟的也是 GPU 缓存，而存储的是图像数据。 40. 创建一个 vbo，并基于 vbo 进行绘制 顶点缓冲对象是我们在 OpenGL 教程中第一个出现的 OpenGL 对象。就像 OpenGL 中的其它对象一样，这个缓冲有一个独一无二的ID，所以我们可以使用 glGenBuffers 函数和一个缓冲 ID 生成一个 VBO 对象： 12unsigned int VBO;glGenBuffers(1, &amp;VBO); OpenGL 有很多缓冲对象类型，顶点缓冲对象的缓冲类型是 GL_ARRAY_BUFFER。OpenGL 允许我们同时绑定多个缓冲，只要它们是不同的缓冲类型。我们可以使用 glBindBuffer 函数把新创建的缓冲绑定到GL_ARRAY_BUFFER 目标上： 1glBindBuffer(GL_ARRAY_BUFFER, VBO); 从这一刻起，我们使用的任何（在 GL_ARRAY_BUFFER 目标上的）缓冲调用都会用来配置当前绑定的缓冲（VBO）。然后我们可以调用 glBufferData 函数，它会把之前定义的顶点数据复制到缓冲的内存中： 1glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); glBufferData 是一个专门用来把用户定义的数据复制到当前绑定缓冲的函数。它的第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到 GL_ARRAY_BUFFER 目标上。第二个参数指定传输数据的大小(以字节为单位)；用一个简单的sizeof计算出顶点数据大小就行。第三个参数是我们希望发送的实际数据。 第四个参数指定了我们希望显卡如何管理给定的数据。它有三种形式： GL_STATIC_DRAW ：数据不会或几乎不会改变。 GL_DYNAMIC_DRAW：数据会被改变很多。 GL_STREAM_DRAW ：数据每次绘制时都会改变。 使用 glVertexAttribPointer 函数告诉 OpenGL 该如何解析顶点数据（应用到逐个顶点属性上）了： 12glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0); glVertexAttribPointer函数的参数非常多，所以我会逐一介绍它们： 第一个参数指定我们要配置的顶点属性。还记得我们在顶点着色器中使用 layout(location=0) 定义了 position 顶点属性的位置值（Location）吗？它可以把顶点属性的位置值设置为0。因为我们希望把数据传递到这一个顶点属性中，所以这里我们传入 0。 第二个参数指定顶点属性的大小。顶点属性是一个 vec3，它由 3 个值组成，所以大小是 3。 第三个参数指定数据的类型，这里是 GL_FLOAT （GLSL 中 vec* 都是由浮点数值组成的）。 下个参数定义我们是否希望数据被标准化（Normalize）。如果我们设置为 GL_TRUE，所有数据都会被映射到 0（对于有符号型signed数据是 -1 到 1 之间）。我们把它设置为 GL_FALSE。 第五个参数叫做步长（Stride），它告诉我们在连续的顶点属性组之间的间隔。由于下个组位置数据在 3 个 float 之后，我们把步长设置为 3 * sizeof(float)。要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以设置为 0 来让 OpenGL 决定具体步长是多少（只有当数值是紧密排列时才可用）。一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔，我们在后面会看到更多的例子。 最后一个参数的类型是 void*，所以需要我们进行这个奇怪的强制类型转换。它表示位置数据在缓冲中起始位置的偏移量（Offset）。由于位置数据在数组的开头，所以这里是0。 每个顶点属性从一个 VBO 管理的内存中获得它的数据，而具体是从哪个 VBO（程序中可以有多个 VBO）获取则是通过在调用 glVertexAttribPointer 时绑定到 GL_ARRAY_BUFFER 的 VBO 决定的。由于在调用glVertexAttribPointer 之前绑定的是先前定义的 VBO 对象，顶点属性 0 现在会链接到它的顶点数据。 现在我们已经定义了 OpenGL 该如何解释顶点数据，我们现在应该使用 glEnableVertexAttribArray，以顶点属性位置值作为参数，启用顶点属性；顶点属性默认是禁用的。自此，所有东西都已经设置好了：我们使用一个顶点缓冲对象将顶点数据初始化至缓冲中，建立了一个顶点和一个片段着色器，并告诉了OpenGL如何把顶点数据链接到顶点着色器的顶点属性上。在OpenGL中绘制一个物体，代码会像是这样： 12345678910// 0. 复制顶点数组到缓冲中供OpenGL使用glBindBuffer(GL_ARRAY_BUFFER, VBO);glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);// 1. 设置顶点属性指针glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);glEnableVertexAttribArray(0);// 2. 当我们渲染一个物体时要使用着色器程序glUseProgram(shaderProgram);// 3. 绘制物体someOpenGLFunctionThatDrawsOurTriangle(); 41. 深度缓存的意义，基于深度检测的方法 在不使用深度测试的时候，如果我们先绘制一个距离较近的物体，再绘制距离较远的物体，则距离远的物体因为后绘制，会把距离近的物体覆盖掉，这样的效果并不是我们所希望的。而有了深度缓冲以后，绘制物体的顺序就不那么重要了，都能按照远近（Z值）正常显示，这很关键。 实际上，只要存在深度缓冲区，无论是否启用深度测试，在像素被绘制时都会尝试将深度数据写入到缓冲区内。这些深度数据除了用于常规的测试外，还可以有一些有趣的用途，比如绘制阴影等等。 42. 描述固定管线中的光照模型 顶点处理主要进行顶点齐次坐标变换和光照（固定管线功能只有逐顶点光照）。 若光照被关闭，顶点的颜色将直接设置成当前颜色（ glColor() 指定），若打开，顶点将根据当前材料颜色（glMatiral()，可分正面背面分别设置）和法向量（glNormal()）来计算环境、散射、高光、发射光的颜色，并叠加。光照分正背面进行（由 glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TURE[FALSE]) 控制），也即顶点处理完成后每个顶点将有两个颜色属性值（见顶点着色器内置输出变量，gl_FrontColor/BackColor），正面颜色的计算依据正面材料及法向量 ，背面颜色计算依据背面材料及法向量的反方向 ，若双面光照关闭，则只计算正面颜色并简单将背面颜色设为和正面相同（关于单面光照最容易被误解的就是，单面光照是简单的将背面颜色设为和正面相同从而不去独立计算，而不是只照亮正面）。顶点的颜色将在随后光栅化的时候被插值到片断，光栅化时根据图元顶点环绕方向（逆时针或顺时针）确定正背面，并据此选择用顶点的正面颜色值还是背面颜色值来插值。根据 glShadeMode(GL_SMOOTH[FLAT]) 的设置，同一个图元的顶点的颜色值将被单独处理，或全都被赋值为其中一个顶点（ProvokingVertex）的值。固定管线的逐顶点光照类似于 Gouraud 模型，这区别于逐片断光照（如 Phong，对片断先由其图元顶点法向量插值出片断法向量，再根据这个法向量计算光照，可由片断着色器实现）。 二、实验题 1. threejs 的程序主框架（初始化和主循环） 1234567891011121314151617181920const scene = new THREE.Scene();const camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 100)const renderer = new THREE.WebGLRenderer();renderer.setSize(window.innerWidth, window.innerHeight)document.body.appendChild( renderer.domElement);const geometry = new THREE.BoxGeometry(1, 1, 1)const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 } );const cube = new THREE.Mesh( geometry, material);scene.add(cube);camera.position.z = 5;function animate(){ requestAnimationFrame(animate); renderer.render( scene, camera); cube.rotation.x+=0.01; cube.rotation.y+=0.01;}animate(); 2. 利用 threejs 实现某个场景的绘制，写出设计和具体代码 同上 3. 利用 threejs 实现对象的运动控制的设计，如太阳系运动，以及汽车与轮子运动等。 每个 animate 帧里更新就行 4. 利用 threejs 实现天空盒的搭建 12345678scene.background = new THREE.CubeTextureLoader().load([ \"/test/Left.png\", \"/test/Right.png\", \"/test/Up.png\", \"/test/Down.png\", \"/test/Front.png\", \"/test/Back.png\", ]); 5. 利用 threejs 设计实现一个简单游戏：用鼠标控制旋转方向，键盘控制向前向后移动，空格键发射子弹，射线检测碰撞结果 123456789101112131415import { FirstPersonControls } from 'three/addons/controls/FirstPersonControls.js';function init(){ ... controls = new FirstPersonControls( camera, renderer.domElement ); controls.movementSpeed = 150; controls.lookSpeed = 0.1;}function animate(){ requestAnimationFrame( animate ); //controls.update() must be called after any manual changes to the camera's transform controls.update( clock.getDelta() ); renderer.render( scene, camera );} 6. 利用 threejs 设计实现一个函数曲线的绘制 123456789101112131415161718192021222324252627282930313233const scene = new THREE.Scene();const camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 1, 500)const renderer = new THREE.WebGLRenderer();renderer.setSize(window.innerWidth, window.innerHeight)renderer.setClearColor(0xffffff);document.body.appendChild( renderer.domElement);function f(x){ return Math.sin(x)+Math.log(Math.abs(x));}const points = [] for(let x=-100;x&lt;=100;x+=0.01){ points.push(new THREE.Vector3(x, f(x), 0));}const geometry = new THREE.BufferGeometry().setFromPoints(points)const material = new THREE.LineBasicMaterial({ color: 0x000000 } );const line = new THREE.Line(geometry, material);const axesHelper = new THREE.AxesHelper( 100 ); scene.add( axesHelper );scene.add(line);camera.position.z = 10;camera.lookAt(0,0,0);function animate(){ requestAnimationFrame(animate); renderer.render( scene, camera);}animate(); 7. 利用 threejs 设计实现一个曲面的绘制 1234567891011var qwq = function(u,v){ var x=u*50; var y=v*50; var z=(u*u+Math.sin(v))*50; return new THREE.Vector3(x,y,z); var r = 50;};const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 , side:THREE.DoubleSide} );var mesh = new THREE.Mesh(new THREE.ParametricGeometry(qwq, 12, 12), material);scene.add(mesh); 另附一个网上抄的克莱因瓶 https://blog.51cto.com/u_15948039/6027103 123456789101112131415161718192021222324252627282930313233343536373839var klein = function (u, v) { u *= Math.PI; v *= 2 * Math.PI; u = u * 2; var x, y, z; if (u &lt; Math.PI) { x = 3 * Math.cos(u) * (1 + Math.sin(u)) + (2 * (1 - Math.cos(u) / 2)) * Math.cos(u) * Math.cos(v); z = -8 * Math.sin(u) - 2 * (1 - Math.cos(u) / 2) * Math.sin(u) * Math.cos(v); } else { x = 3 * Math.cos(u) * (1 + Math.sin(u)) + (2 * (1 - Math.cos(u) / 2)) * Math.cos(v + Math.PI); z = -8 * Math.sin(u); } y = -2 * (1 - Math.cos(u) / 2) * Math.sin(v); return new THREE.Vector3(x, y, z);};function createMesh(geom) { //设置当前的模型矩阵沿xy轴偏移，让图片处于显示中心 geom.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, 0)); // 创建法向量纹理 var meshMaterial = new THREE.MeshNormalMaterial({ flatShading: THREE.FlatShading, transparent: true, opacity: 0.9 }); // 创建一个线框纹理 var wireFrameMat = new THREE.MeshBasicMaterial(); wireFrameMat.wireframe = true; // 创建模型 var mesh = THREE.SceneUtils.createMultiMaterialObject(geom, [meshMaterial,wireFrameMat]); return mesh;} 8. 利用 threejs 设计实现一个模型文件的加载和场景绘制 模型加载注意浏览器的 same origin policy 12345678import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';const loader = new GLTFLoader();loader.load( 'path/to/model.glb', function ( gltf ) { scene.add( gltf.scene );}, undefined, function ( error ) { console.error( error );} ); 9. 利用 threejs 实现三维文字信息tip注释的功能。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function makeTextSprite( message, parameters ){ if ( parameters === undefined ) parameters = {}; var fontface = parameters.hasOwnProperty(\"fontface\") ? parameters[\"fontface\"] : \"Arial\"; fontface=\"Consolas\"; var title = parameters.hasOwnProperty(\"title\") ? parameters[\"title\"] : config[\"default_msg\"]; var fontsize = parameters.hasOwnProperty(\"fontsize\") ? parameters[\"fontsize\"] : 24; var borderThickness = parameters.hasOwnProperty(\"borderThickness\") ? parameters[\"borderThickness\"] : 4; var borderColor = parameters.hasOwnProperty(\"borderColor\") ? parameters[\"borderColor\"] : { r:0, g:0, b:0, a:1.0 }; var backgroundColor = parameters.hasOwnProperty(\"backgroundColor\") ? parameters[\"backgroundColor\"] : { r:255, g:255, b:255, a:1.0 }; var lineHeight = parameters.hasOwnProperty(\"lineHeight\") ? parameters[\"lineHeight\"] : 25; const canvas = document.getElementById('msg'); var context = canvas.getContext('2d'); canvas.width = 450; // get size data (height depends only on font size) context.font = fontsize + \"px \" + fontface; var metrics = context.measureText( message ); var textWidth = metrics.width; // background color context.fillStyle = \"rgba(\" + backgroundColor.r + \",\" + backgroundColor.g + \",\" + backgroundColor.b + \",\" + backgroundColor.a + \")\"; context.lineWidth = borderThickness; // text color context.fillStyle = \"rgba(0, 0, 0, 1.0)\"; lines = Math.ceil(textWidth / canvas.width); canvas.height = (2+lines)*(lineHeight+2); context.font = \"Bold \" + fontsize + \"px \" + fontface; context.fillText( title, borderThickness, borderThickness+lineHeight); context.font = fontsize + \"px \" + fontface; context.wrapText( message, borderThickness, borderThickness+2*lineHeight, canvas.width-2*borderThickness, lineHeight); // canvas contents will be used for a texture var texture = new THREE.Texture(canvas) texture.needsUpdate = true; var spriteMaterial = new THREE.SpriteMaterial( { map: texture} ); var sprite = new THREE.Sprite( spriteMaterial ); sprite.scale.set(100,100*canvas.height/canvas.width,1); return sprite; } 10. 利用 threejs 的 raycaster.setFromCamera(pointer, camera) 实现鼠标选中三维物体进行交互 123456789101112131415161718function click(event){ pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1; pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1; // update the picking ray with the camera and pointer position raycaster.setFromCamera( pointer, camera ); // calculate objects intersecting the picking ray var intersects = raycaster.intersectObjects(scene.children); if(intersects.length &gt; 0){ for(let i=0; i &lt; interactPoint.length; i++){ for(let j=0;j &lt; intersects.length; j++) if(intersects[j].object == interactPoint[i]){ console.log(\"Geting information of \" + i ); } } }}","categories":[{"name":"总结","slug":"总结","permalink":"https://20021123.xyz/categories/%E6%80%BB%E7%BB%93/"},{"name":"图形学","slug":"图形学","permalink":"https://20021123.xyz/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"},{"name":"图形学","slug":"图形学","permalink":"https://20021123.xyz/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"}]},{"title":"计算机中信息的表示","slug":"计算机中信息的表示","date":"2023-02-25T04:31:53.000Z","updated":"2023-02-25T04:45:06.000Z","comments":true,"path":"2023/02/25/计算机中信息的表示/","link":"","permalink":"https://20021123.xyz/2023/02/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA/","excerpt":"","text":"一、数值型数据的表示方法 一个数值型数据的完整表示需三个方面： 进位计数制 符号的数字化（机器数） 小数点的处理 1.1 进位计数制 两个基本要素： 权（与所在数位相关的常数） 基数 每个数位中所允许的最大数码值+1或每个数位中所允许的数码个数 权与基数的关系 相邻两位的权值之比等于基数值 各种进位计数制的表示 二进制 权是 ，基数是 八进制 权是 ，基数是 十进制 权是 ，基数是 十六进制 权是 ，基数是 各种进位计数制的相互表示 （binary-octal-decimal-hexadecimal） 1.1.1 十进制计数 基数为十：0~9 位权为 如果有 位整数， 位小数，则 1.1.2 二进制计数 基数为二：0~1 位权为 如果有 位整数， 位小数，则 1.1.3~4 八进制/十六进制 同理 1.1.5 二进制数的特点 二进制数只有 两个数码，可以用晶体管的通断或脉冲的有无表示一位二进制数 二进制数的运算规则简单，其特点是逢二进一，借一当二 1.2 数制转换 1.2.1 二进制与十进制间的转换 十进制数转换为二进制数 整数部分：除以2取余数直到商为 小数部分：乘以2取整数直到小数为 二进制数转换为十进制数 按权位展开求和 1.2.2 八进制、十六进制与二进制数的转换 二进制数转换为八进制数 从小数点起每三位一组，整数部分不够三位时在前面添 ，小数部分不够三位时在后面添 。 二进制数转换为十六进制数 从小数点起四位一组，整数部分不够四位的在前面添 ，小数部分不够四位的在后面添 。 八进制数和十六进制数转换为二进制数 八进制数转换为二进制数：每 位八进制数字写成 位二进制数字即可。 十六进制数转换为二进制数：每 位十六进制数字写成 位二进制数字即可。 1.2.3 十进制数与八进制数、十六进制数间的转换 1.3 带符号数的代码表示 真值：用正负符号加绝对值表示数值 机器数、分类及组成 机器数的定义：在计算机内部使用的，连同数符一起数码化了的数 分类：源码、补码、反码 组成：符号位部分+有效数值部分 1.3.1 真值与机器数 一个带符号的数由两部分组成，一部分表示数的符号，另一部分表示数的数值。符号位习惯以 表示正数，以 表示负数 若以正号“+”和负号“-”来表示有符号的二进制数，称为符号数的真值。 计算机中使用的符号数称为机器数。 如 表示为 ，而 表示为 。 1.3.2 原码 原码又称“符号－数值表示”，在以原码表示的正负数中，第一位为 (正数)；为 (负数)。如： 记为 ； 记为 。 若二进制整数的原码序列为 则 原 若二进制小数的原码序列为 则 原 原码的性质 当二进制数 为正数时，对应的原码 原 和 只是增加了一位用 表示的符号。由于在数的左边增加一位 对该数值无影响，所以 原 就是 本身。 当二进制数 为负数时，对应的原码 原 就是在原二进制数前增加一位用 表示的符号位。 在原码表示中，有两种不同形式的 。 即 原＝，原＝ 符号位不是数值的一部分，它们是人为约定的， 为正， 为负。所以符号位在运算中要单独处理，不能当作数值的一部分直接参加运算。 1.3.3 反码 反码又称“1的补码”，用反码表示时，左边的第一位也为符号位， 代表正数， 代表负数。对于负数，反码的数值是将原码数值部分按位求反，符号位 保持不变。而对于正数，反码和原码相同。 若二进制整数的反码序列为 则 反 若二进制小数的反码序列为 则 反 反码的性质 正数的反码与原码相同 负数的反码的符号位为 ，其余位按位取反 反码表示中，有两种不同形式的 即 反＝，反＝ 反码就是除符号位外，用同样字长的全 码减去该数的绝对值而得，所以反码称为 的补码 1.3.4 补码 补码又称“对2的补数”，补码表示法是：如果数为正，则正数的补码与原码表示形式相同；如果数为负，则将负数的原码除符号位外，其余各位取反后末尾再加 。 若二进制整数的补码序列为 则 补 若二进制小数的补码序列为 则 补 补码的性质 正数的补码，反码和原码相同 对于负数，补码的符号位为 ，数值部分是对原码每位求反后尾数加 补码表示中 的形式唯一 即 补＝补 根据我们对补码表示方法的描述可知： 补反︱︱︱︱ 所以补码又称为 的补码。 1.3.5 机器数的加减运算 原码计算 直接算，注意符号位不同时需比较绝对值大小 补码运算 运算规则：两数和的补码等于两数的补码之和。而两数差的补码也可以用加法实现。 补＝补补补＝补补 运算时，符号位和数值位一样参加运算。如果符号位产生进位，则将进位“丢掉”。运算结果的符号位为 时，说明是正数的补码，其与原码相同。符号位为 时，说明是负数的补码，应再对运算结果再求补码，才得到原码。 反码运算 反＝反反反＝反反 运算时，符号位参加运算，如果符号位产生了进位，则该进位应该加到和数的最低位，称之为“循环进位”。 运算结果符号位为 时，说明是正数的反码，其与原码相同；若符号位为 ，说明是负数的反码，应对结果再求反码才能得到原码。 1.4 数码和字符的代码表示 1.4.1 十进制数的二进制编码 由于人们习惯使用十进制数，而电路单元最适宜于二进制操作，于是出现了一种用二进制码编写的十进制码，即二—十进制码，或称 BCD码。 十进制数 8421码 余3码 2421码 5421码 0 0000 0011 0000 0000 1 0001 0100 0001 0001 2 0010 0101 0010 0010 3 0011 0110 0011 0011 4 0100 0111 0100 0100 5 0101 1000 1011 1000 6 0110 1001 1100 1001 7 0111 1010 1101 1010 8 1000 1011 1110 1011 9 1001 1100 1111 1100 1.4.2 可靠性编码 格雷码（循环码） 特点：任意相邻两个代码之间只有一位状态不同，这样在计数过程中就不会出现其它代码，译码时就不会产生抖动和毛刺。 将二进制转换到格雷码的方法为：保持最高位不变，其他位与前面一位异或。 奇偶校验码 在数据中加入校验位，校验位的加入如果使整个代码中的“1”的个数为奇数，称奇校验。 若使整个代码中的“1”的个数为偶数，称偶校验。 1.5 数的定点表示与浮点表示 1.5.1 定点表示法 在计算机中，小数点位置固定不变的数称为定点数。表示数的范围和分辨率固定不变 无符号定点整数：略去符号位的正整数。 带符号定点整数：是纯整数，小数点在最低位之后，最高位为符号位。 带符号定点小数：是纯小数，用原码或补码表示。 1.5.2 浮点表示法 是一种小数点位置不固定可随需要浮动的数。 浮点数格式 浮点数的代码由两部分组成：阶码 与尾数 。 浮点的真值 式中 为真值， 为比例因子， 是尾数。对于某种浮点格式， 固定不变且隐含约定，因此浮点数代码序列中只需分别给出 和 两部分（连同它们的符号）。 是阶码的底，一般选择与尾数 的基数相同， 是隐含约定的常数，不直接表示在浮点数代码之中。例如尾数为二进制，基数为 ，则选择 。 是阶码，也就是比例因子RE的指数值，为二进制正负整数，可用补码或移码表示（有关移码的概念将在后面介绍）。若阶码 为正，表明尾数M将被扩大若干倍。若 为负，表明M将被缩小若干倍。 是尾数，为带符号定点小数，可用补码或原码表示。 移码（增码） 前面提到的移码也称为增码，常用于表示浮点数的阶码中。移码定义如下： 若阶码（连同一位符号位）共 位，代码序列为 ，则 移－＜ 式中 是阶码的真值， 是符号位 的位权。因此 移 相当于将真值 沿数轴正向平移 ，所以称为移码。或者说将 增加 ，所以又取名为增码。 移码的性质 最高位为符号位，但其取值与原码、补码正好相反。 除符号位相反之外，移码的其余各位与补码相同。这是由于移码平移了 ，而补码则平移了 （模值）。 让 从 逐渐增至 ，相应地 移 从 逐渐增至 ，呈递增状。可见采用移码能更直观地比较正负阶码的大小，例如 与 之间的比较。 1.5.3 表示范围与精度 1.5.4 IEEE754标准浮点格式 类型 数符（位） 阶码（位） 尾数数值（位） 总位数（位） 偏置值（十六进制） 偏置值（十进制） 短浮点数 1 8 23 32 7FH 127 长浮点数 1 11 52 64 3FFH 1023 临时浮点数 1 15 64 80 3FFFH 16383 短浮点数又称为单精度浮点数，长浮点数又称为双精度浮点数，它们都采用隐含尾数最高数位（）的方法，这样，无形中又增加了一位尾数，因此，相应地尾数真值实际上等于1+（23位尾数数值或52位尾数数值）。 临时浮点数又称为扩展精度浮点数，它没有隐含位，尾数真值就等于64位尾数数值。 单精度浮点数计算公式 S: 符号位（1为负，0为正） M: 尾数，表示小数 E: 阶码 双精度浮点数计算公式 特殊定义 阶码 全零且 也全零时 阶码 全零但 并非全零时，阶码 解析为 ， 解析为实际值（即不加1） 阶码 全 且 全零时， 阶码 全 且 并非全灵时， 二、字符的表示方法 2.1 ASCII 码 国际上广泛采用美国信息交换标准码（American Standard Code For Information Interchange）作为标准，简称为ASCII码。 在ASCII字符集中共有128种常用字符，每个ASCII字符自身有七位编码，存储器中的一个字节单元正好可以存放一个ASCII字符编码与一位奇偶校验位。这样，存储器也就常以字节为一个存储单元的编址单元。 2.2 汉字编码简介 汉字也是字符，是中文的基本组成单位。由于汉字数量极大，接近7万个，字形复杂、异体字多、同音字多，因此，汉字信息的处理比西文复杂得多。汉字信息的处理一般包括汉字的编码、输入、输出、存储、处理与传输。 2.2.1 汉字输入码 每个汉字用一个或几个键输入的编码来表示。这种编码方式称为汉字的输入编码，也称外码。 目前汉字的编码方案有几百种之多，较常使用的也有几十种之多。归纳起来，所采用的方法可分为数字码、拼音码、字形码、音形结合、以及具有某些提示和联想功能的编码等几类。 2.2.2 汉字内部码 汉字内部码也称机内码，它是计算机内部供存储、处理、传输用的代码，简称内码，是汉字在设备或信息处理系统内部最基本的表达。目前国内采用的内部码有四十种左右。 2.2.3 汉字交换码 如前所述，早期的各种汉字系统的内码不统一，因此在各汉字系统之间或汉字系统与通信系统之间进行汉字信息交换（即传输）时，需要制定一种编码标准，即汉字交换码。 我国制定了《信息处理交换用的七位编码字符集》，后来成为国家标准GB1988。除个别字符（如货币符号）外，GB1988与ASCII是一致的，可视为ASCII的中国版本。","categories":[{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"https://20021123.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"},{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"https://20021123.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}]},{"title":"计算机体系结构","slug":"计算机体系结构","date":"2023-02-25T04:30:08.000Z","updated":"2023-02-25T09:01:58.000Z","comments":true,"path":"2023/02/25/计算机体系结构/","link":"","permalink":"https://20021123.xyz/2023/02/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"","text":"第一章 概论 一、基本概念 1. 冯.诺依曼体制？存储程序方式？ 信息用二进制表示。 程序存储的思想。把运算程序存在计算机的存储器中，程序设计员只需在存储器中寻找运算指令，计算机就能自动计算，不必对每个问题重新编程 计算机由五大部分组成：运算器、控制器、存储器、输入设备和输出设备 2. 控制流？数据流？ 控制流驱动如典型的冯诺依曼结构的CPU，从程序存储器中拿到操作指令后，再去数据存储器中取操作数进行计算； 数据流驱动如各种线速处理的网络设备，典型的如FPGA写的一个线卡或者转发、交换处理逻辑，数据流水进来再出去，逻辑处理随路并行完成。 3. 模拟信号？数字信号？数字信号有哪两种？ 模拟信号是指用连续变化的物理量所表达的信息，如温度、湿度、压力、长度、电流、电压等等，我们通常又把模拟信号称为连续信号，它在一定的时间范围内可以有无限多个不同的取值。 数字信号是指在取值上是离散的、不连续的信号。通过信号的两种不同状态表示数字信息（1 和 0） 4. 总线及其组成？ 总线是一组能为多个部件分时共享的信息传输线。用一组系统总线将 CPU，存储器和 I/O 设备连接起来，各部件通过这组总线交换信息 根据系统总线上传送的信息类型，系统总线可分为地址总线、数据总线和控制总线。 地址总线用来传输 CPU 或外设发向主存的地址码 数据总线用来传输 CPU、主存以及外设之间需要交换的数据 控制主线用来传输控制信号，如时钟信号、CPU 发向主存或外设的读/写命令和外设送往 CPU 的请求信号 5. 接口的概念？ 计算机系统连接的各种外部设备并不是标准的，在种类和数量上都是可变的。因此，为了将标准的系统总线与各具特色的 I/O 设备连接起来，需要在系统总线与 I/O 设备之间设置一些接口部件，它们具有缓冲、转换、连接等功能，这些部件经常被统称为 I/O 接口 6. 基本字长？ 基本字长一般是指处理器中参加一次定点计算的操作数的位数，如 8 位、16位、32 位或 64位。基本字长影响计算的精度、硬件的成本，甚至对指令系统功能也有影响 一次运算过程中，操作数和运算结果通过数据总线，在寄存器和运算部件之间传输。因此基本字长标志着计算精度，也反映了寄存器、运算部件和数据总线的位数。基本字长越长，操作数的位数越多，计算精度也越高；但相应部件的位数也会增多，使硬件成本随之增加 7. CPU主频？时钟频率？ 外频也叫外部频率或基频，也是也称为系统时钟频率，是指主板上的振荡器输出的时钟频率，也是计算机中一切硬件部件工作所依据的基准时钟信号，它经过倍频系数放大后用作计算机中各部件的工作频率，如 CPU、内存和各类总线等 CPU 的主频（）是指 CPU 内核的工作频率，有时也叫 CPU 的时钟频率（）。CPU 主频=外频x倍频系数，提高两者任意一项都可以提升 CPU 主频 CPU 主频的高低是决定计算机工作速度的重要因素，但两者之间没有正比关系。在 CPU 时钟频率中，相邻两个时钟脉冲之间的间隔即一个时钟周期，它对应 CPU 完成一步微操作。 CPU 执行程序时，每条指令所需的平均时钟周期数（CPI）也用来衡量 CPU 的综合性能 8. 数据通路宽度？数据传输率？ 数据通路宽度是指数据总线一次能并行传输的数据位数，它会直接影响计算机的性能。 CPU 内部数据通路宽度一般与 CPU 的基本字长相同，也等于 CPU 内总线的宽度，CPU 的外部数据通路宽度则等于系统数据总线的位宽 数据传输率也称比特率，是指单位时间内信道的数据传输量，单位是 bps。数据传输率与传输信道的数据通路宽度和最大工作频率有关，通常的简化计算规则为 其中 DTR 表示数据传输率， 是数据的传输量， 是相应的数据传输时间， 是数据通路的宽度， 是工作频率 第二章 计算机中的信息表示 一、基本概念 1. 一个数值型数据的完整表示需三个方面？ 采用什么进位计数制，即逢几进位 如何表示一个带符号的数，即如何使符号数字化，设计机器数的编码方法如原码和补码 小数点如何处理，即定点法和浮点法 2. 权、基数？ 基数 是进位制中会产生进位的数值，等于每个数位最大数码值（）加 1，也就是数位中允许选用的数码个数 在进位制中每个数位都有自己的权值，它是一个与所在数位相关的常量，称为该位的位权，简称为权。 3. 真值？机器数的定义？分类？ 一个带符号的数由两部分组成，一部分表示数的符号，另一部分表示数的数值。符号位习惯以 表示正数，以 表示负数 若以正号“+”和负号“-”来表示有符号的二进制数，称为符号数的真值。 计算机中使用的连同数符一起数字化的数称为机器数。 包括原码、补码、反码、移码 如 表示为 ，而 表示为 。 4. 数的定点表示与浮点表示？ 在计算机中，小数点位置固定不变的数称为定点数 无符号定点整数，带符号定点整数类似普通整数 带符号定点小数是纯小数，若代码序列为 ，最高位 是符号位，小数点位置在符号位之后。在原码中 是数值的有效部分，常称为尾数，并将 称为最高数位或最高有效位 典型值 真值 代码序列 原码绝对值最大负数 原码绝对值最小负数 原码最小非零正数 原码最大正数 补码绝对值最大负数 补码绝对值最小负数 补码最小非零正数 补码最大正数 浮点数是一种小数点位置不固定可随需要浮动的数 式中 为真值， 为比例因子， 是尾数。对于某种浮点格式， 固定不变且隐含约定，因此浮点数代码序列中只需分别给出 和 两部分（连同它们的符号）。 是阶码的底，一般选择与尾数 的基数相同， 是隐含约定的常数，不直接表示在浮点数代码之中。例如尾数为二进制，基数为 ，则选择 。 是阶码，也就是比例因子RE的指数值，为二进制正负整数，可用补码或移码表示（有关移码的概念将在后面介绍）。若阶码 为正，表明尾数M将被扩大若干倍。若 为负，表明M将被缩小若干倍。 是尾数，为带符号定点小数，可用补码或原码表示。 5. 指令？指令系统？ 从程序的编制和执行角度，用高级语言编制的程序经过编译，转换为可由硬件直接识别并执行的程序形态，即二进制的指令序列。每条指令能控制计算机实现一种操作，因此指令中应规定操作的类型及操作数地址，它们是产生控制信息的基础。 从硬件角度，在设计计算机时，首先要确定其硬件能直接执行哪些操作，既然每种操作对应一条指令，那么这些操作集合在一起就可以被看做是一个指令集 所谓指令系统就是指计算机能执行的全部指令的集合，可以看成计算机硬件的语言系统，也是软件硬件的重要典型分界面。计算机的指令系统包含若干条指令，所以指令系统必须对指令的格式、功能、类型、数量以及相关寻址方式做出明确定义。 6. 地址码？寻址方式？地址结构？ CPU 根据指令寄存器 IR 中保存的指令，结合指令系统定义的规范，将指令分解成操作码、地址码等。操作码指示要进行那种运算，地址码则指示如何得到操作数、结果如何保存，以及后续指令的地址如何形成等 参与运算的数据简称操作数，指令应当给出操作数的有关信息，极少情况下会由指令直接给出操作数，大多数指令一般只会给出操作数的获取途径，如寄存器号及其寻址方式 指令的地址结构是指在指令中明确给出几个地址、给出哪些地址。在大多数指令中，地址信息所占的位数最多 7. 寻址方式 大致可将众多的寻址方式归纳为以下四大类，其它的寻址方式则是它们的变型或组合。 立即寻址。在读取指令时也就从指令之中获得了操作数，即操作数包含在指令中。 直接寻址类。直接给出主存地址或寄存器编号，从CPU内或主存单元内读取操作数。 间接寻址类。先从某寄存器中或主存中读取地址，再按这个地址访问主存以读取操作数。 变址类。指令给出的是形式地址（不是最终地址），经过某种变换（例如相加、相减、高低位地址拼接等），才获得有效地址，据此访问主存储器以读取操作数。 8. 何谓隐式 I/O 指令？其主要特点是什么？ 有些计算机采用通用的数据传输指令实现 I/O 操作，相应地将外围设备（I/O 接口寄存器）与主存单元统一编址。 这类指令的 I/O 等价功能是借用内存传输指令实现的，所以被称为隐式 I/O 指令 9. 主机调用外围设备，外设编址可采用那几种方式？ 外围设备单独编址 为外围设备接口中的有关寄存器单独分配单独的 I/O 端口地址。这里“单独分配”指独立于主存编制系统，即外围设备分配的 I/O 端口地址码可以与主存单元地址码相同，设备和主存的地址码相互独立 与主存储器统一编址 将总线的地址空间划分为两部分，大部分空间留给主存，小部分留给 I/O 接口寄存器使用。这种编址方式就是把 I/O 端口当成一部分特殊的主存单元，因此两者可分享地址空间，低端地址分给内存使用，高端地址给 I/O 设备使用 二、计算题 1. 扩展操作码：根据条件计算指令条数？ 假设某指令系统指令长 16 位，最多给出三个地址段 X,Y,Z，每个地址段 4 位。给出一种拓展操作码的方案 15-12 11-8 7-4 3-0 指令格式 15 条三地址指令 14 条二地址指令 31 条单地址指令 16 条零地址指令 有意为二地址指令只留下一种拓展标志，相应地只有 15 条三地址指令；而为单地址指令留下 2 种拓展标志，相应地只有 14 条二地址指令，而单地址指令可有 31 条 2. 根据寻址方式寻找操作数？ 立即寻址 MOV AL, 1000H 主存直接寻址 INC (A) 寄存器直接寻址 INC R_0 主存间接寻址 INC @A 寄存器间接寻址 INC （R_0) 自增型寄存器间址 INC (R_0)+ 表示先操作（从寄存器读取有效地址，按此地址访问主存，读写操作数），后修改（寄存器内容+1） 自减型寄存器间址 INC -(R_0) 表示先修改（寄存器内容-1），后操作 变址寻址 INC X(R_0) 形式地址 D；以变址寄存器 中存储的内容 作为偏移量。得有效地址 基址寻址 寄存器中内容作为基准地址，形式地址作为偏移量 基址+变址寻址 有效地址=基准地址+变址偏移量+常规偏移量 PC 相对寻址 X(PC) 注意基准地址是 PC 寄存器当前的内容，他与当前指令在主存中的地址并不一致而是大了 。 取决于指令长度和存储器的编址单位。如指令字长 32 位，存储器按字节编址，则 页面寻址 寄存器 PC 的高位段作为有效地址的高位段，指令中给出的形式地址 d 作为有效地址的地位段，操作数的有效地址由而二者接而成 堆栈寻址 为了存储对战单元地址，CPU 通常设置一个具有加减计数功能的专用寄存器作为堆栈指针，名为 SP，SP 中的内容就是堆栈单元地址。随数据的压入货弹出，SP 中的地址码自动修改，始终指向栈顶单元 3. IEEE754短浮点数格式表示？ 类型 数符（位） 阶码（位） 尾数数值（位） 总位数（位） 偏置值（十六进制） 偏置值（十进制） 短浮点数 1 8 23 32 7FH 127 长浮点数 1 11 52 64 3FFH 1023 临时浮点数 1 15 64 80 3FFFH 16383 短浮点数又称为单精度浮点数，长浮点数又称为双精度浮点数，它们都采用隐含尾数最高数位（）的方法，这样，无形中又增加了一位尾数，因此，相应地尾数真值实际上等于1+（23位尾数数值或52位尾数数值）。 临时浮点数又称为扩展精度浮点数，它没有隐含位，尾数真值就等于64位尾数数值。 单精度浮点数计算公式 S: 符号位（1为负，0为正） M: 尾数，表示小数 E: 阶码 双精度浮点数计算公式 特殊定义 阶码 全零且 也全零时 阶码 全零但 并非全零时，阶码 解析为 ， 解析为实际值（即不加1） 阶码 全 且 全零时， 阶码 全 且 并非全灵时， 第三章 中央处理器 一、基本概念 1. CPU内部各寄存器的功能？ 通用寄存器粗 暂存器 指令寄存器（IR） 程序计数器（PC） 程序状态字寄存器（PSW） 地址寄存器（MAR） 数据缓冲寄存器（MBR） 堆栈指针寄存器（SP） 2. 数据通路结构？ CPU 内部各部件之间需要传输信息，如何将不同的部件连接起来 ，为信息传输提供通路涉及到 CPU 内部数据通路结构。 通常，在内部结构比较简单的 CPU 中设置一条数据传输总线，用来连接 CPU 的寄存器和 ALU 部件，在微处理器中常称为 ALU 总线。在较复杂的 CPU 中，为了提高传输速率可能设置几组数据总线同时传输多个数据。 单路内部总线、分立寄存器结构 采用分立寄存器，各寄存器有自己独立的输入输出端口；用一路单向数据总线连接寄存器和 ALU，使 ALU 成为内部数据通路的中心 单路内部总线、集成寄存器结构 为提高寄存器的集成度，寄存器组往往采用小型半导体存储器结构，一个存储单元相当于一个寄存器，存储单元的位数即寄存器的字长 多路总线结构 效率较高的 CPU 可能需要设置多路数据总线，一个节拍可以并行执行多路数据传输操作，这种方式可有效避免竞争总线，以提高数据的传输速率 3. 何谓同步控制方式，何谓异步控制？有何主要特征？应用场合？ 同步控制 同步控制方式是指用统一的时序信号对各项操作进行控制，所有操作均只由这些时序信号触发，各操作之间不存在控制信号的交互。 同步控制方式的优点是：时序关系简单，时序划分规整（如将时序信号划分为工作周期、节拍、脉冲等三级时序），控制不复杂，控制部件在结构中易于集中，设计方便 同步控制方式的缺点是：在时间的安排上可能不合理，对时间的利用不经济 异步控制 异步控制方式是指个操作不受同一时序信号（如时钟周期）的约束，而是根据实际需要安排不同的时间。各操作之间的衔接，各部件之间的数据传输均采用异步应答方式 异步控制方式的优点是：时间安排紧凑合理，可以按不同部件、不同操作的实际需要来分配时间，时间利用率比同步方式高 异步控制方式的缺点是：控制起来比较复杂，因为两种操作之间存在信息交互，CPU 内部或设备内部很少使用异步控制方式 4. 何谓主从设备，试举例说明。 申请使用总线，并获得批准后掌管总线控制权的设备，称为主设备，否则为从设备。 特点：时间紧凑，能按不同部件，设备的实际需要分配时间，实现异步应答所需的控制比较复杂 5. 同步控制中如何引入异步应答的，试举例说明 联合控制是同步控制和异步控制相结合的方式，即大多数操作（如CPU内部各操作）在同步时序信号的控制下进行，少数时间难以确定的微操作（如涉及I/O操作）采用异步控制。 6. 微程序控制思想的基本要点是什么？ 所谓微程序控制方式，是指为命令不是有组合逻辑电路产生，而是由微指令译码产生的。一条机器指令往往分成几部执行，每步操作所需的若干微命令以二进制代码预先编写并存储成一条微指令，若干微指令组成一段微程序，对应一条机器指令。在设计 CPU 时，预先编制好各段微程序，并将它们组织结构存入一个专用的存储器中，通常称为控制存储器 在微程序控制器中同样有指令寄存器 IR，程序计数器 PC，程序状态字寄存器 PSW，时序系统等外部部件。但其与组合逻辑控制器的最大不同在于微命令产生部件的实体发生了变化，不再是组合逻辑电路的集合，而是一个控制存储器 CM 和相应的微指令寄存器 ，以及微地址形成电路和微地址寄存器 等部件 控制存储器 CM 通常是一个结构比较规整的只读存储器，读取存储器以获取微指令的电路延时较大，因此微程序控制方式下微命令的产生速度通常比组合逻辑更慢 7. 判断下面叙述是否正确，说明理由：串行加法器中的进位链是串行进位链，并行加法器中的进位链只有并行进位链。 错。纯并行进位结构在实现时有一个困难，即随输入数据位数的增加，高位的进位形成逻辑中输入的变量随之增多，电路结构越来越复杂，这将受到实用器件扇入系数的限制。因此在数据位数较多的加法器中常采用分级分组的进位链结构模式 典型的分组方法是 4 位一组，组内并行，组间串行或并行 8.常用的加法器进位链结构有哪几种？ 串行、并行、分组 9. 组合逻辑控制器、微程序控制器有何区别？ 采用组合逻辑控制方式的控制器称为组合逻辑控制器。任何微命令的产生都需要以逻辑条件和时间条件作为输入，输入条件和输出的微命令之间存在严格的逻辑关系，这种逻辑关系可用组合逻辑电路实现 10.组合逻辑控制器、微程序控制器的时序系统是如何划分的？ 组合逻辑控制器的微命令是分时产生的，所以微命令发生器还需引入时序系统提供的工作周期、节拍、脉冲等时序信号 产生节拍，脉冲等时序信号的部件，称为时序系统。 CPU工作周期：在指令周期中的某一工作阶段所需的时间，称为一个工作周期。一般不同。 时钟周期（节拍）：是时序系统中最基本的时间分段。各节拍的长度相同。 定时脉冲（工作脉冲）：有的操作如打入R，还需严格的定时脉冲，以确定在哪一刻打入。 多级时序的划分 二级时序（用在微程序控制器中） 三级时序（用在组合逻辑控制器中） 11.微命令、微操作、微指令、微指令周期、微程序？ 微程序控制方式下的指令周期由若干微指令周期组成，一个 周期恰好等于一个 CPU 时钟周期，每个 周期中都要读取、执行一条微指令 一条机器指令需执行若干操作步骤，每步操作都可以用一条微指令来控制完成，因此需要为机器指令编制若干能译码产生控制信号的微指令。这些微指令组成一段微程序，就能完成对一条机器指令执行的全过程进行控制 12. 1位全加器的结构及关系表达式。 13. 并行加法器中的串行进位链结构和并行进位链结构 串行进位链结构： 并行进位链结构： 14. 时序信号？时序系统？ 计算机的工作需要分步地执行，这就需要一种时间划分的信号标志——时序信号，以反映在什么时间段或时刻，计算机做了什么操作。 二、设计题： CPU的逻辑组成及工作机制 1.CPU的逻辑组成（模型机框图） （1）CPU的逻辑组成→模型机框图； （2）CPU内每个寄存器的作用； 可编程寄存器：通用寄存器 ，堆栈指针 SP，程序状态字寄存器 PSW，程序计数器 PC 暂存器 C，D：约定从主存中读取源操作数地址或元操作数时，使用 C；从主存中读取目的操作数地址或墓地操作数时，以及需要暂存目的地址或运算结果时，使用 D 指令寄存器 IR：为提高读取指令的速度，将指令从主存中读出后，经数据总线 DB 直接将其置入指令寄存器 IR 中 与主存的接口寄存器 MAR，MDR：CPU 访问主存时地址由地址寄存器 MAR 提供。当微命令 EMAR 为高电平时，MAR 的输出送往地址总线；低电平时 MAR 输出呈高阻态，与地址总线断开 数据寄存器既可以与 CPU 内的部件交换数据，也可以与系统总线交换数据。一方面接收 CPU 内部总线的数据或将数据送入 ALU 的选择器B；另一方面与数据总线双向传输数据。EMDR 是 MDR 的数据输出使能控制命令，CPMDR 是把内部总线数据打入 MDR 的时钟同步信号，SMDR 是把数据总线上的数据打入 MDR 的控制命令 （3）总线的分类及定义； （4）控制器的分类及区别； 2.CPU的指令流程 FT（取指操作）→ST（源操作）→DT（目的操作）→执行（ET） （1）指令类型：MOV指令、双操作数算术逻辑运算指令、单操作数算术逻辑运算指令、转移/返回指令、转子指令； 拟出指令 MOV(R_0),(R_1) 的读取和执行流程，整理各步的控制信号 步骤 微操作 微命令 FT0 M→IR EMAR,R,SIR PC+1→PC PC→A,0→B,100101,DM,CPPC ST0 R_1→MAR R_1→A,11111,DM,CPMAR ST1 M→MDR→C EMAR,R,SMDR,MDR→B,10101,DM,CPC DT0 R_0→MAR R_0→B,11111,DM,CPMAR ET0 C→MDR C→A,11111,DM,CPMDR ET1 MDR→M EMAR,W(EMDR) ET2 PC→MAR PC→A,11111,DM,CPMAR 单操作数被定义为目的操作数，且将运算结果保留到原存储位置 转移指令注意目的地址是否为 PC，为 PC 的话还要再把 PC+1（因为存了跳跃到的位置的立即数） 转子指令的话要先把返回地址保存到堆栈站定单元，即先修改栈顶指针，再将 PC 内容（返回地址）经 MDR 压入堆栈保存。在 ET3 中，再将子程序入口地址送入 PC 和 MAR，即可转向子程序 （2）核心是寻址方式：立即寻址、R、(R)、—(R)、(R)+、@(R)+、X(R)； 3.操作时间表的安排（微命令的安排）： （1）CPU数据通路操作：按照数据的流向分成四段 ALU输入选择→AUL功能选择→移位器功能选择→分配脉冲（打入到寄存器中的脉冲）； （2）与访问主存有关的微命令。 读主存：R 激活 MAR 中的地址码：EMAR 置入数据总线的指令进 IR：SIR CPU 内部总线到 MDR（ALU 传数据过来）：CPMDR 数据总线到 MDR（主存传数据过来）：SMDR 第四章 存储子系统 一、基本概念 1. 主存、缓存、外存？ 主存是能由 CPU 直接编程访问的存储器，用来存放 CPU 当前执行所需要的程序和数据，通常与 CPU 位于同一主机范畴之内，常被称为内存 为了解决 CPU 和主存之间的存取速率匹配，许多计算机中设置了高速缓冲存储器（Cache），其存取速率几乎可以和 CPU 的一样快。高速缓存中存放的是 CPU 最近要使用的程序和数据，作为主存中当前活跃信息的副本 由于主存容量有限，大多数计算机系统中还设置另一极大容量存储器，作为对主存的后援和补充。它们位于传统主机的逻辑范畴之外，常被称为外部存储器，简称外存。 2.高速缓存Cache用来存放什么内容？设置它的主要目的是什么？ 最近使用的程序和数据，缓解 CPU 与主存存取速率的不匹配，通常有存取速率较高的静态随机访问存储器（SRAM）构成 3. 存储介质？ 凡是具有并能保持两种稳定状态的物质和旗舰，如果能够方便地与电信号进行转换，就可以作为存储介质 半导体存储器 静态存储器 集成度高、容量大、速率快、体积小、功耗低、易失性 动态存储器 需要通过 MOS 管动态刷新电容（对存 1 的电容补充电荷） 内部结构简单，功耗较低，集成度最高，适合大容量的主存储器 磁表面存储器 在金属或塑料基体上涂覆一层很薄的磁性材料，这层磁膜就是记录介质或记录载体 存储容量大，每位价格低，非破坏性读出，信息保存期长。读写方式特殊所以存取速率远低于半导体存储器，一般作为外存 光盘存储器 基本原理是利用激光束对记录膜进行扫描，利用介质材料的光效应或热效应使其光反射率发生变化或出现烧孔，或使结晶状态变化或磁化方向反转 只读型光盘：一烧孔形式记录信息，由母盘复制而成，不能改写 写入式光盘：可由用户写入，写入后可多次读出，但只能写一次，不能修改 可擦除/重写式光盘：激光束使介质产生的物理变化可逆因此可以擦除重写。但性价比不高，因此并未广泛流行 4. 何谓随机存取？何谓顺序存取？何谓直接存取？请各试举一例。 主存和高速缓存 Cache 是 CPU 可以直接编址访问的寄存器，这就要求它们采用随机存取方式 随机存取的含义 可按地址随机访问任一存储单元；CPU 可按字节或字存取数据进行处理 访问各存储单元所需读写时间完全相同，与被仿单元地址无关，一般可用读写周期（存取周期）表明 RAM 的工作速率 顺序访问存储器（SAM）的信息是按块组织且按顺序在介质上存放的，访问所需事件与信息存放位置密切相关。例如磁带。这种顺序存取方式不适合主存，只能用于外部辅助存储器 直接访问存储器（DAM）在访问信息时，先将读写部件直接指向某一小区域，再在该区域中循序茶轴，访问时间与数据所在位置也密切相关。例如磁盘。在磁盘中，每个记录面划分为若干同心圆磁环（磁道），每个闭合磁道中又分为若干扇区，信息按位串行记录与磁道中。常用于调用较频繁的外存，作为主存的直接后援，如硬盘 5. 静态存储器 SRAM、动态存储器 DRAM 存储原理？ 静态存储器依靠双稳态触发器的两个稳定状态保存信息。每个双稳态电路可储存一位二进制代码 0 或1，一款存储芯片包含若干这样的双稳态电路。双稳态电路是有源器件，需要电源持续供电才能保持电路状态稳定。只要电源正常，就能长期、稳定地保存信息，所以称为静态存储器。如果电源断开，则电路的双稳态被破坏，其存储的信息 会丢失，属于挥发性存储器，或称为易失性。 动态存储器是依靠电路电容上存储的电荷来暂存信息的。存储的基本方式是：通过 MOS 管向电容充电或放点，充电后的状态对应信息 1，放电后的状态对应信息 0。工艺上无法完全避免电容上电荷的泄露，因此需要定时刷新暂存的内容，对存 1 的电容补充电荷。由于需要动态刷新，所以称为动态存储器。 6. 动态刷新分为哪几种情况，各有什么特点？ 集中刷新 在最大刷新间隔时间 内集中安排若干刷新周期，其余时间不安排刷新，以免影响正常的读写操作。因为吧刷新操作集中安排在一段连续时间内，此过程中存储器被刷新操作占用，无法进行正常的访存操作，所以会形成一段较长的访存死区时间 优点是连续访存效率高，刷新控制简单，缺点是安排集中刷新操作这段时间内影响存储器的正常读写 分散刷新 将每个存取刷新时间分为两端，前段时间提供对存储器的正常读写，后段时间专门用于刷新，即将刷新周期分散安排在读写周期后。 分散刷新的优点是时序控制简单，无较长的访存死区时间；缺点是降低了访存效率和速度，制约了对存储器的连续多次访问，故读写速度会显著降低。分散刷新一般只适用于对访存频率和速度要求较低的计算机系统 异步刷新 刷新系统按 和芯片行数来统筹安排所需的合理刷新周期数，每次刷新操作都是分散安排的，优先保证连续多次访存，既可以安排在访存前，也可以安排在访存后。它并不是每次访存后都固定安排一次刷新。在最大刷新建个时间内，如果需要刷新 行存储单元，只需要在刷新周期 内安排刷新一行即可 DRAM 的异步刷新方式兼有两种方式的优点：对正常访存的影响最小，不会积累较长的访存死区时间，也可以避免存储单元的过度刷新。在控制上相对复杂，但它可以充分利用计算机上的 DMA 功能来实现自动刷新。大多数计算机系统都采用异步刷新方式 7. 全地址译码方式？部分地址译码方式？ 全地址译码方式 就是构成存储器时要使用全部地址总线信号，即所有的高位地址信号都用来作为译码器的输入，低位地址信号接存储芯片的地址输入线，从而使存储器芯片上的每一个单元在整个内存空间中具有唯一的地址。 部分地址译码方式 就是仅把地址总线的一部分地址信号线与存储器连接，通常是用高位地址信号的一部分（而不是全部）作为片选译码信号；低位地址信号接存储芯片的地址输入线。 部分地址译码使地址出现重叠区，而重叠区的部分必须空着不准使用，这就破坏了地址空间的连续性，也在实际上减少了总的可用存储地址空间。其优点是其译码器的构成比较简单，成本较低。 全地址译码使存储器芯片上的每一个单元在整个内存空间中具有唯一的地址。 在实际应用中，采用全地址译码还是部分地址译码应根据具体情况来定。如果地址资源很富余，为使电路简单可考虑用部分地址译码；如果要充分利用地址空间，则应采用全地址译码。 二、设计题 半导体存储器逻辑设计：(地址分配、片选逻辑、逻辑框图)，片选逻辑采用全/部分译码方式。 第五章 I/O 系统 一、基本概念 1. 系统总线上一般包含哪三组信息？ 数据信息、地址信息、控制信息 2. 中断方式定义、实质、特点？ 中断方式的 I/O 控制原理是：CPU 一直执行当前分配的计算任务，当设备随机提出某个 I/O 请求时，CPU 立即暂停执行当前任务，并切换到相应的中断服务程序执行。在中断服务程序中，CPU 进行具体的 I/O 控制，当中断服务程序执行完成后，CPU 再返回原来的计算任务继续执行。在执行中断服务程序的过程中，CPU 还可以再次响应优先级更高的设备的 I/O 请求，从而实现中断嵌套 采用中断控制方式，设备没有 I/O 请求时，CPU不必反复查询设备当前运行状态，只有设备提出 I/O 请求，CPU 才参与具体的 I/O 控制。当没有请求时，CPU 和设备可以并行工作，能把 CPU 从反复查询设备状态的简单任务中解放出来。 中断方式使 CPU 的利用率较高，系统的相应延迟也较小，适合中低速设备但实时性要求很高应用领域如温度控制。 3. 中断向量、中断向量表、向量地址？ 中断向量表中存放着各中断服务程序的入口地址（未考虑中断服务程序状态字），称为中断向量。 访问中断向量表的地址称为向量地址。 按照这样的软件组织方法，中断服务程序是独立于主程序事先编制的。不必细致考虑何时中断以及如何处理中断等，只需提供允许中断的可能（如开中断）。一旦发生中断请求，可通过硬件中断请求信号或软中断指令INT n 提供的终端号，经过一系列转换得到向量地址，据此从向量表中找到对应的服务程序入口，从而转入中断服务程序执行 4. 何谓向量中断？何谓非向量中断？各有何优点和缺点？ 如果直接依靠硬件，通过查询中断向量表来确定入口地址，就是向量中断方式；如果是通过执行软件（如中断服务总程序）来确定中断服务程序的入口地址，则属于非向量中断 向量中断特点是依靠硬件操作快速转向对应的中断服务程序。因此现代计算机基本都有向量中断功能，其实现方法可以有多种 非向量中断方式是通过软件查询方式来确定响应哪个中断源，再分治进入响应的服务程序处理。这种方式硬件逻辑简洁，调整优先级方便，但响应速度慢。非向量中断方式一般作为向量中断的一种补充。 5. 单级中断、多重中断？ 多重中断处理方式 这种方式允许在服务过程中响应，处理优先级别更高的中断请求。这就可能形成一种中断嵌套关系 为了允许多重中断，在编制中断服务程序时，采取下列的安排方法。在保护现场后，送出新的屏蔽字，该屏蔽字将屏蔽与本请求同一优先级别和更低级别的其他请求，然后开中断，再开始本请求源所要求的服务处理。 单级中断处理方式 如果响应某个中断服务请求后，CPU 只能为该请求源提供排他式服务，不允许被其他任何优先级的中断请求打断，这种不运行中断服务程序再次响应中断的方式称为单级中断模式。这种模式下，在执行中断服务程序的全过程中，CPU 处于关中断状态，禁止响应任何常规的中断请求 6. 程序直传方式定义、实质、特点？ 直接程序传送（PIO）的工作原理是：CPU 通过执行 I/O 指令，分析设备控制器接口中专门用来指示设备运行状态的状态寄存器，了解设备当前的运行状态，再根据设备运行状态执行对外设的数据 I/O 操作。 PIO 方式硬件结构比较简单，但整个 I/O 操作中，CPU 要反复执行 I/O 指令，外设的整个 I/O 操作都会占用 CPU。所以 CPU 和外设 I/O 不能并行工作，CPU 的利用率较低，I/O 的吞吐率也低，系统的相应延迟也较大。PPIO 方式一般只适合于低俗 I/O 设备。现在 PIO 方式在一些功能比较单一，I/O 要求很低的单片机中还在使用 7. 程序直传方式，中断方式，DMA 方式之间的区别？ DMA 原理上与 PIO 方式刚好相反。当设备提出随机 I/O 请求后，控制系统依靠控制器硬件（主要是 DMA 控制器）直接控制主机与外部设备之间的数据 I/O 操作。CPU 不参与具体的 I/O 操作控制，只负责启动 DMA 控制器，以及执行 I/O 操作的善后处理工作。具体 I/O 操作结束后，DMA 控制器通过中断的方式通知 CPU DMA 控制方式意味着主存储器与外部设备之间有直接的数据 I/O 通路，不必经过 CPU，因此也称为数据直传。 用 DMA 来控制 I/O 操作，CPU 仅负责启动 DMA 控制器和执行 I/O 操作善后处理，进一步提升了主机 CPU 和外部设备的并行性，使 CPU 的利用率更高，响应时间延迟很小，还具备高速的数据 I/O 控制能力，但其硬件机构比中断更复杂，一般适用于主存与高速外设之间的大批量数据简单传输场合，如高速磁盘的读写 《微型计算机原理与接口技术》 第2章 微处理器与总线 一、基本概念 1. 微处理器主要由哪几部分构成？ 运算器、控制器、寄存器组 寄存器组又可视为运算器部件的一部分 2. 说明 8088 CPU 中 EU 和 BIU 的主要功能。在执行指令时，EU 能直接访问存储器吗？ 执行单元（EU）负责分析指令（指令译码）和执行指令，总线接口单元（BIU）负责取指令、取操作数和写结果。这两个单元都能独立地完成各自相应的工作。所以大多数情况，取指令和执行指令操作都可重叠地进行。 3. 8086/8088 CPU 中，有哪些通用寄存器和专用寄存器？说明他们的作用。 通用寄存器包括数据寄存器、地址指针寄存器和变址寄存器 数据寄存器 数据寄存器一般用于存放参与运算的数据或运算结果。每一个都是 16 位寄存器，但又可将高、低 8 位分别作为两个独立的 8 位寄存器使用。高八位记为 AH,BH,CH,DH，低 8 位记为 AL,BL,CL,DL AX：累加器，常用与存放算术逻辑运算的操作数，另外所有的 I/O 指令都使用累加器与外设接口传递信息 BX：基址寄存器，常用来存放访问内存时的基地址 CX：计数寄存器，在循环和串操作指令中用作计数器 DX：数据寄存器，在寄存器间接寻址的 I/O 指令中存放 I/O 端口地址 另外，在双字长乘除法运算时，DX 与 AX 合起来存放一个双字长数（32 位），其中 DX 高 16 位，AX 低 16 位 地址指针寄存器 SP：堆栈指针寄存器，堆栈操作中用来存放栈顶偏移地址，永远指向堆栈栈顶 BP：基址指针寄存器，一般用来存放访问内存时的基地址，但通常与 SS 寄存器配对使用 变址寄存器 常在变址寻址方式中作为索引指针 SI：称为源地址寄存器 DI：称为目的变址寄存器 段寄存器 用于存放段基址，即段起始地址的高 16 位 CS：代码段寄存器 SS：堆栈段寄存器 DS：代码段寄存器 ES：附加数据段寄存器 控制寄存器 IP：指令指针寄存器，用以存放预取指令的偏移地址。CPU 取指令时用 CS 为段基址，以 IP 为端内偏移地址。用户程序不能直接访问 IP FLAGS：标志寄存器或程序状态字（PSW）。是 16 位寄存器但只使用其中的 9 位，包括 6 个状态标志和 3 个控制标志 4. 8086/8088 系统中，存储器为什么要分段？一个段最大为多少字节？最小为多少字节？ 8088/8086 有 20 条地址线，可寻址的最大物理内存容量为 1MB，其中任何一个内存单位都有一个 20 位的地址，称为内存单元的物理地址。但内部寄存器都只有 16 位，访问内存单元在多数情况下都要通过寄存器间接寻址，很明显，若不采取特殊措施，无法访问 1MB 的存储空间。于是 8086/8088 采用将存储器分段的方式解决问题，即将 1MB 的地址空间分为若干个 64KB 的段，用段基址加上端内偏移地址访问物理存储器 段基地址和段内偏移地址又称为逻辑地址，逻辑地址常写成 XXXXH:YYYYH 的形式，其中 XXXXH 是段基址，YYYYH 是段内偏移地址（或相对地址）。20 位的物理地址和逻辑地址的关系如下 物理地址段基址端内偏移 例如，逻辑地址 3A00H:12FBH 对应的物理地址是 3B2FBH 最多 64K 个段即最小 16 字节；最大 即 64K 字节 5. 8086/8088 系统中，物理地址和逻辑地址是指什么？ 同上 6. 8088/8086 CPU 的特点？ 使用并行流水线 内存的分段管理技术 支持多处理器系统 二、计算题 8086/8088 系统中，物理地址和逻辑地址的转换？ 同上 第3章 8086/8088指令系统 一、基本概念 1. 8086/8088 指令系统的 8 种寻址方式 立即寻址 MOV AX,3102H 直接寻址 MOV AX,[3102H] 寄存器寻址 MOV SI,AX 寄存器间接寻址 MOV AX,ES:[SI] 寄存器相对寻址 MOV AX,DATA[BX] 基址-变址寻址 MOV AX,[BX][SI] 基址-变址-相对寻址 MOV AX,5[DI][BX] 隐含寻址 MUL BL 隐含被乘数 AL 和乘积 AX 二、六大类指令 1. 数据传送 1）通用数据传送 一般传送指令 MOV 两个操作数字长必须相同 两个操作数不能同时为存储器操作数 不能用立即数给段寄存器赋值 两个操作数不能同时为段寄存器 一般情况，指令指针 IP 及代码段寄存器 CS 的内容不通过 MOV 指令修改，即不作为目标操作数，但可以作为源操作数 通常情况，FLAGS 不能作为操作数 堆栈操作指令 push/pop 堆栈的存取每次必须是一个字（16 位），且只能是寄存器或存储器操作数，不能是立即数 想堆栈中存放数据时，从高地址向低地址方向增长，取数据时则相反 堆栈段在内存中的位置由 SS 决定，堆栈指针 SP 总是指向栈顶，即 SP 的内容相当于栈顶的偏移地址。压入操作数之前，SP 先减2；每弹出一个字，SP 加 2 对堆栈的操作遵循“后进先出”原则 交换指令 XCHG 将源地址与目标地址中的内容惊醒互换 源操作数和目的操作数可以是寄存器或存储器，但不能同时为存储器 不能为段寄存器操作数 两个操作数字长必须相同 查表转换指令 XLAT 将表的首地址送寄存器 BX，要查找的元素序号送 AL。执行 XLAT 后，表中指定序号的元素被存入 AL （字位扩展指令不要求） 2）输入输出 IN 从端口输入一个字节到 AL 或输入一个字到 AX 中 OUT 将 AL（或 AX）的内容输出到指定的端口 注意：采用间接寻址的 IN/OUT 指令只能用 DX 寄存器作为间址寄存器 3）地址传送 LEA 将存储器操作数的 16 位偏移地址送到指定的寄存器。这里，源操作数必须是存储器操作数，目标操作数必须是 16 位通用寄存器。因该寄存器常用来作为地址指针，故最好选用 4 个间址寄存器之一 LDS、LES 4）标志位操作 PUSHF、POPF、LAHF、SAHF 2. 算术运算类指令 1）加法运算指令 ADD 将源操作数和目的操作数相加，结果送回目标地址 源操作数可以是立即数，可以是无符号数，也可以是带符号数 不允许两个操作数都是存储器操作数 不允许段寄存器作为操作数 ADC 带进位位的加法，CF 也参加求和运算 INC 指定的操作数加一再送回 操作数不能是段寄存器或立即数 2）减法运算指令 SUB、SBB、DEC 同上 CMP 用目的操作数减源操作数，但不送回，只影响 6 个状态标志位，可获得大小及相等关系 （求补指令NEG不要求） 3）乘法指令（不要求） 4）除法指令（不要求） 3. 逻辑运算和移位指令 AND 实现两操作数按位与 是目标操作数中某些位不变，其他清零 使操作数不变，影响 6 个状态标志位 OR 同上 NOT 逻辑非 XOR 可用于清零 TEST 与 AND 类似，但不送回目标操作数而是只影响标志位 SHL,SHR,SAL 逻辑左移等于算术左移，逻辑右移 将左边最高位/右边最低位移入 CF；另一边补零 SAR 算术右移 最高位不补零而是保持不变，最低位移入 CF ROL、ROR、RCR、RCL 循环移位 RCL 和 RCR 带进位标志位 CF 一起移位 4. 串操作指令 源串默认为数据段，即段及地址在 DS 中，但允许段重设。偏移地址 SI 目标串默认在 ES 中，不允许段重设。偏移地址 DI 串长度放 CX DF=0 按地址增量修改 SI,DI（CLD）；DF=1 按地址减量方式修改（STD） 可以在串操作指令前使用重复前置。若使用了重复前缀则没次操作后 CX 自动减一 MOVS 实现了内存单元到内存单元的数据传送 CMPS 比较两个数据串，结果不返回目标串地址而是只反映在标志位中 SCAS 与 CMPS 类似，但用 AL 或 AX 的值域目标串的字或字节比较，只影响操作位 LODS 串装入指令 将 DS:SI 指向的源串中的字节或字装入 AL 或 AX 中，并自动修改 SI 指向下一个要装入的字节或字 STOS 串存储指令 将 AL 或 AX 中的字节或字存到 ES:DI 中指向的存储器单元 5. 程序控制指令 1）转移指令 JMP 无条件转移 JG,JGE,JL,JLE,JE,JNE,JZ,JNZ 条件转移指令 2）循环控制指令 LOOP 先将 CX 减一，若不为零则继续循环；否则退出循环 LOOPZ/LOOPE 先将 CX 减一，再根据 CX,ZF 的值决定是否继续 LOOPNZ/LOOPNE 与 LOOPZ 类似，只是 ZF 的条件相反 3）过程调用指令：CALL 4）中断控制指令：INT INT 指令要把标志寄存器 FLAGS 压栈，而 CALL 不用 INT 影响 IF 和 TF 标志，而 CALL 不影响 中断服务程序入口地址在内存的固定位置以通过中断向量码找到它，而 CALL 指令可以任意指定子程序入口地址的存放位置 6. 处理器控制指令 常用的 CLD 、STD 方向标志位 DF CLI、STI 中断标志位 IF， CLI 即关中断，STI 即开中断 CLC、STC 进位标志位 CF HLT 暂停指令，使 CPU 处于暂停状态，等待中断产生 第4章 汇编语言程序设计 一、基本概念 1. 指令与伪指令区别？ 指令性语句是指指令助记符等组成的可被 CPU 执行的语句 指示性语句告诉汇编程序如何对程序进行汇编，是 CPU 不执行的语句，不能生成目标代码，被称为伪操作语句或伪指令 2. 伪指令 段定义伪指令 格式为 123段名 SEGMENT [定位类型][组合类型]['类别']……段名 ENDS 数据定义伪指令 DB：定义变量为字节类型，也常用来定义字符串 DW：定义变量为字类型。低字节在低地址，高字节在高地址 DD：定义双字类型变量 DQ：定义四字类型变量 DT：定义十字节类型的变量 重复操作号 格式为 1[变量名] 数据定义伪操作 n DUP(初值[,初值…]) 如 DATA1 DB 20 DUP(?) DATA3 DB 20 DUP(30H) 过程定义伪指令 1234过程名 PROC [NEAR/FAR]…… RET过程名 ENDP 当前位置计数器定位伪指令 汇编程序在汇编源程序时，每遇到一个逻辑段，就要为其设置一个位置计数器，用来记录该逻辑段中定义的每一个数据或每一条指令在逻辑段中的相对位置。 在源程序中使用符号 来表示位置计数器的当前值。因此， 被称为当前计数器 定位伪指令 ORG 用来改变位置计数器的值 ASSUME ASSUME 的作用是告诉汇编程序,在处理源程序时，定义的段与哪个段寄存器关联。 ASSUME 并不设置各个段寄存器的具体内容，段寄存器的值是在程序运行时设定的。 ASSUME 段寄存器名：段名，段寄存器名：段名，...... 其中段寄存器名为CS,DS,ES和SS四个之一，段名是用SEGMENT/ENDS伪指令定义的段名。 OFFSET 偏移地址 SEG 段地址 二、汇编语言程序设计 1. 汇编语言源程序结构 1234567891011121314151617181920212223242526272829DATA SEGMENTNUM DB 86H,34H,21HRESULT DW ?DATA ENDS;STACK SEGMENT DW 32 DUP(?)STACK ENDS;CODE SEGMENT ASSUME CS:CODE,DS:DATA,SS:STACKSTART: MOV AX, DATA MOV DS, AX ;初始化数据段寄存器 MOV AX,STACK MOV SS AX ;初始化堆栈段寄存器 LEA SI, NUM LEA DI,RESULT MOV AL,[SI] MOV BL,[SI+1] MUL BL MOV BL,[SI+2] MOV BH,0 SUB AX,BX MOV [DI],AX ;返回 DOS MOV AH,4CH INT 21HCODE ENDS END START 2.汇编语言程序设计四种类型：顺序程序设计、分支程序设计、循环程序设计、子程序设计 略 第6章 输入输出和中断技术 一、基本概念 1. 输入/输出系统主要由哪几个部分组成？主要有哪些特点？ 包括输入输出设备，输入输出接口和输入输出软件 复杂性 异步性 实时性 与设备无关性 2. I/0 接口的主要功能有哪些？有哪两种编址方式？在 8088/8086 系统中采用哪一种编址方式？ CPU 与外设之间交换信息需解决的问题 速度匹配问题 信号电平和驱动能力问题 信号形式匹配问题 信息个事问题 时序匹配问题 I/O 接口的功能 I/O 地址译码与设备选择 信息的输入输出 命令、数据和状态的缓存与锁存 信息转换 编址方式 I/O 端口与内存单元统一编址 可以使用访问内存的方式访问 I/O 端口。具有灵活性，给应用带来很大的方便。缺点是外设占用了一部分内存地址空间，减少了内存可用的地址范围，对内存容量有潜在影响 I/O 端口独立编制 I/O 端口的地址空间与内存地址空间完全独立 I/O 端口与内存使用不同的控制信号 指令系统中设置了专门用于访问外设的 I/O 指令 8086/8088 CPU 采用的是 I/O 端口独立编制方式 3. 试比较 4 种基本输入/输出方法的特点。 无条件传送方式 具有固定状态的简单外部设备的控制，如开关、发光二极管、继电器、步进电机 查询 连接到系统的外部设备是简单的，慢速的，而且对实时性要求不高 连接到同一系统的外设，其工作速度相近 中断 大大提高了 CPU 的效率，还能对外设的请求做出实时响应 直接存储器存取 与以上三种需要 CPU 执行程序来实现（统称为程序控制输入输出方式 PIO）的方式不同，外设不通过 CPU 而直接与存储器进行信息交换，称为直接存储器存取（DMA） 4. 主机与外部设备进行数据传送时,采用哪一种传送方式 CPU 的效率最高？ DMA 二、逻辑电路及程序设计 1. 根据状态端口地址查询相关状态位的值，符合条件通过数据端口传送一次数据 2. 中断向量表中中断向量设置 12345678910111213141516171819202122232425262728293031323334MY_INT PROC FAR PUSH AX PUSH BX STI ;------------------- ;中断程序主体 ;------------------- CLI POP BX POP AX MOV AL, 20H OUT A0H, AL ;主片发送EOI MOV AL, 20 H OUT 20H, AL ;从片发送EOIMY_INT ENDP;---PUSH DSMOV AX, 0000HMOV DS, AXMOV SI, 78H *4MOV BX, OFFSET MY_INTMOV [SI], BXMOV BX, SEG MY_INTMOV [SI+2], BXPOP DS;--- 3. 显存 显存的内容和容量 为了持续不断提供刷新图像所需的数据信号，必须把一帧图像对应的数据信息存储在一个专用的刷新存储器中，这个存储器也叫显示存储器，一般有随机访问存储器构成，简称为显存（VRAM） 当工作于字符/数字模式时，缓存 RAM 存放的是待显示字符的 ASCII 编码。这时一个字符的编码占显存的 1 字节，显存容量由屏幕行列规格决定。例如一帧字符的显示规格 25行x80 列，则 VRAM 最小容量是 行列 在图形/图像模式下，显存中保存的内容是一帧待显示图像的像素编码信息，不同的代码表示图形中像素的不同颜色 缓存容量与屏幕分辨率的高低，显示的颜色种类有关。例如屏幕分辨率为 200线x640点，那么显存的容量就是 200线x640点x1bit/8=16KB 属性信息与属性缓存 彩色或灰度图时，每个像素点需若干位代码表示，例如分辨率为 1024线x1024点，能显示 256 位灰度图，则显存的基本容量应为 1024线x1024点x8bit/8=1MB 某些情况，人们希望屏幕上的字符能够闪烁/下划线/背景与字符采用不同颜色。我们称这些特色为字符的显示属性，屏幕上每个字符属性可以存放在 1 字节中，因此需要一个与显示缓存容量相同的存储器来存放一帧所有字符的属性信息，这个存储器称为属性缓存。例如用来存放字符的显示缓存为 2KB，那么相应的属性缓存也应该至少有 2KB 的容量 对于字符显示方式，如分辨率为 C列xL行，二一个字符的编码与属性，颜色数共占 n 字节，则显存的总容量应不少于 CxLxn 字节 对于图像显示方式，如果分辨率为 CxL 像素，而每个像素的颜色数用 n 位二进制代码表示，则显存容量应不少于 CxLxn 位。 显然图形方式所需的显存容量一般大于字符方式 字符/数字模式的显示原理 从 VRAM 中读取字符编码（ASCII 码），根据字符编码定位 ROM（点阵发生器），再根据点阵的行控制信号，控制各行字符相同行号的点阵代码输出，在用输出的隔行点阵代码形成视频控制信号，去控制屏幕像点（像素）的明暗颜色变化，从而将字符最终显示在屏幕上、 图形/图像模式的显示原理 在 VRAM 中保存的是屏幕像素对应的二进制 RGB 颜色编码，经过一系列转换，最后形成视频控制信号，这些控制信号再来直接控制对应像素点的 RGB 各颜色分量值，从而使像素显示为一定的颜色 计数器 点 线的 CRT 显示器 点计数器 ，字节计数器 ，线计数器 点-字节-线 每一次点计数循环访问一次VRAM，每一次字节计数循环发一次水平同步信号，每一次线计数循环发一次垂直同步信号。 字符显示模式下还要多设置一个行计数器","categories":[{"name":"总结","slug":"总结","permalink":"https://20021123.xyz/categories/%E6%80%BB%E7%BB%93/"},{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"https://20021123.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"https://20021123.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://20021123.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"}]},{"title":"机器学习导论","slug":"机器学习导论","date":"2023-02-25T04:27:21.000Z","updated":"2023-02-25T04:45:12.000Z","comments":true,"path":"2023/02/25/机器学习导论/","link":"","permalink":"https://20021123.xyz/2023/02/25/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AE%BA/","excerpt":"","text":"一、机器学习概论 机器学习方法三要素 方法模型策略算法 1. 模型 模型就是要学习的条件概率分布或决策函数。模型的假设空间包含所有可能的条件概率分布或决策函数。 2. 策略 机器学习需要考虑按照什么准则学习或选择最优的模型。机器学习的目标在于从假设空间中选择最优模型。 损失函数度量模型一次预测的好坏，风险函数度量平均意义下模型预测的好坏。 1. 损失函数和风险函数 监督学习问题是在假设空间 中选取模型 作为决策函数，对于给定的输入 ，由 给出相应的输出 ，这个输出的预测值 和真实值 可能一致也可能不一致，用一个损失函数或代价函数来度量预测错误的程度。损失函数是 和 的非负实值函数，记作 损失函数值越小，模型就越好。由于模型的输入输出 是随机变量，遵循联合分布 ，所以损失函数的期望是 这是理论上模型 关于联合分布 的平均意义下的损失，称为风险函数或期望损失 给定一个训练数据集 模型 关于训练数据集的平均损失称为经验风险或经验损失 根据大数定律，当样本容量 区域无穷时，经验风险 趋于经验风险 。但是由于现实中训练样本数目有限，所以用经验风险估计期望风险常常不理想，要对经验风险进行一定矫正。这就关系到监督学习两个基本策略：经验风险最小化和结构风险最小化。 2. 经验风险最小化与结构风险最小化 经验风险最小化的策略认为，经验风险最小的模型是最优的模型。即求解最优化问题 但是当样本容量很小时，经验风险最小化的学习效果未必很好，会产生“过拟合”现象 结构风险最小化是为了防止过拟合而提出来的策略。结构风险最小化等价于正则化。结构风险在经验风险上加上不出模型复杂度的正则化项或罚项。在假设空间、损失函数及训练数据集确定的情况下，结构风险的定义是 其中 为模型的复杂度，是定义在假设空间 上的泛函。 是系数，用以权衡经验风险和模型复杂度。 结构风险最小化的策略认为结构风险最小的模型是最优的模型，即求解最优化问题 3. 算法 算法是指学习模型的具体计算方法。机器学习基于训练数据集，根据学习策略，从假设空间中选择最优模型，最后需要考虑用什么样的计算方法求解最优模型。这时机器学习问题归结为最优化问题，机器学习的算法称为求解最优化问题的算法。 泛化性 学习方法的泛化能力是指该方法学习到的模型对未知数据的预测能力，是学习方法本质上重要的性质。现实中采用最多的是通过测试误差来评价学习方法的泛化能力。但这种评价依赖于有限的测试数据集，可能不可靠。机器学习理论试图从理论上对学习方法的泛化能力进行分析。 若学到的模型是 ，那么用这个模型对位置数据预测的误差即为泛化误差 泛化误差反映了学习方法的泛化能力，如果一种方法学习的模型比另一种方法学习的模型具有更小的泛化误差，那么这种方法就更有效。事实上，泛化误差就是所学习到的模型的期望风险。 模型选择 当假设空间含有不同复杂度（如不同参数个数）的模型时，就要面临模型选择的问题。我们希望选择或学习一个合适的模型。如果在假设空间中存在真模型，那么所选择的模型应逼近镇魔性。具体地，所选择的模型要与真模型的参数个数相同，所选择的模型的参数向量与真模型的参数向量相近。 若一味追求提高对训练数据的预测能力，所选模型的复杂度往往会比真模型更高，这种现象称为过拟合。过拟合是指学习时选择的模型所包含的参数过多，以至于出现这一模型对已知数据预测的很好，但未知数据预测很差的现象。可以说模型选择旨在避免过拟合并提高模型的预测能力。 当模型复杂度增大时，训练误差会逐渐减少并趋向于 ；而测试误差会先减小，达到最小值后又增大。当选择的模型复杂度过大时，过拟合现象就会发生。这样在学习时就要防止过拟合，进行最优的模型选择，即选择复杂度适当的模型，以达到使训练误差最小的学习目的。 正则化与交叉验证 模型选择的典型方法是正则化。正则化是结构风险最小化策略的实现，是在经验风险上加一个正则化项或罚项。正则化项一般是模型复杂度的单调递增函数，模型越复杂，正则化值越大。比如正则化项可以是模型参数向量的范数。 例如，在回归问题中，损失函数是平方损失，正则化项可以是参数向量的 范数 也可以是参数向量的 范数 另一项常用的模型选择方法是交叉验证。 在许多实际应用中数据是不足的。为了选择好的模型，可以采用交叉验证方法。交叉验证的基本想法是重复地使用数据，把给定的数据进行切分，将切分的数据集组合为训练集与测试集，在此基础上反复地进行训练、测试、以及模型选择 简单交叉验证 简单交叉验证方法时：首先随机地将已给数据分为两部分，一部分非作为训练集另一部分作为测试集；然后用训练集在各种条件下（例如，不同参数个数）训练模型，从而得到不同的模型；在测试机上评价各个模型的测试误差，选出测试误差最小的模型 S 折交叉验证 应用最多的是 S 折交叉验证：首先随机地将已给数据分为 S 个互不相交，大小相同的子集；然后利用 S-1 个子集的数据训练模型，利用余下的子集测试模型；将这一过程对所有 S 中选择重复进行；最后选出 S 次评测中平均测试误差最小的模型 留一交叉验证 S 折交叉验证的特殊情形是 S=N，称为留一交叉验证，往往在数据缺乏的情况下使用。 分类问题 准确率与召回率 二、感知机 感知机学习算法是对以下最优化问题的算法。给定一个训练数据集 其中 ，求参数 ，使其为一下损失函数极小化问题的解 其中， 为误分类点的集合 感知机学习算法是误分类驱动的，具体采用随机梯度下降法。首先，任意选取一个超平面 ，然后用梯度下降法不断地极小化目标函数。极小化过程不是一次使 中而又误分类点的梯度下降，而是一次随机选取一个误分类点使其梯度下降。 假设误分类点集合 是固定的，那么损失函数 的梯度由 随机选取一个误分类点 ，对 进行更新 式中 是步长，在机器学习中又称为学习率 三、支持向量机 给定线性可分训练数据集，通过间隔最大化或等价地求解相应凸二次规划问题学习得到的分离超平面为 以及相应的分类决策函数 称为线性可分支持向量机 函数间隔 对于给定的训练数据集和超平面 ，定义超平面 关于样本点 的函数间隔为 定义超平面 关于训练数据集 的函数间隔为超平面 关于 中所有样本点 的函数间隔之最小值，即 但当 成比例时改变时超平面并没有改变，函数间隔却称为原来的两倍。 几何间隔 对于给定的训练数据集和超平面 ，定义超平面 关于样本点 的几何间隔为 定义超平面 关于训练数据集 的几何间隔为超平面 关于 中所有样本点 的几何间隔之最小值，即 ### 线性可分支持向量机学习算法原始形式 最优化问题 在线性可分情况下，训练数据集的样本点中与分离超平面距离最近的样本点的实例称为支持向量。支持向量是使约束条件式等号成立的点，即 对 的正例点，支持向量在超平面 上，对 的负例点，支持向量在超平面 上 之间的距离称为间隔。间隔依赖于分离超平面的法向量 ，等于 。 称为间隔边界 拉格朗日对偶形式 其中 为拉格朗日乘子向量 改写为如下最优化问题 例：正例点 负例点 解：对偶问题是 通过带入得到 对其求偏导并令其为 ，易知极值点 ，但该点不满足约束条件 ，所以最小值在边界取得 当 ，最小值 ；当 时，最小值 于是得 此时， 得对应的实例点 是支持向量，得到 分离超平面 分类决策函数 四、决策树 熵 熵是表示随机变量不确定性的度量。设 是一个取有限值的离散随机变量，其概率分布为 则随机变量 的熵定义为 若 ，则定义 通常，对数以 或 为底，这时单位分别称为比特或纳特 熵只依赖于 的分布，与取值无关，所以也可将 的熵记作 ，即 设有随机变量 其联合概率分布为 当熵和条件上中的概率由数据估计（特别是极大似然估计）得到时，所对应的熵与条件熵分别称为经验熵和经验条件熵 信息增益 特征 对训练数据集 的信息增益 定义为集合 的经验熵 与特征 给定条件下 的经验条件熵 之差，即 根据信息增益的特征选择方法是：对训练数据集 ，计算其每个特征的信息增益，并比较它们的大小，选择信息增益最大的特征 信息增益比 为防止选择信息增益作为划分特征时选择取值较多的特征的偏向性问题，使用信息增益比进行校正 定义 特征 对训练数据集 的信息增益比 定义为信息增益与训练数据集关于特征 的值的熵之比，即 其中 ， 是特征 取值的个数 例如 对于各特征对数据集 的信息增益 等等 ID3 算法 输入：训练数据集 ，特征集 阈值 输出：决策树 若 中所有实例属于同一类 ，则 为单节点树，并将类 作为该节点的类标记，返回 若 ，则 为单节点树，并将 中实例数最大的类 作为该节点的类标记，返回 否则，按照先前算法计算 中各特征对 的信息增益，选择信息增益最大的特征 如果 的信息增益小于阈值 ，则置 为单节点树，并将 中实例数最大的类 作为该节点的类标记，返回 否则，对 的每一可能值 ，依 将 分割为若干非空子集 ，将 中实例数最大的类作为标记，构建子节点，由结点及其子节点构成树 ，返回 对于第 个子节点，以 为训练集，以 为特征集，递归调用步骤 1-5，得到子树 ，返回 C4.5 算法 基本类似，只是改为以信息增益比作为选择特征 基尼指数 分类问题中，假设有 个类，样本点属于第 类的概率为 ，则概率分布的基尼指数为 对于二分类问题，样本点属于第一个类的概率是 ，则其基尼指数是 对于给定的样本集合 ，其基尼指数 如果样本集合 根据特征 是否取某一可能值 被分割为 两部分，则在特征 的条件下，集合 的基尼指数定义为 基尼指数表示集合 的不确定性，基尼指数 表示经 分割后集合 的不确定性 CART 算法 输入：训练数据集 ，停止计算的条件 输出：CART 决策树 设结点的训练数据集为 ，计算现有特征对该数据集的基尼指数。此时，对每一特征 ，对其可能取的每个值 ，根据样本点对 的测试为“是”或“否”将 分割成 两部分，利用上式计算 时的基尼指数 在所有可能的特征及其所有可能的切分点中，选择基尼指数最小的特征点及其对应的切分点作为最优特征与最优切分点。依最优特征与最优切分点从现结点生成两个子节点，将训练数据集依特征分配到两个子节点中 对两个子节点递归调用步骤 1-2，直至满足停止条件 算法停止计算的条件是节点中的样本个数小于既定阈值或样本机的基尼指数小于预定阈值（样本基本属于同一类），或者没有更多特征 例如 特征 的基尼指数 求特征 的基尼指数 由于 只有一个切分点，所以它们就是最优切分点 等等 五、朴素贝叶斯 朴素贝叶斯法对条件概率分布作了条件独立性的假设 朴素贝叶斯利用后验概率最大的类作为 的类输出，即 注意到分母对所有 相同，即 例如 由表计算得下列概率 对于给定的 ，计算 由于后者最大，所以 六、k 近邻 值的减小意味着整体模型变得复杂，容易发生过拟合 值过大则学习的静思误差会增大，意味着整体模型变简单 应用中一般取一个比较小的 ，采用交叉验证法选取最优的 值 kd 树的最近邻搜索 输入：已构造的 kd 树，目标点 输出： 的最近邻 在 kd 树中找出包含目标点的叶结点：从根节点出发根据切分点坐标和 当前维坐标的大小递归访问 kd 树 以此叶节点为“当前最近点” 递归往上回退 如果当前结点保存的实例点比当前点距离目标点更近，则以该实例点为“当前最近点” 检查“当前最近点”的父节点的另一个子节点的区域是否有更近的点，具体的：检测该区域与以目标点为球心，当前最近距离为半径的超球体是否相交。若相交则移动到另一子节点递归最近邻搜索。不相交向上回退 回退到根节点时搜索结束。最后的“当前最近点”即 的最近邻点 七、聚类 类或促的定义 设 为给定的整数，若对于集合 中任意两个样本 ，有 则 为一个类或簇 k 均值聚类 首先采用欧氏距离平方作为样本之间的距离 然后定义样本与其所属的类的中心之间的距离的综合为损失函数 k 均值聚类就是求解最优化问题 事实上其最优解且解问题是 NP Hard，现实中采用迭代法解决 输入： 个样本的集合 输出：样本集合的聚类 初始化。领 ，随机选择 个样本点作为初始聚类中心 对样本进行聚类。对固定的类中心，计算每个样本到类中心的距离，将每个样本支配到与其最近的中心的类中，构成聚类结果 计算新的类中心。对聚类结果 ，计算当前各个类中的样本的均值，作为新的类中心 如果迭代收敛或符合停止条件，输出 ；否则令 ，返回第二步 可以带计算器","categories":[{"name":"总结","slug":"总结","permalink":"https://20021123.xyz/categories/%E6%80%BB%E7%BB%93/"},{"name":"机器学习","slug":"机器学习","permalink":"https://20021123.xyz/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"},{"name":"AI","slug":"AI","permalink":"https://20021123.xyz/tags/AI/"}]},{"title":"概率论与数理统计 第九章 回归分析","slug":"概率论与数理统计-第九章-回归分析","date":"2023-02-25T04:26:12.000Z","updated":"2023-02-25T04:26:54.000Z","comments":true,"path":"2023/02/25/概率论与数理统计-第九章-回归分析/","link":"","permalink":"https://20021123.xyz/2023/02/25/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90/","excerpt":"","text":"第九章 回归分析 9.1 回归分析的模型 一般来说，变量之间的关系可分为两类 确定性关系，在数学上可表示为函数关系 相关关系，即变量之间存在某种联系但没有达到可以相互确定的程度 设在一个问题中，因变量 的值由两部分构成：一部分是自变量的影响表现为 的函数 ；另一部分由其他未知的未加考虑的因素以及随机因素的影响，这一部分记为随机误差 ，于是得到模型 作为随机误差，通常要求均值为 ，方差存在，即 这样的假定下， 就是自变量 取值为 时，因变量 的数学期望 函数 称为 对 的回归函数，方程 称为 对 的回归方程 以上模型称为回归模型 只含一个自变量的回归分析称为一元回归分析，含有多个自变量的回归分析称为多元回归分析 9.2 一元线性回归 回归函数为线性函数的情形 其中 是未知常系数，这种情形叫做线性回归 这里讨论只有一个自变量 的情形，回归模型 称为一元线性回归模型，其中 为未知参数， 称为回归常数， 称为 对 的回归系数 确定自变量 的一组值 对 做 次独立观测试验，记实验结果为 ，则 由于各次观测独立，所以 独立同分布 有时进一步要求随机误差 服从正态分布，模型 称为一元正态线性回归模型，此时 可看做正态总体 的简单随机样本 一、对 的估计 估计值和观测值的偏离 称为在 处的残差，残差平方和 考虑使 最小的 作为 的估计值，这种估计方法称为最小二乘法 记 为 对 的经验回归方程，“经验”表示回归方程是由实验数据得到的区别于直接从模型得到的理论回归方程 利用多元函数求极值的方法，求 对 的偏导并使其等于零，得 整理后，得正规方程组 解此方程得 的估计值 其中 得到 的无偏估计为 其中 将观测数据点描绘在坐标平面上得到的图形称为散点图 二、估计量的统计性质 对正态回归模型，有 类似地 对于正态回归模型，有 有 对于正态回归模型 三、一元线性回归的显著性检验 1. 检验法 记 为总离差平方和，记 称 为残差平方和， 为回归离差平方和 对回归系数 进行检验，提出原假设 统计量 于是对于给定的显著性水平 ，原假设的拒绝域是 这里使用的方法是方差分析法 各离差平方和常用简便计算式 2. 相关系数检验法 以其矩估计量相关系数 进行检验 定义 $$ $$ 提出原假设 不难发现 于是 对于给定的 ，由 即得到样本相关系数临界值 的计算式","categories":[{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"https://20021123.xyz/categories/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"概率论与数理统计 第八章 假设检验","slug":"概率论与数理统计-第八章-假设检验","date":"2023-02-25T04:25:45.000Z","updated":"2023-02-25T04:26:02.000Z","comments":true,"path":"2023/02/25/概率论与数理统计-第八章-假设检验/","link":"","permalink":"https://20021123.xyz/2023/02/25/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/","excerpt":"","text":"第八章 假设检验 8.1 假设检验的基本概念 一、问题的提出 提出统计假设 这是两个对立的假设。假设 称为原假设或零假设，而假设 称为备择假设或对立假设。备择假设描述的内容与原假设对立，它作为备择假设的含义是，在假设检验问题中，否定原假设后，则选择备择假设的结论 关于总体参数的检验称为参数的假设检验，关于总体分布的假设称为非参数的假设检验 参数假设检验分为参数的单侧假设检验和双侧假设检验 二、假设检验的接收域与拒绝域 使原假设 得以接受的检验统计量取值的区域称为检验的接收域，使原假设 被拒绝的检验统计量取值的区域称为检验的拒绝域， 三、假设检验的两类错误和检验水平 假设检验可能犯的第一类错误是弃真错误： 本来是正确的却被拒绝了，犯第一类错误的概率为 拒绝为真 这个事先给定的 称为假设检验的显著性水平 假设检验可能翻的第二类错误是纳伪错误： 实际上不正确，却被接受了 一般先保证犯第一类错误的概率 有较小的值如 再尽可能地使犯第二类错误的概率尽可能小 8.2 参数的假设检验 一、单个正态总体均值 的检验 1. 总体方差 已知 原假设成立时，检验统计量 ，若给定显著性水平为 ，则 得到原假设 的拒绝域为 ，在这个检验中我们使用了统计量 ，其服从的分布为 ，若一检验方法使用了服从标准正态分布的统计量，则称为 检验法 2. 总体方差 未知 检验统计量 有 得到原假设 的拒绝域为 若一检验方法使用了服从 分布的统计量，则称为 检验法 二、单个正态总体方差 的检验 取检验统计量为 其拒绝域为 或 运用了服从 的统计量，常称为检验法 当总体均值已知时，常取检验统计量为 在原假设 成立时，它服从 分布 三、两个正态总体均值差 的检验 1. 当总体方差 和 均已知时 在 成立时，有检验统计量 于是，显著性水平为 的检验的拒绝域为 ，即 上述几个检验称为两样本 检验法 2. 当总体方差 和 均未知，但 时 当原假设 成立时，有检验统计量 其中 于是，显著性水平为 的拒绝域为 ，或 上述几个检验称为两样本 检验法 四、两个正态总体方差 的检验 当参数 未知。当原假设 成立时，有检验统计量 得到检验问题的拒绝域为 或 当参数 已知时，以 五、大样本检验方法 令 的精确分布复杂，其极限分布是 ，当 都足够大时，以 作为 的近似分布，确定出检验问题的拒绝域为 或 8.3 分布的假设检验 设 是来自总体 的一个样本，在显著性水平 下，检验假设 其中 为某一个已知或仅含有若干个未知参数的分布函数 处理这个问题的一般原则：设法确定一个量 ，它具有某种理由可以作为样本 与理论分布 之间偏离的度量，就具体的样本观测值算出 的值，记为 ，然后在假设 成立的条件下，算出概率 它被称为在选定的偏离值表 之下，样本与理论分布的拟合优度 越大，表示样本与理论分布的拟合越好，假设 就越可信 一般地，事先根据某种考虑，确定显著性水平 ，当 时拒绝 ，否则接受 ，通常称这种类型的检验为拟合优度检验 一、理论分布完全已知且只取有限个值 设 为只取有限个值，且理论分布完全已知的离散型分部总体，则假设可表述为 总体分布率为 其中 均已知，且 以 表示 中等于 的个数。考虑样本容量 足够大时，由大数定律， 中等于 的个数应大致为 ，不妨设 为“理论频数”，把 称为“经验频数” 显然里，理论频数与经验频数的差异越小，越符合原假设 。有下列统计量 定理 若原假设成立，则当样本容量 时， 的分布是自由度为 的 分布，即 给定显著性水平，计算出 的值，得原假设 的拒绝域为 根据实际经验，样本容量 不应小于 二、理论分布只取有限个值但含有未知参数 设 为只取有限个值 ，总体分布律为 其中 为未知参数，可在一定范围内变化，参数个数 ，此时，原假设的一般提法是 总体分布率为 其中 为参数 在其变化范围内的一组值 通常采用 的最大似然估计值 代替参数真值 ，不过此时 的抽样分布发生一点变化 定理 在一定条件下，若原假设 成立，则当样本容量 足够大时，由上式确定的统计量 的分布近似服从自由度为 的 分布，即 由此结果，对给定显著性水平 ，原假设的拒绝域为 三、总体分布为一般分布 设 是抽自总体 的样本，欲检验原假设 的分布函数为 其中 完全已知，或含有未知参数，将其记为 检验原假设 的基本方法是通过区间的划分转化为已讨论过的情况","categories":[{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"https://20021123.xyz/categories/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"概率论与数理统计 第七章 参数估计","slug":"概率论与数理统计-第七章-参数估计","date":"2023-02-25T04:25:13.000Z","updated":"2023-02-25T04:25:34.000Z","comments":true,"path":"2023/02/25/概率论与数理统计-第七章-参数估计/","link":"","permalink":"https://20021123.xyz/2023/02/25/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%8F%82%E6%95%B0%E4%BC%B0%E8%AE%A1/","excerpt":"","text":"第七章 参数估计 7.1 参数的点估计 设总体 的分布函数为 其分布类型已知， 是未知参数。 是总体 的样本，对每一个未知参数 ，构造一个适当的统计量 ，作为对参数 的估计。我们称 为参数 的估计量。将观测值 带入估计量 ，就得到一个具体数值 ，即 的估计值。通常在不至混淆的情况下，对估计量和估计值不作严格区分，统称为估计，并简记为 一、矩估计法 设总体 的分布为 ，若总体的各阶矩存在，则它的矩（原点矩或中心距）是参数 的函数。以原点矩为例，总体 解原点矩为 或 用样本 阶原点矩 去估计相应的总体 阶原点矩，即构造方程组 解此方程租，其解为 ，就以 作为 的估计。 同理，若要估计 的函数 ，就用 去估计它，这样给出的估计量就是矩估计 二、最大似然估计法 对于离散型总体，事件 发生的概率为 对于离散型总体，随机样本 落在点 的边长依次为 的 维长方体邻域内的概率近似于 因为 与参数 无关，故只需考虑 我们将式 统称为参数 的似然函数，记为 。若 则称 为 的最大似然估计值，称 为参数 的最大似然估计量 因为对数函数是单增函数，所以 和 在相同点处达到最大值，为了计算方便，一般通过求解如下的似然方程组 得到未知参数的最大似然估计 7.2 估计量的优良性准则 一、无偏性 定义 设 是未知参数 的一个估计量，若对 的所有可能取值，都有 则称 是 的一个无偏估计量 一个估计量如果不是无偏的就称之为有偏估计量。称 为估计量 的偏差，在科学技术中也称为 的系统误差。由此，无偏估计的意义就在于无系统误差 二、有效性 定义 设 是未知参数 的两个无偏估计，若对 的所有可能取值，都有 则称 比 有效 设 是 的无偏估计，若对 的任何一个无偏估计 ，都有 对 的所有可能取值成立，则称 为 的最小方差无偏估计 三、相合性 定义 设 是 的估计量，若对 的所有可能取值，当 时， 以概率收敛于 ，即对任意 ，有 或 成立，则称 为 的相互估计量或一致估计量 7.3 区间估计 一、基本概念 定义 给定一个很小的数 ，若对于参数 的所有可能取值，都有 则称随机区间 是 的置信水平为 的置信区间 二、枢轴变量法构造置信区间 寻找置信区间的一般方法： 找出一个关于带估计参数 的良好的估计量 构造一个包含参数 及其估计量的函数 除了被估计参数 外， 不能包含其他未知数，并且 的概率分布能完全确定，与 无关，函数 称为枢轴变量 对任何参数 ，不等式 可以改写成等价形式 ， 与 是不含未知参数的统计量 根据 的分布，找出其上侧 分位数 和上侧 分位数 ，有 ，改写成等价的形式 ，区间 即使参数 的置信水平为 的置信区间 三、一个正态总体参数的置信区间 总体均值 的置信区间 已知 此时枢轴变量 ，置信水平为 的置信区间为 未知 由于此时 未知， 不再构成枢轴变量，故用 代替 ，即可得到枢轴变量 得到参数 的置信水平为 的置信区间是 总体方差 的置信区间 只介绍 未知的情形 我们知道 是 的无偏估计，根据定理 于是 可作为枢轴变量， 分布不是对称分布，可由分布表查出 和 ，即可得到 的置信水平为 的置信区间为 四、两个正态总体的区间估计 设总体 是来自正态总体 的样本；总体 是来自正态总体 的样本。两个样本相互独立， 和 分别表示两个样本的均值和方差 两个正态总体均值差 的置信区间 已知 因为 是 的无偏估计，所以 是 的无偏估计，又因为 相互独立，故 取枢轴变量为 即得 的置信水平为 的置信区间为 未知，但 由定理知 两个正态总体方差比 的置信区间 仅讨论总体均值 未知的情况，由定理知 从而确定出比值为 的置信水平为 的置信区间为 当参数 均已知时，可通过构造枢轴变量 进行方差比的区间估计 五、大样本方法构造置信区间 非正态分布而言，以中心极限定理为理论基础，利用极限分布确定枢轴变量的否是，进而构造出置信区间 有中心极限定理，当 足够大时 作为枢轴变量 若 ​ 未知，则以 作为枢轴变量，得出 的置信区间为 置信水平近似地为 ，近似的成都不仅取决于样本容量 的大小，还要看总体分布 六、单侧置信区间 置信区间有两个有限的端点称为双侧置信区间 定义 设 是来自某个总体的样本，总体分布包含未知参数 是两个统计量，若 对 的一切可取的值，有 则称随机区间 为参数 的置信水平为 的单侧置信区间， 称为单侧置信下限 对 的一切可取的值，有 则称随机区间 为参数 的置信水平为 的单侧置信区间， 称为单侧置信上限","categories":[{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"https://20021123.xyz/categories/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"概率论与数理统计 第六章 数理统计的基本概念","slug":"概率论与数理统计-第六章-数理统计的基本概念","date":"2023-02-25T04:24:37.000Z","updated":"2023-02-25T04:24:56.000Z","comments":true,"path":"2023/02/25/概率论与数理统计-第六章-数理统计的基本概念/","link":"","permalink":"https://20021123.xyz/2023/02/25/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"第六章 数理统计的基本概念 6.1 总体、样本与统计量 一、总体 研究对象的全体称为总体或母体 组成总体的每个基本元素称为个体 具有一定概率分布的总体称为统计总体，其概率分布称为总体分布 当总体分布为指数分布时称为指数分布总体；当总体分布为正态分布时称为正态分布总体或正态总体 二、样本 样本是按一定规定从总体中抽出的一部分个体 取得样本的过程称为抽样 样本是一组随机变量，记为 ，其中 称为样本容量或样本大小、样本量 把样本 的全体称为一组样本，而把 称为其中的第 个样本 实施抽样后得到的具体数据 称为样本观测值 要求样本满足下列要求 代表性 每一个 应与总体 有相同的分布 独立性 应该是相互独立的随机变量 具有上述两个特性的样本称为简单随机样本 三、统计量 设 为来自总体 的一个样本，若样本函数 中不含任何未知参数，则称 为一个统计量 常用统计量为 称为样本均值 称为样本方差， 称为样本标准差 ，称为样本 阶原点矩 称为样本 阶中心距 样本原点矩和样本中心距统称样本矩，显然 ，值得注意的是样本二阶矩和样本方差相差一个实数因子： 将样本观测值代入上述各式得到统计值，用相应的小写字母表示，如 等 6.2 抽样分布 统计量的分布称为抽样分布 一、三个重要分布 1. 分布 定义 设随机变量 的概率密度为 则称随机变量 服从自由度为 的 分布，记为 其中 为 函数，定义为 定理 设有 个相互独立且都服从正态分布 的随机变量 ，即 则称随机变量 服从自由度为 的 分布 设随机变量 ，对于给定的正数 ，称满足关系式 的数 为 分布的上侧分位数或上侧临界值 分布的性质 设随机变量 ，则有 设随机变量 相互独立，且 ，则 当 足够大时，有 其中 是标准正态分布的上侧分位数 2. 分布 定义 设随机变量 的概率密度为 则称 服从自由度为 的 分布，记为 定理 设随机变量 相互独立， ，记 则随机变量 服从自由度为 的 分布 同理可定义 为 分布的上侧分位数或上侧临界值 可以证明，若随机变量 ，则对任意实数 ，有 因此当 足够大时， 近似服从 分布 3. 分布 设随机变量 的概率密度为 则称 服从第一自由度为 ，第二自由度为 的 分布，记为 定理 设随机变量 相互独立，，记 则 服从第一自由度为 ，第二自由度为 的 分布 同理可定义 为 分布的上侧分位数或上侧临界值 易知 ，据此性质，得 二、抽样分布定理 定理 设 是正态总体 的样本， 分别是样本均值和样本方差，则有 相互独立 定理 设 和 分别是来自正态总体 和 的样本，并且它们相互独立， 及 分别是这两组样本的样本均值和样本方差，则有 当 时 其中","categories":[{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"https://20021123.xyz/categories/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"概率论与数理统计 第五章 大数定律和中心极限定理","slug":"概率论与数理统计-第五章-大数定律和中心极限定理","date":"2023-02-25T04:23:22.000Z","updated":"2023-02-25T04:23:56.000Z","comments":true,"path":"2023/02/25/概率论与数理统计-第五章-大数定律和中心极限定理/","link":"","permalink":"https://20021123.xyz/2023/02/25/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B%E5%92%8C%E4%B8%AD%E5%BF%83%E6%9E%81%E9%99%90%E5%AE%9A%E7%90%86/","excerpt":"","text":"第五章 大数定律和中心极限定理 5.1 随机变量序列的收敛性 定义 设 是随机变量序列， 是一个随机变量（或为常数 ），若对任意给定正数 ，有 或等价地 则称随机变量序列 依概率收敛于 ，记为 或记为 定义 设 是随机变量序列， 为随机变量 和 分别为 的分布函数。若在 的连续点 均有 则称 依分布收敛于 ，记为 依分布收敛于 ，表明 以 的分布为极限分布 5.2 大数定律 一、切比雪夫不等式 定理（切比雪夫不等式） 设随机变量 的数学期望 和方差 均存在，则对任意常数 ，不等式 或 二、大数定律 定义 设随机变量序列 的每个数学期望 都存在，若对任意给定的正实数 ，有 则称随机变量序列 服从大数定律 定理（切比雪夫大数定理） 设 是相互独立的的随机变量序列，每个随机变量的数学期望 和方差 均存在，且方差一致有界，即存在正常数 ，使 则 服从大数定律 定理（独立同分布大数定理） 设 是相互独立且服从同一分布的随机变量序列，每个随机变量的数学期望与方差均存在，即 则 服从大数定律，即对任意 有 定理（辛钦大数定律） 设 是相互独立且服从统一分部的随机变量序列，每个随机变量的数学期望均存在，即 则 服从大数定律，即对任意正数 ，有 根据大数定律的定义可知： 的数学期望均存在，是其服从大数定律的充分条件 定理（伯努利大数定理） 设 是 重伯努利试验中 出现的次数， 是 在每次试验中发生的概率，则对任意实数 ，有 小概率实际推断原理 概率很小的事件，在一次实验中几乎不可能发生，在实际中可看成不可能事件 5.3 中心极限定理 定义 设 是相互独立的随机变量序列，其前 项和的标准化随机变量序列为 记 的分布函数为 ，若 则称随机变量序列 服从中心极限定理 即随机变量序列 依分布收敛于标准正态分布随机变量 定理（独立同分布中心极限定理） 设 是独立同分布的随机变量序列，有数学期望和方差 则随机变量序列 服从中心极限定理，即有 因此，当 很大时，可以认为 近似服从 分布，从而 近似服从 分布。or随机变量序列 的前 想的算术平均 近似服从 分布 若 是 个独立同分布的随机变量，当 充分大时，可得概率近似计算公式 定理（棣莫弗-拉普拉斯中心极限定理） 设随机变量 ，则对任意实数 有","categories":[{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"https://20021123.xyz/categories/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"概率论与数理统计 第四章 随机变量的数字特征","slug":"概率论与数理统计-第四章-随机变量的数字特征","date":"2023-02-25T04:22:45.000Z","updated":"2023-02-25T04:23:10.000Z","comments":true,"path":"2023/02/25/概率论与数理统计-第四章-随机变量的数字特征/","link":"","permalink":"https://20021123.xyz/2023/02/25/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E6%95%B0%E5%AD%97%E7%89%B9%E5%BE%81/","excerpt":"","text":"第四章 随机变量的数字特征 4.1 数学期望 一、随机变量的数学期望 定义 设离散型随机变量 的分布律为 若 ，则称 为随机变量 的数学期望或均值 设随机变量 服从柯西分布，其概率分布为 则其数学期望不存在 二、随机变量的函数的数学期望 定理 设 是随机变量 的函数 （ 连续） 若 是离散型随机变量，其分布律为 若 绝对收敛，则有 若 是连续型随机变量，其概率密度是 ，若 则 定理也可以推广到多维随机变量的情形 三、数学期望的性质 设 是常数，则 设 是随机变量， 是常数，则有 设 是两个随机变量，则有 设 是相互独立的随机变量，则有 4.2 随机变量的方差 定义 设 是随机变量，若 存在，则称 为 的方差，称 为 的标准差（或均方差） 常用的计算公式为 方差的性质有 设 是常数，则 若随机变量 的方差存在， 是常数，则有 设随机变量 的方差存在，有 有设 相互独立，则 随机变量 的方差为零的充要条件是 以概率为 取常数 ，即 设 设随机变量 的数学期望存在，方差 ，令 为随机变量 的标准化随机变量，满足 4.3 几种常见分布的数学期望和方差 一、二项分布 设 ，有 二、泊松分布 设 ，有 三、均匀分布 设 ，则 四、指数分布 设随机变量 服从参数为 的指数分布，其概率密度为 则 五、正态分布 设随机变量 ，其概率密度为 则有 4.4 协方差、相关系数与矩 一、协方差 定义 若关于随机变量 的数学期望 存在，则称 为随机变量 的协方差 特别地，有 且 协方差的性质 对称性： 齐性：， 是常数 可加性 常利用公式 定义 设 维随机变量 的协方差均存在，称矩阵 为 维随机变量 的协方差矩阵 协方差矩阵满足 二、相关系数 定义 设随机变量 的协方差及方差均存在且 ，则称 为随机变量 的相关系数 也可写成下列形式 即相关系数 是 相应的标准化随机变量的协方差 定理 设 两个随机变量的相关系数 存在，则有 的充要条件是 依概率为 线性相关，即存在常数 使 定义 若随机变量 相关系数存在，且 则称 不相关；若 ，则称 正相关；若 ，则称 负相关 定理 若 相互独立，则 不相关 但此定理的逆定理不存在 三、矩 定义 设随机变量 的数学期望 存在，若有 ，则称 为 的 阶原点矩，称 为 的 阶绝对原点矩 随机变量 的数学期望即一阶原点矩 定义 设随机变量 的数学期望 存在，且 ，则称 为 的 阶中心距，称 为 的 阶绝对中心距 可以证明，若高阶矩存在，则低阶矩一定存在 随机变量 求 各阶中心距 得 为奇数时， 为偶数时， 将 带入，得 其中 ，如 4.3 多维正态随机变量 定义 设 维随机变量 的协方差矩阵 是 阶正定对称矩阵，联合概率密度为 其中 则称 服从 维正态分布 当 时无法写出其概率密度，称 服从退化正态分布或奇异正态分布 维正态随机变量的概率密度均由其均质向量 和协方差矩阵 确定，记为 服从 性质 维正态分布随机变量的任一 维子向量服从 维正态分布，特别地， 均为一维正态随机变量 维正态随机变量 相互独立的充要条件是其协方差矩阵是对角矩阵 ​ 等价地， 维正态随机变量相互独立的充要条件是 两两不相关 相互独立的正态随机变量的有限线性组合仍然服从正态分布 为正态随机变量 的任一非零线性组合 服从正态分布，其中 不全为零 设有矩阵 随机变量 ，其线性变换 服从 维正态分布 ，特别若 为 阶满秩矩阵，则该线性变换是非退化的 维正态随机变量，也称正态随机变量的线性不变性","categories":[{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"https://20021123.xyz/categories/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"概率论与数理统计 第三章 多维随机变量","slug":"概率论与数理统计-第三章-多维随机变量","date":"2023-02-25T04:22:07.000Z","updated":"2023-02-25T04:22:34.000Z","comments":true,"path":"2023/02/25/概率论与数理统计-第三章-多维随机变量/","link":"","permalink":"https://20021123.xyz/2023/02/25/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%A4%9A%E7%BB%B4%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F/","excerpt":"","text":"第三章 多维随机变量 3.1 二维随机变量及其分布 一、联合分布函数 定义 设随机试验 的样本空间 ， 是定义在 上的 个随机变量，则将它们构成的有序组 称为 维随机变量，或称 维随机向量 定义 设 是二维随机变量， 是任意实数对，记 称二元函数 为 的联合分布函数； 的分布函数 分别称为 关于 的边缘分布函数 因 可得联合分布函数与边缘分布函数的关系如下 二维联合分布函数的性质 分别对 单调不降 对每一个变量 是右连续的 是非负有界函数： 并且有 对任意实数 ，有 维随机变量 的联合分布函数定义为 式中 是 个任意实数 由 的联合分布函数可确定其中任意 个（）分量的联合分布函数，称为 维边缘分布函数，例如 是 分别关于 的边缘分布函数 二、联合分布律 定义 二维随机变量 所有可能取值为有限对或可列无穷对：，记 满足以下条件 则称 为二维离散型随机变量，称上式为 的联合分布律 关于 的联合分布律，有如下性质 随机变量 的联合分布函数为 随机变量 的分布律为 设随机变量 的联合分布律如表所示，其中 ，称 服从二维两点分布 X 得 三、联合概率密度 定义 二维随机变量 的联合分布函数为 ，如果存在 ，使得对于任意实数对 有 则称 是连续型的二维随机变量，函数 称为 的联合概率密度 同理有如下性质 处处成立 若 ，则有 随机变量 的概率密度分别为 称 为 关于 的边缘概率密度 四、二维均匀分布 设 其面积记为 ，若二维随机变量 的联合概率密度为 则称 在 上服从均匀分布 设 是 的子域（）则有 若随机变量 在 上服从均匀分布，则对任意 ，有 的长度的长度 根据以上两式和类似公式，人们借助于几何度量来计算概率，称这种概率为几何概率 五、二维正态分布 二维随机变量 的联合概率密度为 其中 均为常数，且 ，则称 服从二维正态分布，记为 命题 若二维随机变量 则 3.2 随机变量的独立性 定义 设 是二维随机变量，若对于任意实数 ，有 成立，则称随机变量 相互独立 等价于 成立 定理 设 是为二维离散型随机变量，则 相互独立的充要条件是对于 的任意一对取值 均有 定理 设 是连续型随机变量，其联合概率密度和边缘概率密度分别是 ，则 相互独立的充要条件是 在平面上取出“面积”为零的集合外成立 定义 设 维随机变量 的联合分布函数为 ，若对所有实数组 均有 成立，式中 是关于 的边缘分布函数，则称 相互独立 若 为 维连续型随机变量，则上式可改写为 定理 若 维随机变量 相互独立，则 其中任意 个随机变量也相互独立 若随机变量的函数 也是随机变量，则它们也相互独立 若 与 相互独立，且 是连续函数，则 和 也相互独立 3.3 条件分布 一、条件分布律 设离散型随机变量 的联合分布律为 若 ，则在事件 已发生的条件下，事件 的条件概率为 次概率数列具有分布列的性质 定义 设 是离散型随机变量，对固定的 ，若 ，则称 为在 的条件下，随机变量 的条件分布律 对 固定时同理 二、条件概率密度 对于一般随机变量 ，不能保证 或 ，因此对于离散型随机变量，不能用条件概率的概念引入“条件分布函数”，而是用极限来处理 定义 对于给定的实数 和任意的 ，若 ，且对任意实数 ，极限 存在，则称此极限为“Y=y”的情况下，随机变量 的条件分布函数，记为 对二维离散型随机变量 ，若 ，则在 的条件下，随机变量的条件分布函数为 若 是随机型连续变量，其联合概率密度为 ，若记 为在 的条件下，随机变量 的条件概率密度，则 3.4 随机变量的函数及其分布 一、离散型随机变量的函数及其分布律 离散型随机变量 的分布律为 若它的函数 仍是离散型随机变量，则其分布律为 其中 设离散型随机变量 的联合分布律为 的函数 仍是离散型随机变量，其分布律为 其中 定理 设离散型随机变量 相互独立，其分布律分别为 $$ 则其和的分布律为 P{X+y=m}=_{k=0}^m p(k)q(m-k)(m=0,1,2,) $$ 两个相互独立的泊松分布随机变量之和仍服从泊松分布，其参数为相应的参数之和。称泊松分布具有可加性（再生性） 类似可证二项分布也具有可加性：若 且 相互独立，则和 可以归纳证明，若 相互独立，且 ，则 换言之，若随机变量 则 可以表示称为 个相互独立的 (0-1) 分布随机变量之和 二、连续性随机变量的函数及其概率密度 仅考虑两种情形 是连续型随机变量，函数 也是连续型随机变量，求其概率密度 是连续型随机变量，函数 是一维连续型随机变量，求其概率密度 设 的概率密度为 ，则 的分布函数为 的概率密度为 在的连续点其他 设 的联合概率密度是 ，则 的分布函数为 的概率密度为 在的连续点其他 定理 设随机变量 具有概率密度 ，，又设 处处可导且恒有 （或恒有 ）则 是离散型随机变量，其概率密度为 其他 其中 ， 是 的反函数 三、几种特殊函数的分布 极值分布 设随机变量 与 相互独立，则最大值 ，最小值 的分布函数分别为 和的分布 设 的联合概率密度 ，则 的分布函数是 $$ $$ 设随机变量 相互独立且都在 上服从均匀分布，求其和 的概率密度 当 当 当 时 此时称 服从辛普森分布，或三角分布 商的分布 设 的联合概率密度为 ，则其商 的分布函数是 得 的概率密度为 随机变量的模拟 的分布函数 连续且单增，随机变量 在 上均匀分布，则","categories":[{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"https://20021123.xyz/categories/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"概率论与数理统计 第二章 随机变量的分布","slug":"概率论与数理统计-第二章-随机变量的分布","date":"2023-02-25T04:20:40.000Z","updated":"2023-02-25T04:21:14.000Z","comments":true,"path":"2023/02/25/概率论与数理统计-第二章-随机变量的分布/","link":"","permalink":"https://20021123.xyz/2023/02/25/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%86%E5%B8%83/","excerpt":"","text":"第二章 随机变量的分布 2.1 随机变量的分布函数 定义 设 是随机试验 的样本空间，若对于每一个样本点 ，都有唯一的实数 与之对应，且对于任意实数 ，都有确定的概率 与之对应，则称 为随机变量，简记为 随机变量有如下的特点 它们是由随机实验的结果所确定的量 随机变量取各值的可能性大小有确定的统计规律性 引进分布函数来描述随机变量的统计规律 定义 设 是随机试验 的样本空间， 是任意实数，称函数 为随机变量 的分布函数， 也可记为 可将随机变量 看成实数轴上随机点的坐标， 称为随机点 定理 设 为随机变量 的分布函数，则 为单调不降函数，即 ，有 ，且 是右连续函数，即 2.2 离散型随机变量 一、离散型随机变量及其分布律 定义 如果随机变量 只取有限个或可列无穷多个数值 ，记 ，它满足 则称 为离散型随机变量，并称 为 的分布律，并用如下表格表示 例 某射手一次射击命中目标的概率为 ，射击进行到第一次命中目标位置，求射击次数 的分布律 解 设 第次射击击中目标 则 且 故 的分布律为 则称随机变量 服从几何分布 若一个试验的样本空间只有两个样本点，则只有两个可能的对立结果 ，则称之为伯努利试验 在伯努利试验中， 为伯努利试验的基本事件，若 ，令 发生不发生 则 的分布律为 或者 则称 服从（0-1）分布（或两点分布） 二、伯努利试验与二项分布 定义 将一个试验在相同条件下重复进行 次，如果在每次试验中，任一事件出现的概率与其他各次试验结果无关，则称这 次试验是 次重复的独立的试验 次重复独立的伯努利试验称为 重伯努利试验，或称伯努利概型 定理 在 重伯努利试验中，事件 在每次试验中发生的概率为 ，，则 恰好发生 次的概率为 注意到 ，显然 ，并由二项式定理有 则称 服从二项分布，记为 特别若 ，则其分布律为 则 服从（0-1）分布 三、泊松分布 设随机变量 的分布律为 则称随机变量 服从参数为 的泊松分布，记为 泊松定理 设随机变量序列 有 ，即 若满足 则有 当 很大， 很小时，可用泊松定理近似计算二项分布的概率 其中 2.3 连续型随机变量 一、概率密度函数 定义 设 是随机变量 的分布函数，若存在非负函数 ，对任意实数 ，有 则称 是连续型随机变量，称 为 的概率密度 连续性随机变量的概率密度具有如下性质 若 在点 处连续，则 连续型随机变量的分布函数 是一个在 上的连续函数 设 为连续型随机变量，则对任一指定实数 ，有 二、几种连续型分布 均匀分布 设连续型随机变量 具有概率密度 其他 则称 在区间 上服从均匀分布，记为 可得 的分布函数为 指数分布 设随机变量 ​ 的概率密度为 则称随机变量 服从参数为 的指数分布 三、正态分布 定义 若连续型随机变量 的概率密度为 其中 均为实数，且 ，则称 服从参数为 的正态分布（或高斯分布），记为 特别地当 ，即 时，称 服从标准正态分布，其概率密度简记为 正态概率密度 具有以下性质 处处大于 ，且具有各阶连续的导函数 在 内单调增加，在 达到最大值 ，在 上单调减少，当 或 时， ​ 关于直线 ​ 是对称的，即对任意实数 ​，有 ​，从而 若 服从标准正态分布，其分布函数记为 有如下常用计算式 若随机变量 ，则 若随机变量 ，则 设随机变量 ，若 则称 是标准正态分布的上侧分位数 得","categories":[{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"https://20021123.xyz/categories/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"概率论与数理统计 第一章 概率论的基本概念","slug":"概率论与数理统计-第一章-概率论的基本概念","date":"2023-02-25T04:19:23.000Z","updated":"2023-02-25T04:20:24.000Z","comments":true,"path":"2023/02/25/概率论与数理统计-第一章-概率论的基本概念/","link":"","permalink":"https://20021123.xyz/2023/02/25/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%A6%82%E7%8E%87%E8%AE%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","excerpt":"","text":"第一章 概率论的基本概念 1.1 随机事件与随机变量 一、随机现象及其统计规律 确定性现象的共同特点是在准确重复某些条件时它的结果总是确定的；或者根据它过去的状态，在一定条件下完全可以预言将来的发展情况。 非确定性现象具有事前不可预言性，即在相同条件下做重复试验每次结果未必相同；或是知道它过去的状态，事前却不能预知未来的情况，也称随机现象 随机现象在个别试验中其结果呈现不确定性，在大量重复试验中其结果又具有规律性，我们称大量同类随机现象所呈现的固有规律为随机现象的统计规律性 二、随机试验与随机事件 对社会现象和自然现象进行的观察以及各种科学实验统称为试验 具有以下特征的试验称为随机试验 它可在相同条件下重复进行 试验的全部可能结果，在试验前就明确知道 一次试验结束之前，不能准确预知那一个结果将会出现 称随机试验中可能发生也可能不发生的事情为随机事件，简称时间，通常用大写英文字母 表示 在随机事件中必然发生的事件称为必然事件，用符号 表示 在随机试验中必然不可能发生的事件称为不可能事件，用符号 表示 三、样本空间与随机变量 称在随机试验 中必发生一个且仅发生一个的最简单事件为试验 的基本事件，由若干基本事件组合而成的事件称为复合事件 对于随机试验 的每一基本事件，用一只包含一个元素 的单元素 表示 由若干基本事件组成的复合事件，则用对应的若干元素所组成的集合表示 由全体基本事件所对应的全部元素所组成的集合，称为随机事件 的样本空间，称样本空间的每一个元素 为样本点， 表示事件 发生 若将样本空间看作事件，则它是必然事件，样本空间仍用 表示，试验 的任一事件都是样本空间的子集，记为 定义在样本空间上的随机变量 ，记 四、事件的关系与运算 包含关系 ，即事件 发生必然导致事件 发生，称事件 包含事件 对任一事件 ，都有 若 则称 与 相等，记为 和事件 事件 称为事件 与事件 的和，即当且仅当 和 中至少有一个发生时，事件 发生 积事件 事件 称为事件 与事件 的积，即当且仅当 和 同时发生时，事件 发生； 也记为 互不相容事件 若 ，则称事件 与 互不相容（或互斥） 同一随机事件的基本事件都是互不相容的 对立事件 若 且 ，则称事件 与事件 互为对立事件（或称互为逆事件） 这是指对每次试验而言，事件 与 必有且仅有一个发生 事件 的对立事件记为 ，即一次实验中” A 不发生“这一事件 差事件 事件 称为 与 的差事件，当且仅当 发生且 不发生 按照对立事件的概念，有 ， 1.2 概率 一、概率 概率是对随机事件发生可能性大小的一个客观度量，事件 的概率记为 二、频率 设在相同条件下，进行 次试验，事件 发生了 次，称比值 为事件 发生的频率 一般来讲，在相同的条件下重复进行试验，随着试验次数增多，事件的频率总在某一常数的附近摆动，并且出现较大偏差的可能性很小，我们称频率的这一性质为频率的稳定性 工程中常进行较多次数的重复试验，算得的频率作为概率的近似值 三、古典概率 设 是一个随机试验，若它满足以下两个条件 仅有有限个基本事件 每个基本事件发生的可能性相等 则称 为古典概型试验 设试验 为古典概型试验， 是全体基本事件，则由 所含基本事件个数所含基本事件总数 所确定的概率为事件 的古典概率 四、概率的公理化定义与性质 设随机试验 的样本空间为 ，若对于 的每一事件 都对应一个实数 ，其对应规则满足以下三条 （非负性）对任一事件 ，有 （规范性） （可列可加性）对 的互不相容事件列 ，有 则称 是事件 的概率 由此可得概率的性质 （有限可加性）若事件 的事件组 互不相容，则有 对任何事件 有 （单调性）若事件 和 满足 ，则 和 成立 概率加法定理 对试验 的任意两个事件 ，有 1.3 条件概率 一、条件概率 在已知事件 发生的条件下，事件 发生可能性大小的客观度量，记为 定义 设 是随机试验 的两个随机事件，且 ，称 为在事件 发生的条件下，事件 发生的条件概率 二、乘法公式 设 ，则有 设 ，则有 三、全概率公式 设 为随机试验 的样本空间， 为 的一组事件，若 则称 为 的一个有限划分 全概率公式 设随机试验 的样本空间为 ,， 为 的一个有限划分，且 ，则有 四、贝叶斯公式 设随机试验 的样本空间为 是 的一个有限划分，且 ，则有 1.4 事件的独立性 一、两个事件的独立性 设 是随机试验 的时间，若满足 则称事件 与 相互独立 若事件 相互独立，则 与与与 也分别相互独立 二、 个事件的独立性 对于试验 的三个事件 ，若下面四个等式同时成立 则称 所组成的事件组相互独立，若仅有前三个等式同时成立，则称此事件组是两两独立的 定义 设 为随机试验 的事件，若对任意的 即 ，有 则称事件组 相互独立 定理 若 个事件 相互独立，则将 中的任意多个事件换成它们的对立事件，所得到的 个事件仍然相互独立","categories":[{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"https://20021123.xyz/categories/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"安卓 12 安装 HttpCanary 证书","slug":"安卓 12 安装 HttpCanary 证书","date":"2022-10-23T16:19:00.000Z","updated":"2022-12-25T19:55:32.000Z","comments":true,"path":"2022/10/24/安卓 12 安装 HttpCanary 证书/","link":"","permalink":"https://20021123.xyz/2022/10/24/%E5%AE%89%E5%8D%93%2012%20%E5%AE%89%E8%A3%85%20HttpCanary%20%E8%AF%81%E4%B9%A6/","excerpt":"","text":"安卓 12 安装 HttpCanary 证书 一、安装 HttpCanary 略 二、安装 Magisk 模块 custom-certificate-authorities 三、配置证书文件 /data/data/com/guoshi.httpcanary/cache/HttpCanary.pem 是 HttpCanary 的证书 复制到 /data/misc/user/0/cacerts-custom并改名为 87bc3517.0 四、配置 HttpCanary 在 /data/data/com.guoshi.httpcanary/cache/ 下创建空文件 /HttpCanary.jks 表明证书已安装","categories":[{"name":"教程","slug":"教程","permalink":"https://20021123.xyz/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"搞机","slug":"搞机","permalink":"https://20021123.xyz/tags/%E6%90%9E%E6%9C%BA/"}]},{"title":"Ubuntu 下编译 obs 多路推流插件","slug":"ubuntu 下编译 obs 多路推流插件","date":"2022-09-02T17:34:00.000Z","updated":"2022-12-25T19:53:50.000Z","comments":true,"path":"2022/09/03/ubuntu 下编译 obs 多路推流插件/","link":"","permalink":"https://20021123.xyz/2022/09/03/ubuntu%20%E4%B8%8B%E7%BC%96%E8%AF%91%20obs%20%E5%A4%9A%E8%B7%AF%E6%8E%A8%E6%B5%81%E6%8F%92%E4%BB%B6/","excerpt":"","text":"Ubuntu 下编译 obs 多路推流插件 一、安装 obs-studio 1sudo apt-get install obs-studio 二、下载 obs-multi-rtmp 源码 1git clone https://github.com/sorayuki/obs-multi-rtmp/ 三、一些必要环境 Build system dependencies 1sudo apt install cmake ninja-build pkg-config clang clang-format build-essential curl ccache git OBS dependencies (core): 1sudo apt install libavcodec-dev libavdevice-dev libavfilter-dev libavformat-dev libavutil-dev libswresample-dev libswscale-dev libx264-dev libcurl4-openssl-dev libmbedtls-dev libgl1-mesa-dev libjansson-dev libluajit-5.1-dev python3-dev libx11-dev libxcb-randr0-dev libxcb-shm0-dev libxcb-xinerama0-dev libxcomposite-dev libxinerama-dev libxcb1-dev libx11-xcb-dev libxcb-xfixes0-dev swig libcmocka-dev libxss-dev libglvnd-dev libgles2-mesa libgles2-mesa-dev libwayland-dev OBS dependencies (UI): 1sudo apt install qt6-base-dev qt6-base-private-dev libqt6svg6-dev qt6-wayland If Qt6 is not available: 1sudo apt install qtbase5-dev qtbase5-private-dev libqt5svg5-dev qtwayland5 Plugin dependencies: 1sudo apt install libasound2-dev libfdk-aac-dev libfontconfig-dev libfreetype6-dev libjack-jackd2-dev libpulse-dev libsndio-dev libspeexdsp-dev libudev-dev libv4l-dev libva-dev libvlc-dev libdrm-dev 四、编译 项目目录下 1./build_linux.sh 如报错 /usr/bin/ld: 找不到 -llibobs: 没有那个文件或目录 手动 12sudo updatedblocate */libobs.so 将 CMakelists.txt 中的 1set(LIB_OBS libobs) 改为 1set(LIB_OBS /usr/lib/x86_64-linux-gnu/libobs.so) # 根据 locate 得到的位置来 如报错需要设置 OBS_SRC_DIR 则 1export OBS_SRC_DIR=/usr/include/obs/ 五、使用 解压得到的 obs-multi-rtmp_Linux_0.2.8.0.tar.xz 复制 /usr/share 对应目录 但不知为什么默认不加载 /usr/lib/obs-plugins 的 so 文件，查看 obs 其他插件的 log 后复制到对应位置 1sudo cp ./obs-multi-rtmp.so /usr/lib/x86_64-linux-gnu/obs-plugins","categories":[{"name":"教程","slug":"教程","permalink":"https://20021123.xyz/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://20021123.xyz/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://20021123.xyz/tags/Ubuntu/"},{"name":"obs","slug":"obs","permalink":"https://20021123.xyz/tags/obs/"}]},{"title":"Linux 云服务器安装 KDE 图形页面","slug":"Linux 云服务器安装 KDE 图形页面","date":"2022-08-24T10:56:00.000Z","updated":"2022-12-25T19:57:56.000Z","comments":true,"path":"2022/08/24/Linux 云服务器安装 KDE 图形页面/","link":"","permalink":"https://20021123.xyz/2022/08/24/Linux%20%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85%20KDE%20%E5%9B%BE%E5%BD%A2%E9%A1%B5%E9%9D%A2/","excerpt":"","text":"Linux 云服务器安装 KDE 图形页面 一、安装 kde 桌面环境 KDE 有 3 个不同的包可供安装。 kubuntu-desktop：官方推荐安装的包，包含了 LibreOffice, Kontact, Konversation, Amarok, K3B 等常用软件。 kde-full：全家桶包，包含了 kdegames, kdeaccessibility, kdeplasma-addons, kdeadmin, kdeartwork, kdegraphics, kdemultimedia, kdenetwork, kdepim, kdesdk, kdeutils, kdewebdev, kde-plasma-desktop metapackage 等。 kde-plasma-desktop：核心包，里面只包含了 KDE 运行所需的最小依赖包。 12sudo apt-get install kde-plasma-desktopsudo apt-get install language-pack-zh-hant-base language-pack-zh-hans-base 二、安装 xrdp 1sudo apt install xrdp 随后 123systemctl start xrdpsystemctl enable xrdpsystemctl status xrdp 配置 12sudo adduser ${whoami} ssl-cert echo startplasma-x11 &gt;~/.xsession 三、连接 Windows 下使用 mstsc 即可 截图","categories":[{"name":"教程","slug":"教程","permalink":"https://20021123.xyz/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://20021123.xyz/tags/Linux/"},{"name":"KDE","slug":"KDE","permalink":"https://20021123.xyz/tags/KDE/"}]},{"title":"大学物理 变化的电磁场","slug":"大学物理-变化的电磁场","date":"2022-06-20T16:22:53.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2022/06/21/大学物理-变化的电磁场/","link":"","permalink":"https://20021123.xyz/2022/06/21/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86-%E5%8F%98%E5%8C%96%E7%9A%84%E7%94%B5%E7%A3%81%E5%9C%BA/","excerpt":"","text":"变化的电磁场 感应电动势 感应电流 匝线圈 其中 称为磁链 运动的导体棒 自感 互感 自感磁能 磁线圈的自感 磁场能量密度","categories":[{"name":"大学物理","slug":"大学物理","permalink":"https://20021123.xyz/categories/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/"}],"tags":[{"name":"物理","slug":"物理","permalink":"https://20021123.xyz/tags/%E7%89%A9%E7%90%86/"}]},{"title":"大学物理 静电学","slug":"大学物理-静电学","date":"2022-06-20T16:21:57.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2022/06/21/大学物理-静电学/","link":"","permalink":"https://20021123.xyz/2022/06/21/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86-%E9%9D%99%E7%94%B5%E5%AD%A6/","excerpt":"","text":"静电学 库仑定律 电偶极子 两个大小相等的正负电荷 ，当两者间的距离比他们到所讨论的场点距离小得多时这个电荷系统就成为点偶极子 从负电荷到正电荷的矢径 的方向作为轴线正方向 电量 与 的乘积称为点偶极矩或电距，用 表示 求场强 求电势 极坐标 的点 的场强 均匀带电直线 长为 ，电量为 ，线外一场点 里直线的垂直距离为 ， 点和直线两端的连线与直线之间的夹角分别为 解 取长为 的线元，则 注意 若 ，则 均匀带电细圆环 半径为 的均匀带电细圆环，电量为 ， 求场强 解 设场点距圆心为 ，环上取电荷元 求电势 均匀带电薄圆盘 一均匀带电薄圆盘，半径为 ，电荷面密度为 求场强 解 取一细圆环，其电荷元 场强 注意 若 即 求电势 高斯定理 内 微分形式 均匀带电球体的电场分布 球半径为 ，总电量为 解 当 点在球外时 球内时 静电场环路定理 环路定理的微分形式 均匀带电球面 求半径为 ，总电量为 ，， 得 球面外 球面内 极化强度 极化强度的定义是每单位体积内分子电距的矢量和 对于各向同性的均匀介质， 与 成正比 均匀介质表面束缚电荷面密度与极化强度的关系 电介质中的高斯定理 定义 描述电场的辅助量 ，称为电位移矢量 所以有 内 微分形式 同时 其中 为电介质的介电常量 平板电容器 圆柱形电容器 球形电容器 电容器的串并联 串联 电容减小，耐压提高 并联 电容提高，耐压受耐压最低的限制 电能 电容器的储能 电场能量密度","categories":[{"name":"大学物理","slug":"大学物理","permalink":"https://20021123.xyz/categories/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/"}],"tags":[{"name":"物理","slug":"物理","permalink":"https://20021123.xyz/tags/%E7%89%A9%E7%90%86/"}]},{"title":"大学物理 静磁学","slug":"大学物理-静磁学","date":"2022-06-20T16:19:37.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2022/06/21/大学物理-静磁学/","link":"","permalink":"https://20021123.xyz/2022/06/21/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86-%E9%9D%99%E7%A3%81%E5%AD%A6/","excerpt":"","text":"静磁学 毕奥-萨法尔定律 为电流元与电流元到 点的位矢的夹角 ## 无限长直导线 ## 磁矩 为线圈匝数， 为线圈面积， 为线圈平面法向单位矢量，与电流环绕方向呈右螺旋关系 圆电流轴线上的磁场 圆电流的圆心处 载流直螺线管内部的磁场 无限长 左右两个端面的圆心 高斯定理 ## 安培环路定理 微分形式 其中 是该处电流密度矢量 载流螺线环 无限大电流平面 安培力 ## 磁力矩 安培力做功 洛伦兹力 磁介质的磁感应强度 磁化强度 磁化电流 磁化电流-传导电流 —— 极化电荷-自由电荷 磁场强度矢量 磁介质中的安培环路定理 内 其中 为传导电流密度 磁感应强度和磁场强度矢量的关系 位移电流 位移电流密度 位移电流强度 全电流安培环路定律 微分形式 感生电动势 动生电动势","categories":[{"name":"大学物理","slug":"大学物理","permalink":"https://20021123.xyz/categories/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/"}],"tags":[{"name":"物理","slug":"物理","permalink":"https://20021123.xyz/tags/%E7%89%A9%E7%90%86/"}]},{"title":"大学物理 刚体力学","slug":"大学物理-刚体力学","date":"2022-06-20T16:19:30.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2022/06/21/大学物理-刚体力学/","link":"","permalink":"https://20021123.xyz/2022/06/21/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86-%E5%88%9A%E4%BD%93%E5%8A%9B%E5%AD%A6/","excerpt":"","text":"刚体力学 力矩 刚体转动惯量 刚体绕定轴转动的转动定律 冲量距 作用在刚体上的力矩与时间的成绩称为冲量矩 角动量 角动量守恒定律 力矩的功 刚体的动能定理","categories":[{"name":"大学物理","slug":"大学物理","permalink":"https://20021123.xyz/categories/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/"}],"tags":[{"name":"物理","slug":"物理","permalink":"https://20021123.xyz/tags/%E7%89%A9%E7%90%86/"}]},{"title":"线性代数与空间解析几何 第五章 特征值与特征向量","slug":"线性代数与空间解析几何-第五章-特征值与特征向量","date":"2022-06-20T16:16:32.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2022/06/21/线性代数与空间解析几何-第五章-特征值与特征向量/","link":"","permalink":"https://20021123.xyz/2022/06/21/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%89%B9%E5%BE%81%E5%80%BC%E4%B8%8E%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/","excerpt":"","text":"第五章 特征值与特征向量 5.1 特征值与特征向量的概念与运算 一、定义 定义 设 是 阶方阵，如果存在数 和 维非零向量 ，使 ，则称 为方阵 的一个特征值， 为方阵 对应于 的一个特征向量 二、性质 设 ，则 设 ，则 特征子空间 设 故 是 维向量的子空间，称为矩阵 的特征子空间 三、计算","categories":[{"name":"线性代数","slug":"线性代数","permalink":"https://20021123.xyz/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"线性代数与空间解析几何 第四章 n 维向量空间","slug":"线性代数与空间解析几何-第四章-n-维向量空间","date":"2022-06-20T16:15:47.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2022/06/21/线性代数与空间解析几何-第四章-n-维向量空间/","link":"","permalink":"https://20021123.xyz/2022/06/21/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95-%E7%AC%AC%E5%9B%9B%E7%AB%A0-n-%E7%BB%B4%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4/","excerpt":"","text":"第四章 维向量空间 4.1 维向量空间的概念 一、 维向量空间的概念 个数 组成的有序数组称为 维向量，记为 ，也叫 维行向量， 称为向量 的第 个分量；称 为 维列向量， 称为向量 的第 个分量，分量为实数的向量称为实向量，分量为复数的向量称为复向量 称为 维实向量空间 向量的线性运算 二、 的子空间 定义 设 ，如果 对于 的线性运算也构成一个向量空间，那么称 为 的一个子空间 定理1 设 为 的非空子集合， 是 的一个子空间的充要条件为 对于 的加法和数乘运算是封闭的 4.2 向量组合矩阵 一、向量组的线性组合 1. 向量组线性组合的定义 定义1 若存在数 使得 则称向量 为向量组 的线性组合 或称 可由 线性表出 线性组合的全体 若记 则 即，任一 维向量均可由 线性表出 设 ，则 为 的子空间——有 生成的子空间 2. 向量组线性组合与非齐次线性方程组的关系 定理1 设 则下列命题等价 有解 定义2 设有两个向量组 （I） （II）： 若组（I）中每一个向量都可由组（II）中的向量线性表出，则称组（I）可由组（II）线性表出。若组（I）与组（II）可以互相线性表处，则称组（I）与组（II）等价 若 则 的列向量组能由矩阵 的列向量组线性表示， 为这一表示但系数矩阵 同时 的行向量组能由 的行向量组线性表示， 为这一表示的系数矩阵 二、向量组的线性相关性 1.向量组线性相关性的定义 定义 若存在不全为零的数 使得 则称 线性相关；否则，称 线性无关 说明 若 线性无关，则只有当 时，才有 成立 对于任意向量组，不是线性无关就是线性相关 向量组只包含一个向量 时，若 则说 线性相关，若 则说 线性无关 包含零向量的任何向量组是线性相关的 对于含有两个向量的向量组，它线性相关的充要条件是两向量的分量对应成比例，几何意义是两向量共线；三个向量线性相关的几何意义是三向量共勉 在 中， 线性相关 （或共线） 在 中， 线性相关 共面 2. 线性相关性与齐次线性方程组的关系 定理2 设有 维向量组 ， 则下列命题等价 线性相关 有非零解 推论1 设有 维向量组 ， 则下列命题等价 线性相关 有非零解 推论2 向量个数&gt;向量维数的向量组必线性相关 在 中，任意 个向量必线性相关 线性相关性的基本定理 定理3 若 线性相关，则 线性相关 **部分相关，则整体相关** 定理4 线性相关的充要条件是其中至少有一个向量可由其余 个向量线性表出 定理5 若 线性无关，， 线性相关，则 可由 线性表出，且表示式唯一 4.3 向量的秩与极大无关组 一、向量组的秩与最大无关组的概念及性质 定义 设有向量组 ，如果在 中能选出 个向量 满足 向量 线性无关 中任意 个线性相关 则称 是向量组 的一个最大无关组，数 为向量组 的秩 定理1 若 行初等变换，则 的任意 个（）个列向量与 的对应 个列向量有相同的线性相关性 定理2 矩阵的行秩=列秩=矩阵的秩 定理3 若向量组 可由 线性表出，且 线性无关，则 推论 若向量组 可由 线性表出，且 ，则 线性相关 两向量组秩的关系： 若向量组 I 可由组 II 线性表出，则组 I 的秩 $r_1\\leq$ 组 II 的秩 $r_2$ 定理4 设 是 的线性无关部分组，它为最大无关组的充要条件是 中每一个向量均可由 线性表出 二、 的基、维数与坐标 ： 维向量空间 的一组基： 的一个最大无关组 的维数（）： 的秩， 设 为 的一组基，则 ，特别地， 为一组基， 中 称为 在基 下的坐标 一个向量在确定基下的坐标是唯一的（坐标的唯一性） 设向量组 和 分别为 的基，由于 的任意两组基都是等价的，所以存在可逆矩阵 ，使得 称 为从基 到基 的过渡矩阵 4.4 线性方程组解的结构 一、齐次线性方程组 齐次线性方程组 显然有 称为零解 性质1 设 为齐次线性方程组 的解，则 也是 的解 性质2 若 为齐次线性方程组 的解， 为数，则 也是 的解 性质3 齐次线性方程组 解向量的线性组合也为 的解，即设 为 的解，则对任意 个数 也是 的解 将齐次线性方程组 的解的全体记为 ，即 由性质 1,2知 为 的一个子空间，称为 的解空间，其任意一组基称为 的一个基础解系 定理 设齐次线性方程组 的系数矩阵 的秩 ，则方程组 有基础解系且所含解向量个数为 ，即 的维数为 ，这里 为方程组中未知数的个数 2.基础解系的求法","categories":[{"name":"线性代数","slug":"线性代数","permalink":"https://20021123.xyz/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"线性代数与空间解析几何 第三章 几何空间","slug":"线性代数与空间解析几何-第三章-几何空间","date":"2022-06-20T16:14:13.000Z","updated":"2022-07-12T18:25:46.000Z","comments":true,"path":"2022/06/21/线性代数与空间解析几何-第三章-几何空间/","link":"","permalink":"https://20021123.xyz/2022/06/21/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%87%A0%E4%BD%95%E7%A9%BA%E9%97%B4/","excerpt":"","text":"第三章 几何空间 3.1 空间直角坐标系与向量 一、空间直角坐标系 三个坐标轴的正方向符合右手系 二、向量 （一）向量的概念 （二）向量的线性运算 向量的分量 向量的线性运算 线性运算满足的运算规律 基向量与线性表出 （三）向量在轴上的投影 空间两向量的夹角的概念 特殊地，当两个向量中有一个零向量，规定它们的夹角可在 到 中任意取值 空间一点在轴上的投影 向量在轴上的投影 向量在轴上的投影的性质 向量 在轴 上的投影等于向量的模乘以轴与向量夹角的余弦 两个向量的和在轴上的投影等于两个向量在该轴上的投影之和 （四）线性运算的几何意义 平行四边形法则 伸缩变换 （五）方向角与方向余弦 非零向量 与三条坐标轴的夹角称为方向角 称为向量 的方向余弦 3.2 向量的乘法 一、内积 定义 设向量 称为 与 的内积（或数量积） 记为 由定义可知，基向量 的内积为 向量内积的另一种描述 内积的物理意义：力所做的功 二、外积 定义 向量 与 的外积 是一个向量 与 所确定的平面垂直，且 符合右手系 外积的性质 ， 外积的几何意义 以为邻边的平行四边形面积 基向量的外积 利用坐标计算外积 设 则 三、混合积 定义 设已知三个向量 数量 称为这三个向量的混合积，记为 $$ $$ 混合积的几何意义与性质 向量的混合积 是这样的一个数，它的绝对值表示以向量 为棱的平行六面体的体积 三向量 共面 3.3 平面 一、点法式方程 平面 可由 上任意一点和垂直于 的任一向量完全确定，垂直于 的任一向量称为 的法线向量 法线向量的特征：垂直于平面内任一向量 设 位平面 上任一点 必有 称为平面的点法式方程 其中法向量 ，已知点 二、一般式方程 由平面的点法式方程 称为平面的一般方程 法向量 平面一般方程的几种特殊情况 ，平面通过坐标远点 ，平面通过轴平面平行于轴 ，平面平行于 坐标面 三、截距式方程 例：设平面与 分别交于 ，求此平面方程 解：设平面为 得 四、平面与平面的位置关系 两平面的夹角 定义 两平面法向量之间的夹角称为两平面的夹角（通常取锐角） 例：点 到平面 的距离 解： 故 点到平面距离公式 3.4 空间直线 一、点向式方程 方向向量的定义 如果一非零向量 平行与一条已知直线 ，向量 称为直线 的方向向量 称为直线的点向式方程 称为直线的一组方向数 二、参数式方程 由点向式方程可得 称为直线 的参数式方程， 称为参数 直线的两点式方程 例： 说明： ，即 在平面 上 三、一般式方程 空间直线可看成两平面的交线 称为空间直线的一般式方程 例：确定直线 外一点 到 的距离 解 设 是直线 上任意一确定的点， 是 上另一点，且 则直线 的方程为 平行四边形面积 四、直线与直线的位置关系 两直线的夹角 两直线 与 的方向向量 与 的夹角（通常指锐角）称为 与 的夹角，记为 直线 直线 两直线的位置关系 直线 直线 它们的方向向量为 设点 在直线 上，点 在直线 上，则有 与 重合 与 相交 与 异面 五、直线与平面的位置关系 直线与平面的夹角 直线和它在平面上的投影直线的夹角 称为直线与平面的夹角 或 直线与平面的夹角公式","categories":[{"name":"线性代数","slug":"线性代数","permalink":"https://20021123.xyz/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"线性代数与空间解析几何 第二章 行列式","slug":"线性代数与空间解析几何-第二章-行列式","date":"2022-06-20T16:13:40.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2022/06/21/线性代数与空间解析几何-第二章-行列式/","link":"","permalink":"https://20021123.xyz/2022/06/21/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%A1%8C%E5%88%97%E5%BC%8F/","excerpt":"","text":"第二章 行列式 2.1 行列式的定义 一、矩阵的概念 （一）矩阵概念的引入 定义 由四个数排成二行二列的数表 则表达式 称为数表所确定的二阶行列式，并记作 即 （二）三阶行列式 定义 设有 个数排成三行三列的数表 记 （1）沙落法 （2）对角线法则 说明 对角线法则只适用于二阶与三阶行列式 三阶行列式包括 项，每一项的数位于不同行，不同列的三个元素的乘积，其中三项为正，三项为负 二、 阶行列式的定义 称 分别为 的代数余子式（不含 -1 的幂的称为余子式） 定义 定义 阶矩阵 的行列式 当 时，; 当 时， 其中 ， 为划去 的第一行第 列后所得的 阶行列式， 称为 的代数余子式，记号 例，计算斜下三角行列式 2.2 行列式的性质与计算 一、行列式的性质 性质1 行列式按任意行展开，其值相等，即 其中 ， 为划去 的第 行第 列后所得到的 阶行列式， 称为 的代数余子式 性质2 阶行列式某两行对应元全相等，则行列式为零，即当 ，， 时， 证（归纳法） 结论对二阶行列式显然 设结论对 阶行列式成立，对于 阶：按第 行展开 由于 是 阶行列式且其中有两行元全相等，所以 故 性质3 $$ $$ 性质4（行列式的初等变换） 若把行初等变换施于 阶矩阵 上 将 的某一行乘以数 得到 ，则 将 的某一行乘以数 加到另一行得到 ，则 交换 的第 行和第 行得到 ，则 推论 若行列式某两行对应元成比例，则行列式为零 应用 设 为 阶矩阵，则 初等矩阵的行列式 初等矩阵与任一方阵 乘积的行列式 对任一初等矩阵 ， 设 为初等矩阵，则 例5 奇数阶反对称矩阵行列式必为 为奇数时 二、行列式的计算 例 已知 例 范德蒙德行列式 $$ $$ 三、方阵乘积的行列式 定理1 方阵 可逆的充要条件为 定理2 设 为 阶方阵，则 推论1 设 为 阶矩阵，则 推论2 设 为 阶矩阵，且 （或 ），则 应用： 例 设 且 求证 证： 2.3 拉普拉斯展开 一、行列式按行（列）展开 阶子式 矩阵 中任取 行 列的交点处 个原按照原来的相对位置组成的 阶行列式 称为 的一个 阶子式 的余子式 在 中划去 所在的 行 列，余下的元按照原来的相对位置组成的 阶行列式 称为 的余子式 定理 行列式等于它的任一行（列）各元素与其对应的代数余子式乘积之和，即 推论 行列式任一行（列）与另一行（列）的对应元素的代数余子式乘积之和等于 ，即 二、拉普拉斯展开定理 在行列式 中任取 行（列），由这 行（列）元所组成的一切 阶子式分别与它们的代数余子式的乘积之和，等于行列式 2.4 克拉默法则 一、逆矩阵的一个简明表达式 引理 设 则 即：行列式任一行（列）与另一行（列）的对应元素的代数余子式乘积之和等于 引理2 设 为 阶矩阵，则 ，其中 为 的伴随矩阵 定理1 方阵 可逆的充要条件为 ，当 可逆时， 例 求证 例 求证 若 可逆，则 ，故 若 不可逆，则 ，，反证法可证 也不可逆，所以 二、克拉默法则 已有结论：方阵 可逆的充要条件为 有唯一解 克拉默法则：设 可逆，则 的唯一解为： 是用 代替 中的第 列得到的行列式 证明： 其中 的第 个数等于 相当于把 第 列换成 后的 2.5 矩阵的秩 一、矩阵秩的概念 定义 矩阵 中非零子式的最高阶数 ，称为 的秩，记为 矩阵的秩的另一种理解 设在矩阵 中有一个不等于 的 阶子式 ，且所有 阶子式（如果存在）全等于 ，那么 称为矩阵 的最高阶非零子式，数 称为矩阵 的秩 基本结论与性质 有一个 阶子式不为零 的所有 阶子式全为零 设 为 矩阵，则 对任意矩阵 ， 阶矩阵 可逆 满秩矩阵——可逆矩阵 降秩矩阵——不可逆矩阵 二、矩阵秩的计算 对于行阶梯形矩阵 ， 的非零行的行数 定理1 初等变换不改变矩阵的秩 等价于经初等行变幻能将 化为具有 个费领航的行阶梯型矩阵 推论 乘可逆矩阵不改变矩阵的秩 （将可逆矩阵拆为若干初等矩阵） 三、矩阵的标准形（分解） 对任意矩阵 ，都存在可逆矩阵 使得 ， 其中 称为 的标准形，即任何矩阵都等价与其标准形 与 等价 存在可逆的 使得 推论 同型矩阵 与 等价的充要条件是 例 设 为 阶矩阵，证明 证： 若 则 所以 若 则 中所有 阶子式均为零， 另外 秩1矩阵：拆成一行一列相乘","categories":[{"name":"线性代数","slug":"线性代数","permalink":"https://20021123.xyz/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"线性代数与空间解析几何 第一章 矩阵及其初等变换","slug":"线性代数与空间解析几何-第一章-矩阵及其初等变换","date":"2022-06-20T16:12:36.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2022/06/21/线性代数与空间解析几何-第一章-矩阵及其初等变换/","link":"","permalink":"https://20021123.xyz/2022/06/21/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E8%A7%A3%E6%9E%90%E5%87%A0%E4%BD%95-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%9F%A9%E9%98%B5%E5%8F%8A%E5%85%B6%E5%88%9D%E7%AD%89%E5%8F%98%E6%8D%A2/","excerpt":"","text":"第一章 矩阵及其初等变换 1.1 矩阵及其运算 一、矩阵的概念 （一）矩阵概念的引入 #### （二）矩阵的定义 由 个数排成的 行 列的数表称为 行 列的矩阵，简称为 矩阵，其中 表示第 行第 列元素 简记为 元素为实数称为实矩阵，元素是复数的称为复矩阵 （三）几种特殊矩阵 （1）n阶方阵 行数与列数都等于 的矩阵 ，称为 阶方阵，记作 （主对角线为左上到右下，次对角线为右上到左下） （2）行矩阵，列矩阵 只有一行的矩阵称为行矩阵（行向量），只有一列的矩阵称为列矩阵（列向量） （3）零矩阵 元素全为零， 零矩阵记作 或 （4）对角矩阵 的元 ，且 时， 不全为零 称为对角元，记作 （5）单位矩阵 方阵 也可记作 （6）三角矩阵 形如 的方阵，称为上三角矩阵 当 时， 形如 的方阵，称为下三角矩阵 当 时， 二、矩阵的线性运算 （一）同型矩阵与矩阵相等的概念 行列都相等称为同型 同型且对应元相等称矩阵相等 （二）矩阵的加法 同型的矩阵 负矩阵 同型的矩阵 矩阵加法的运算规律 （三）矩阵的数乘 数乘的运算规律 三、矩阵的乘法 设 矩阵 ， 矩阵 则由元 Misplaced & c_{ij}=a_{i1}b_{1j}+a_{i2}b_{2j}+\\cdots+a_{im}b_{mj}=&amp;\\sum_{x=1}^ma_{ix}b_{xj}\\\\&amp;(i=1,2,\\cdots,n;j=1,2,\\cdots,k) 构成的 矩阵 ，称为矩阵 和 的乘积，记为 例：设 矩阵乘法的运算规律 例 则 故 矩阵的可交换 对于两个 阶方阵 ，，若 ，则称 与 是可交换的 只有 与 可交换时，下列公式才成立 一般来说 （即矩阵乘法不适合消去律） 但是 方阵的幂 设 为 阶方阵， 为正整数 注意 一般， 当 时，，但其逆不真 反例 方阵的多项式 设 为 的多项式， 是 阶方阵，则 称为 的 次多项式 设有多项式 ， 为 阶方阵，则 如 但是，一般 四、矩阵的转置 设 称 为 的转置 对称矩阵 即 反对称矩阵 即 例 为两个 阶对称矩阵，则 对称的充要条件为 可交换 例 是 阶反对称， 是 阶对称，则 是 阶反对称 1.2 高斯消元法与高斯-若尔当消元法 一、线性变换的概念 个变量 与 个变量 之间的关系式 称为从变量 到变量 的线性变换 若记 则上述线性变换的矩阵形式为 例 在平面直角坐标系中，线性变换 是将点 逆时针旋转 角得到新点 的旋转变换 若记 则方程组可用矩阵和向量表示为 系数矩阵为 ，增广矩阵为 齐次方程组 非齐次方程组 （ 中至少有一分量不为零 当 使得方程组 成立时，则称 为 的解 二、高斯消元法与矩阵的初等变换 （一）消元法 任意取值：自由变量 上述解方程组的方法称为消元法 始终把方程组看作一个整体变形，用到如下三种变换 交换方程次序 以不等于 的乘某个方程 一个方程加上另一个方程的 倍 （二）矩阵的初等变换 矩阵的行（列）初等变换是指对矩阵施行以下三种变换 交换两行（列）的位置：（或 ） 用一非零数乘某一行（列）的所有元：（或 ） 把矩阵的某一行（列）的适当倍数加到另一行（列）上去：（或 ） 高斯消元法就是对增广矩阵实施行初等变换转化为行阶梯形（或简化行阶梯形）矩阵 行阶梯形矩阵 每个非零行的非零首元都出现在上一行非零元的右边 没有一个非零行出现在零行之下 简化行阶梯形矩阵 行阶梯形矩阵的每个非零行的非零首元都是 且非零首元所在列的其余元素都为 非零行的非零首元所在列为非自由未知量 增广矩阵经行初等变换化为行（简化）阶梯形，该阶梯形与方程组解的关系 无穷多解 行（简化）阶梯形中非零行的行数 未知量个数 惟一解 行（简化）阶梯形中非零行的行数 未知量个数 右下数不等于 ，无解 若有解 （三）初等矩阵 定义：对单位矩阵做一次初等变换所得矩阵 定理：对矩阵 做一次行（列）初等变换，等于在 的左（右）边乘上相应的初等矩阵 交换 行和 行 第 行乘 第 行乘 加到第 行 1.3 逆矩阵 一、逆矩阵的概念与性质 定义：设 为 阶矩阵，若存在 阶矩阵 ，使得 则称 为可逆矩阵， 为 的逆矩阵，记为 单位阵 对角阵 定理1 设 可逆，则它的逆唯一 证：设有 和 满足 若 均为方阵且 则 可逆且 性质 可逆，且 可逆，且 可逆，且 可逆且 例3 矩阵 满足 ， 证明 可逆，求 解： 初等矩阵的逆矩阵 一个矩阵可逆则可写作有限个初等矩阵的乘积 定理 为 阶矩阵，则下列个命题等价 是可逆的 只有零解 与 行等价 可表为有限个初等矩阵的乘积 推论 设 为 阶矩阵，则 有唯一解的充要条件是 可逆 证 充分性 有唯一解 必要性 设 有唯一解 ，但 不可逆 有非零解 令 则 也为 的解 二、用行初等变换求逆矩阵 求逆矩阵的简便方法 设 可逆，所以存在初等矩阵 使得 方法 行初等变换 1.4 分块矩阵 一、矩阵分块的概念 对于行列数较高的矩阵，为了简化运算常划分为若干肖局长 分块原则：分成特殊矩阵如对角矩阵、零矩阵、三角矩阵等 二、分块矩阵的运算 加法 同型矩阵若分块方法相同，则 数乘 乘法 Misplaced &C_{ij}=A_{i1}B_{1j}+A_{i2}B_{2j}+\\cdots+A_{im}B_{mj}=&amp;\\sum_{x=1}^mA_{ix}B_{xj}\\\\&amp;(i=1,2,\\cdots,n;j=1,2,\\cdots,k) 求逆 只对对角矩阵有效 主对角线矩阵一一对应，副对角线矩阵颠倒顺序","categories":[{"name":"线性代数","slug":"线性代数","permalink":"https://20021123.xyz/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"离散数学","slug":"离散数学","date":"2022-06-20T16:11:31.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2022/06/21/离散数学/","link":"","permalink":"https://20021123.xyz/2022/06/21/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/","excerpt":"","text":"第一章 集合论 1.1 集合的基本概念 指定范围内的每一个对象被称为这个集合的元素 集合 中的元素个数被称为集合 的基数 基数有限的集合称为有限集，反之称为无限集 集合中的元素满足无序且互异 设 为任意两集合，如果 中每个元素都是 中的元素则称 是 的子集，也称 被 包含，或 包含 ，记作 设 为任意两集合，如果 则称 是 的真子集，记作 不含任何元素的集合叫做空集，记作 在一个相对固定的范围内，包含此范围内所有元素的集合称为全集或论集，用 或 表示 设 为任意集合，称 的所有不同子集构成的集合为 的幂集，记作 或 ，即 称含有 个元素的集合为 元集 若 为 元集，则称 的含有 个元素的子集为它的 元子集 1.2 集合的运算 称为 与 的并集，称 “”为并运算 称为 与 的交集，称 “”为交运算 称为 与 的差集，称 “”为差运算， 又可叫做相对补集 特别指出，当 时， 称为集合 的补集，记为 ， 称为补运算 称为 与 的对称差集，称 “”为对称差运算 1.3 无限集 设 为两个集合，若在 之间存在一一对应关系 则称 是等势的 凡与自然数集 等势的集合，称为可数集（可列集），该集合的基数记为 ，读作“阿列夫零” 两个有限集等势当且仅当它们有相同的元素个数 有限集不和其任何真子集等势 可数集可以和其可数的真子集等势 称开区间 为不可数集，其基数称为 ，凡与开区间 等势的集合都是不可数集 第二章 命题逻辑 2.1 命题与命题联结词 能够判断真假的陈述句称为命题。称“真”和“假”为命题的真值 不能再分解为更简单命题的命题，称为原子命题（简单命题）；像“或者”这种连接命题的关联词称为命题联结词；由命题联结词联结原子命题而成的命题称为复合命题 否定联结词 设 是任意一个命题，称复合命题“非 ”为 的否定，记作 ，称符号 为否定联结词 合取联结词 设 是任意两个命题，称复合命题“ 并且 ”为 与 的合取，记作 ，称符号 为合取联结词 析取联结词 设 是任意两个命题，称复合命题“ 或 ”为 与 的析取，记作 ，称符号 为析取联结词 蕴含联结词 设 是任意两个命题，称复合命题“如果 ，则 ”为 与 的蕴含，记作 ，称符号 为蕴含联结词， 为蕴含式的前件， 为蕴含式的后件 等价联结词 设 是任意两个命题，称复合命题“ 当且仅当 ”为 与 的等价，记作 ，称符号 为等价联结词 自然语言描述 符号化结果 仅当 除非 ，否则非 2.2 命题公式、解释与真值表 原子命题又常被称作命题常量，或常值命题 字母 通常被称为命题变量，或命题变元 命题公式 又被称为 的真值函数 命题演算的合式公式，又称命题公式，可按递归规则定义 设 是出现在公式 中的所有命题变元，给它们各指定一个真值，则称这些指定的真值组成 的一个解释（或赋值），常记为 若赋值 使 取值为真则称这个赋值为成真赋值，也称 满足于 ；反之称成假赋值，也称 弄假与 个不同的解释及 对应的真值构成一张表称为 的真值表 任意解释 ，公式 的真值全为真则称 为永真公式（重言式）；如果全为假则称 为永假公式（矛盾式）；如果存在至少一个为真称为可满足公式 设 两个命题公式， 是出现在 中的所有命题变元。如果对于 的 组不同的解释， 与 的结果都相同，则称公式 与 等价，记作 的充要条件是 是永真公式 2.3 公式的标准型——范式 如果任意一个命题公式都可用 中的联结词进行等价表示，则称 是联结词的完备集 设 是一个联结词的完备集且 。如果至少存在一个命题公式不能用 中的联结词进行等价表示，则称 为极小联结词的完备集 称命题变元或命题变元的否定为文字 如果一个命题公式具有形式 其中 是文字，则称该命题公式为合取式或短语 如果一个命题公式具有形式 其中 是文字，则称该命题公式为析取式或子句 如果一个命题公式具有形式 其中 是析取式，则称该命题公式为合取范式 如果一个命题公式具有形式 其中 是合取式，则称该命题公式为析取范式 单个的文字是合取式、析取式、析取范式、合取范式 析取范式、合取范式仅含联结词 有括号的公式必须作为一个整体来看，如 是合取范式但不是析取范式 在含有 个命题变元 的合/析取式中，若每个命题变元与其否定不同时存在但二者之一恰好出现一次且仅一次，则称此合/析取式为关于 的一个极小/大项 如果一个命题公式具有形式 其中 是极大项，则称该命题公式为主合取范式 如果一个命题公式具有形式 其中 是极小式，则称该命题公式为主析取范式 编码规则 利用真值表计算主范式的方法被称为真值表技术 设 是命题公式。对任意解释 ，如果 为真， 也为真，则称 是 的逻辑结果，或者 共同蕴含 ，记作 设 是命题公式，如果 是 的逻辑结果，则称 为有效的或者正确的，否则称为无效的，称 为一组前提， 为结论 等价公式转换法 合取所有前提作为蕴含式的前件，结论作为蕴含式的后件 化简蕴含式 如果结果为 则推理有效否则无效 演绎法 推理规则 P 规则：引入前提 T 规则：引入推理过程的中间结果 CP 规则：如果逻辑结果为蕴含式，并将逻辑式的前件作为前提引入 引入的定理 I：推理定理 E：等价定理 反证法：在 的证明过程中，将 作为附加前提然后推出矛盾的方法 设 和 是两个析取式，如果 中有文字 ， 中有文字 ，则从 与 中分别消去 和 ，并将余下的部分析取构成一个新的析取式 ，这个过程称为消解， 被称为 和 的消解式 消解原理：如果 是 和 的消解式，则 第三章 谓词逻辑 3.1 自然语言的谓词符号化 在原子命题中，可以独立存在的客体称为个体词，用以刻画客体性质或客体之间关系的部分称为谓词 具体明确的个体称为个体常量，个体常量一般用带或不带下标的小写英文字母 等表示 泛指的或抽象的个体称为个体变量，一般用带或不带下标的小写英文字母 表示 个体变量的取值范围称为个体域（或论域），常用字母 表示 宇宙间的所有个体聚集在一起所构成的个体域称为全总个体域 设 是定义在 的 元函数，其中 为非空的个体域，如果 的值域是 ，则称 为 元命题函数或者 元谓词 表示全部数量关系的词语称为全称量词，记为 表示部分数量关系的词语称为存在量词，记为 其中 被称为作用变量 一般将量词加在对应的谓词之前，记为 。此时 被称为全称量词和存在量词的辖域 为了描述的统一性和方便性，将表示个体域的名词称为特性谓词，并用一元谓词表示。一般来说量词后的名词即为特性谓词 3.2 谓词公式与解释 函数的定义域和值域都是个体域 谓词的定义域是 ，值域是 元谓词符号化涉及到的符号总结如下 常量符号：用带或不带下标的小写英文字母 表示，当个体域 给出时它可以是 中某个确定的元素 变量符号：用带或不带下标的小写英文字母 表示，当个体域 给出时它可以是 中的任意元素 函数符号：用带或不带下标的小写英文字母 表示，当个体域 给出时， 元函数 可以是 的任意一个函数 谓词符号：用带或不带下标的大写英文字母 表示，当个体域 给出时， 元谓词 可以是 的任意一个谓词 谓词逻辑中的项递归定义 任意的常量符号或变量符号是项 若 是 元函数符号， 是项，则 也是项 有限次使用 1 和 2 后得到的符号串都是项 注意：项是个体域 中的某个个体次 若 是 元谓词， 是项，则称 为原子谓词公式，简称原子公式 合式谓词公式可按递归规则生成 给定公式 和 ， 为 和 的辖域，则 中 的出现都约束出现，称变元 为约束变元， 中的不同于 的其他变元的出现则是自由出现，称这些变元为自由变元 约束变元改名规则，简称改名规则 将量词辖域内与作用变元相同的约束变元都用新的个体变元替换 新的变元一定要有别于改名辖域中的所有其他变元 自由变元带入规则，简称带入规则 将公示中出现某个自由变元的每一处都用新的个体变元或个体常量替换 新变元不允许在原公式中以任何约束形式出现 设 是任意一个公式，若 中无自由变元则称 为封闭的公式，简称闭式，闭式一定是命题 谓词逻辑中谓词公式 的每一个解释 由如下四个部分组成 非空的个体域 中的每个常量符号，指定 中某个特定元素 中每个 元函数符号，指定 到 的某个函数 中的每个 元谓词符号，指定 到 的某个特定谓词 任意解释 ，谓词公式 的真值全为真则称 为永真公式；如果全为假则称 为永假公式；如果存在至少一个为真称为可满足公式 设 是谓词公式，如果谓词公式 是永真公式，那么 是等价的，记为 3.3 谓词公式的标准型——前束范式 具有形式 形式的谓词公式称为前束范式，其中 为量词 ， 为不含量词的公式 设公式 是一个前束合取范式，按照从左到右去掉 中的存在量词，若 是存在量词且 ，则直接用个体变量取代 中所有的 ，并在 中删去 ，若 都是全称量词，则在 中使用一个未使用过的函数符号如 ，并用 替换 中所有的 ，然后删去 。重复此过程直到没有存在量词。这样得到的公式称为 Skolem 范式 3.4 谓词逻辑的推理理论 在谓词公式 中，若 不自由出现在量词 的辖域中，则称 对于 是自由的 推理规则 UI：全称量词消去 取代 的新变元在新公式中是自由出现的 EI：存在量词消去 如果 中还有出 以外的自由变元，需要用这些变元的函数符号来取代 UG：全称量词引入 对 自由才可以引入 EG：存在量词引入 取代 的 在原公式中不曾出现过 推理定律 如果需要使用 UI 和 EI 规则并且选用的个体常量是同一个符号，则必须先使用 EI 规则再使用 UI 规则 第四章 二元关系 4.1 二元关系及其表示 由两个元素 按照一定次序组成的二元组称为有序偶对，简称序偶，记作 设 是两个集合，称集合 为集合 的笛卡尔积 设 是 个集合，称集合 为集合 的笛卡尔积 当 时，可记 设 为两个非空集合，称 的任意子集 为从 到 的一个二元关系，简称关系，记作 。如果 ，则称 为 上的一个二元关系，记作 序偶 ，可记作 ，读作“ 对 有关系 ” 当 时，称 为空关系 当 时，称 为全关系 当 时，称 为 上的恒等关系 设 是 个集合，称 的子集 为以 为基的 元关系 有 ，此时 称为 的前域， 称为 的后域， 称为 的定义域，记作 ， 称为 的值域，记作 ， 称为 的域 设 ， 是从 到 的二元关系，称矩阵 为关系 的关系矩阵 如果 和 是两个 布尔矩阵，则布尔并也是 矩阵，记作 如果 和 是两个 布尔矩阵，则布尔交也是 布尔矩阵，记作 如果 和 是两个 布尔矩阵，则布尔积也是 布尔矩阵，记作 4.2 关系的运算 设 是三个集合 ，则 与 的复合关系（合成关系）是从 到 的关系，记为 ，其中 符号 表示复合运算 设 是两个集合，，则从 到 的关系 称为 的逆关系，符号 表示逆运算 设 ，则 的 次幂 记为 ，定义如下 4.3 关系的性质 设 是 上的关系 关系性质 集合表示 关系图 自反性 中每个节点都有自环 反自反性 中每个节点都没有自环 对称性 图中两点间只有方向相反的两条边或者无边 反对称性 图中任意一对节点间至多有一条边 传递性 中任何两个不同的节点之间如果有一条路径则必定有一条边 绝对不能脱离基集讨论关系的性质 关系性质的保守性 是自反的，则 也是自反的 是反自反的，则 也是反自反的 是对称的，则 也是对称的 是反对称的，则 也是反对称的 是传递的，则 也是传递的 4.4 关系的闭包 在给定关系中添加最少元素使其具有需要的特殊性质被称为求关系的闭包 自反闭包，对称闭包，传递闭包被记作 ，若 ，则 第五章 特殊关系 5.1 相容关系 设 是定义在非空集合 上的关系，如果 是自反的，对称的，则称 为 上的相容关系 给定非空集合 ，设有集合 ，如果 且 则 被称作集合 的一个覆盖 5.2 等价关系 设 是定义在非空集合 上的关系，如果 是自反的，对称的和传递的，则称 为 上的等价关系 给定非空集合 ，设有集合 ，如果 且 则 被称作集合 的一个划分，而 叫做这个划分的块或类 由等价关系产生的划分被称为集合 上关于 的商集，划分中的每一块被称为等价类 设 是非空集合 上的等价关系，对 ，称集合 为 关于 的等价类，或叫做 关于 生成的等价类，其中 称为 的生成元（代表元或典型元） 设 是非空集合 上的等价关系，由 确定的一切等价类构成的集合称为 上关于 的商集，记为 ，即 设 是非空集合 上的等价关系，则 对 的商集 是 的一个划分，称此划分为由 导出的等价划分 给定非空集合 的一个划分 设 则 是 上的等价关系，称此关系 是由划分 所导出的等价关系 5.3 次序关系 设 是定义在非空集合 上的关系，如果 是反自反的，反对称的和传递的，则称 为 上的拟序关系，简称拟序，记作 ，并将 记为 。序偶 称为拟序集 一个关系具有反自反性和传递性，意味着它一定有反对称性 设 是定义在非空集合 上的关系，如果 是反自反的和传递的，则称 为 上的拟序关系 设 是定义在非空集合 上的关系，如果 是自反的，反对称的和传递的，则称 为 上的偏序关系，简称偏序，记作 ，并将 记为 。序偶 称为偏序集 对于偏序关系，哈斯图的画法： 去掉关系图中所有的自环 对 将 画在 的下方且在图中去掉该边的箭头 对 ，且 之间不存在 使得 ，则 之间连一条边 设 是偏序集， 是 的非空子集 如果 则称 为 的最大元素，简称最大元 如果 则称 为 的最小元素，简称最小元 如果 则称 为 的极大元素，简称极大元 如果 则称 为 的极小元素，简称极小元 设 是偏序集， 是 的任何一个子集 如果 则称 为 的上界 如果 则称 为 的下界 令 是的上界，则称 的最小元为 的最小上界或上确界，记作 令 是的下界，则称 的最大元为 的最大下界或下确界，记作 设 是一个偏序集关系，若 ，总有 或 之一成立，则称关系 为全序关系或者线序关系，简称全序或者线序。称 为全序集或者线序集，或者链 设 是一个偏序集关系，若 的任何一个非空子集都有最校园，则称 为良序关系，简称良序，此时 称为良序集 良序 全序 偏序 有限全序集一定是良序集 5.4 函数 设 是集合 到 的关系，如果对每个 ，都存在唯一 使得 ，则称关系 为 到 的函数或映射，记为 。 为函数的定义域，记为 为函数的值域，记为 当 时，通常记为 ，此时称 为函数 的自变量（原像），称 为 在 下的函数值（像） 设 是从集合 到 的函数 如果 ，则称 为从 到 的单射或一对一映射 如果 则称 为从 到 的满射 如果 既是单射又是满射，则称 为从 到 的双射或一一映射 如果 ，则称 为 上的函数；当 上的函数 是双射时，称 为变换 设 和 是两个函数，如果 与 的符合关系 是从 到 的函数，则称 为函数 和 的复合函数 设 ，如果 是从 到 的函数，则称 是函数 的逆函数 设 是有限集合，从 到 的双射函数称为 上的置换或排列，记为 ， 称为置换的阶 第六章 图 6.1 图的基本概念 一个图是一个序偶 ，记为 是有限非空集合， 称为结点，简称点， 称为结点集 是有限集合，称为边集。 中的每个元素都有 中的结点对与之对应，称之为边 若边 与无序结点对 对应，则称 为无向边，这时称 为边的两个端点，也称结点 与边 是彼此相关联的 若边 与序偶 对应，则称 为有向边（弧），这时称 为边的始点（弧尾），称 为边的终点（弧头），统称为 的端点 对于一个图 ，将其记为 并写出 的集合表示，这称为图的集合表示，画图则称为图的图形表示 设图 且结点已经有了从 到 的次序，则 阶方阵 称为 的**邻接矩阵，其中 设图 1. 设 用 表示从 中去掉边 得到的图，即 ，该操作称为删除边。又设 ，用 表示从 中删除 中所有边得到的图，即 ，该操作称为删除边集 2. 设 ，用 表示从 中去掉结点 及 关联的所有边得到的图，即 关联，该操作称为删除结点。又设 ，用 表示从 中去掉 中所有结点及关联的所有边得到的图，即 关联，该操作称为删除结点子集。 3. 设 ，用 表示从 中删除 ，将 的两个端点 用一个新的结点 代替，使 关联 以外 关联的所有边，该操作称为边的收缩。一个图 可以收缩为图 ，是指 可以从 经过若干次边的收缩而得到 4. 设 ，用 表示在 之间加一条边，该操作称为加新边 图 中，若两个结点 是 的端点，则称它们互为邻接点 具有公共结点的两条边称为邻接边 两个端点相同的边称为环或自回路 图中不与任何结点相邻接的结点称为孤立结点 仅由孤立结点组成的图称为零图 仅含一个结点的零图称为平凡图 含有 个结点 条边的图称为 图 每条边都是无向边的图称为无向图 每条边都是有向边的图称为有向图 有有向边也有无向边的图的图称为混合图 在有向图中，两结点间（包括结点自身）若有同始点同终点的几条边，则这几条边称为平行边 在无向图中，两结点间（包括结点自身）若几条边，则这几条边称为平行边 两结点 间相互平行的边的条数称为边 的重数 含有平行边的图称为多重图，非多重图称为线图，无环的线图称为简单图 赋权图 是一个三元组 或四元组 其中 是点集， 是边集， 是 到非负实数集合的函数， 是 到非负实数集合的函数 设有图 和 若 则称 是 的子图，记为 若 且 则称 是 的真子图，记为 若 则称 是 的生成子图 若 以 为节点集，两个端点均在 中的边为边集的 的子图称为 导出的 子图，简称 的导出子图 设 为一个具有 个结点的无向简单图，如果 中任意两个节点间都有边相连，则称 为无向完全图，简称完全图，记为 设 为一个具有 个结点的有向简单图，如果 中任意两个节点间都有方向相反的两条边相连，则称 为有向完全图，简称完全图，记为 设 为简单图， 为完全图，则称 为 的补图，记为 6.2 握手定理 图 中以 为端点的边数（有环算两次）称为结点 的度数，简称度，记为 有向图 中以 为始点的边数称为结点 的出数，记为 ，以 为终点的边数称为结点 的入数，记为 度数为 的点称为悬挂结点，以悬挂节点为端点的边称为悬挂边 图论的基本定理（握手定理） 图中结点度数和等于边数的 倍，即 推论： 图中度数为奇数的点的个数为偶数 有向图中各节点的出度之和等于入读之和等于边数 设 ，称 为 的度数序列 6.3 图的同构 设有图 和 ，若存在双射函数 ，使 当且仅当 并且重数相同，则称 与 同构，记为 6.4 通路与回路 设有图 中结点和边相继交错出现的序列 若 中 两端点是 ，则称 为结点 到 的通路， 称为始点， 称为终点，统称为贿赂的端点。 称为通路的长度，当 时，此通路称为回路 若通路中所有边互不相同，则称为简单通路（迹） 若回路中所有边互不相同，则称为简单回路（闭迹） 若通路中所有结点互不相同，则称为基本通路，初级通路、路径 若回路中除头尾所有结点互不相同，则称为基本回路，初级回路、圈 到 长度 的通路数目可以通过邻接矩阵幂计算 如果 到 存在通路则称 到 可达的 如果 到 可达，则称 到 的长度最短的通路为短程线，其长度称为 到 的距离 设有线图 且结点已经有了从 到 的次序，称 阶方阵 为 的可达性矩阵，其中 到可达否则 设有线图 ， 分别是 的邻接矩阵和可达性矩阵，则有 其中 表示 的布尔积 次幂 6.5 图的连通性 若无向图 中任何两个结点都是可达的，则称 是连通图，反之为非连通图（或分离图） 无向图 中节点之间的可达关系定义如下 到可达 则 是 上的等价关系 无向图 中节点之间的可达关系 的每个等价类导出的子图都称为 的一个连通分支。 表示 中的连通分支个数 设有向图 1. 略去所有边的方向得到无向图 ，如果 是连通图则称 是连通图或弱连通图，否则为非连通图 2. 若 中任何一对结点直接至少有一个到另一个是可达的，则称 是单向连通图 3. 若 中任何一对节点都相互可达，则称 是强连通图 能找到一条经过所有节点的回路，则是强连通图 能找到一条经过所有节点的通路，则是单向连通图 在有向图 中，设 是 的子图，若 1. 是强联通图（单向连通图、弱连通图） 2. ，若 ，则 不是强联通图（单向连通图、弱连通图） 则称 为 的强联通分支（单向连通分支、弱连通分支）或强分图（单向分图、弱分图） 第七章 特殊图 7.1 树 连通而不含回路的无向图称为无向树，简称树 树中度数为 的结点称为叶，度数大于 的结点称为分支点（内部节点） 每个连通分支都是树的无向图称为森林 平凡图称为平凡树 平凡树没有叶 给定图 ，若 的某个生成子图是树，则称之为 的生成树，记为 生成树上的边称为树枝 中不在 的边称为弦 的所有弦的集合称为生成树的补 给定连通赋权图 ，生成树 的每个数值所赋权值之和称为 的权，记为 中具有最小权的生成树称为 的最小生成树 7.2 根树 一个有向图略去所有边的方向后得到的无向图是一棵树则称之为有向树 一棵非平凡的有向树，如果恰有一个节点入度为 ，其他节点入度为 ，则称之为根数或外向树。 入度为 的点称为根 出度为 的点称为叶 入度为 出度不为 的点称为内点 内点和根统称为分支点 从根到任一结点 的通路长度称为 的层数，称层数相同的结点在同一层上 所有节点的层数中最大的称为根数的高 在跟树种，若 到 可达，则称 是 祖先， 是 的后代 若 是根数中的有向边，则称 是 父亲， 是 儿子 两个结点是同一结点的儿子，则彼此称兄弟 如果在根树中规定每一层上结点次序，则称有序树 设 为根树 若 的每个分支点都至多 个儿子，则称 为k元树（或 k叉树） 若 的每个分支点都恰有 个儿子，则称 为完全k元树 若 是完全k元树且每个叶结点的层数均为树高，则称 为满k叉树 若k元树有序，则称 为有序k元树 若完全k元树有序，则称 为有序完全k元树 若满k元树有序，则称 为有序满k元树 的任一结点及其所有后代导出的子图 称为 的以 为根的子树。有序2元树每个节点的两个儿子分别称为左儿子和右儿子。有序2元树的每个节点的两棵子树分别称为左子树和右子树 在完全k元树中，叶数为 ，分支点数为 ，则 根树的遍历 先根次序 中根次序 后根次序 根树转化为2元树 从根开始只保留最左边儿子，相邻弟弟变为右儿子 森林转化为2元树 每棵树转为2元树，然后一次将每棵2元树变为左边2元树根的子树 设 为长度 的符号串，则其子串 为其长度为 的前缀 7.3 欧拉图 设无孤立结点图 ，经过所有边一次且仅一次的通路（回路）称为欧拉通路（回路） 具有欧拉回路的图叫欧拉图 规定：平凡图为欧拉图 无向图找奇点 有向图找入度不等于出度的点 设 ，若 则称 为 的桥或割边 7.4 哈密顿图 经过图中每个节点一次且仅一次的通路（回路）称为哈密顿通路（回路） 存在哈密顿回路的图称为哈密顿图 对于哈密顿图 ，任意 对于存在哈密顿回路的无向图 （为必要条件而非充分条件，如彼得森图） 设 是 个点的简单无向图，若对任意两个不相邻的点 均有 则 中存在哈密顿通路 设 是 个点的简单无向图，若对任意两个不相邻的点 均有 则 中存在哈密顿回路 设 是 个点的简单无向图，若对任意 ，均有 则 是哈密顿图 （为充分条件而非必要条件，如六边形） 7.5 偶图 若无向图的点集能够划分为两个子集满足任意一条边的两个端点都不在同一集合，则称 为偶图，二部图，二分图， 为互补结点子集，通常纪为 在偶图 中，若 中每个节点都与 每个结点连一条边，则称 为完全偶图，完全二部图，完全二分图，记为 ，其中 判断偶图 找奇环 在偶图中， 若存在 的子集 ，其中 是 个不同的 中的结点，则称 为 到 的一个完全匹配，简称匹配 存在匹配的必要条件是 霍尔定理（婚姻定理） 偶图中存在 到 的充要条件是 中任意 个结点至少与 中的 个结点相邻接 条件通常称为相异性条件 t条件（充分非必要） 中每个节点至少关联 条边 中每个节点至多关联 条边 即找 中最小度数和 中最大度数即可 7.6 平面图 各边在非结点上交叉称为交叉点，相交的边称为交叉边 若能吧一个无向图 所有节点和边画在平面上，使得任意两边除公共结点为没有其他交叉点，则称 为平面图，否则为非平面图 没有交叉边的图形称为平面图的平面表示 对于平面图 的一个平面表示 由边所包围的内部不含图的结点和边的区域称为 的一个面 保卫盖面的诸边所构成的回路称为这个面的边界 面 的边界的长度称为该面的次数，记为 区域面积有限的的称为有限面，反之称为无限面 图中所有面的次数之和等于边数的两倍 欧拉公式 对于联通平面图， 个结点， 条边和 个面，则 对于一个简单连通平面图，若 ，则 若每个面的次数至少为 ，则 库拉托夫斯基定理 一个图是平面图的充要条件是其任何子图都不可能收缩为 或","categories":[{"name":"离散数学","slug":"离散数学","permalink":"https://20021123.xyz/categories/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"微积分 第八章 无穷级数","slug":"微积分-第八章-无穷级数","date":"2022-06-20T16:10:41.000Z","updated":"2022-07-12T18:30:32.000Z","comments":true,"path":"2022/06/21/微积分-第八章-无穷级数/","link":"","permalink":"https://20021123.xyz/2022/06/21/%E5%BE%AE%E7%A7%AF%E5%88%86-%E7%AC%AC%E5%85%AB%E7%AB%A0-%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0/","excerpt":"","text":"第八章 无穷级数 8.1 常数项级数的概念与性质 一、引言 一个数可以由无穷个数相加得到，但无穷个数相加却不一定能等于一个确定的数 但有限个数相加却一定是一个确定的数 即有限时成立的结论在无限时不一定成立，因为从有限到无限发生了质的变化 二、常数项级数的概念 级数的定义：给定数列 则有这个数列构成的表达式 称为 无穷级数，简称 级数，记为 每一项都是常数的级数 称为 常数项级数 每一项都是函数的级数 称为 函数项级数 称级数 的前 项和 为级数的 部分和 为 的部分和数列 定义2 当 无限增大时，如果级数 的部分和数列 有极限 ，即 ，则称级数 收敛，并称 为该级数的 和，记为 ，反之称该级数发散 当级数 收敛时，则 余项 显然 三、基本性质 性质1 若级数 收敛，则 也收敛 注：级数的每一项同乘一个非零的常数，敛散性不变 性质2 设两收敛级数 ，则级数 收敛，其和为 注：收敛级数 可以逐项相加与逐项相减 性质3 在级数 的前面去掉或加上有限项，不改变其敛散性 性质4 收敛级数 加括弧后形成的级数仍然收敛于原来的和 注：收敛级数去掉括弧所形成的级数不一定收敛 性质5 设级数 收敛，则 注： 如果级数的一般项不趋于零，则级数发散 必要条件不充分，如调和级数发散 8.2 常数项级数的判别法 一、正项级数及其审敛法 定义 如果级数 中各项均有 ，这种级数称为正项级数 定义 正项级数 收敛 部分和数列 有上界 1. 比较判敛法 定理 设 和 都是正项级数，且 ，则 若 收敛，则 收敛 若 发散，则 发散 推论1 给定级数 和 ，且存在正整数 和正数 ，使得 ，则 若 收敛，则 收敛 若 发散，则 发散 定理3 设 和 都是正项级数，若 则 同时发散或收敛 若 且 收敛则 收敛；若 且 发散则 发散 2. 比值判敛法 定理（达朗贝尔判别法） 设 是正项级数，若 则当 时级数收敛； 时级数发散； 时不确定 3. 根植判敛法 定理（柯西判别法） 设级数 正项级数， 则当 时级数收敛； 时级数发散； 时不确定 二、交错级数的判敛法 定义2 设 则称级数 或 是交错级数 定理6（莱布尼兹判敛法） 若交错级数 满足 则该级数收敛，且其和 ，其余项 的绝对值 三、绝对收敛和条件收敛 定义3 设 是任意实数，则级数 是任意项级数，其中各项绝对值所构成的级数 称为级数 的绝对值级数 定理7 若级数 收敛，则 也收敛 定义4 设 是任意项级数级数，若级数 收敛，则称级数 绝对收敛；若级数 收敛但 发散，则称 条件收敛 定理8（绝对收敛级数的可交换性） 绝对收敛级数不因改变想的位置二改变它的和 定理9（绝对收敛级数的成绩） 设级数 与 都是绝对收敛的，其和分别为 ，则它们的柯西乘积 对于条件收敛来说，定理 并不成立 8.3 幂级数 一、函数项级数的一般概念 定义1 给定一个区间上的函数列 则由该函数列构成的表达式 称为定义在区间 上的函数项级数 定义2 设 且级数 收敛，则称 是函数项级数 的收敛点；如果级数发散，则称 是函数项级数 的发散点。全体收敛点的集合称为函数项级数 的收敛域 二、幂级数及其收敛半径 定义3 形如 的函数项级数称为幂级数，其中 称为幂级数的系数 定理1（阿贝尔定理） 若幂级数 在点 收敛，则当 时，幂级数 绝对收敛；若 在 处发散，则 是幂级数 发散 推论 若幂级数 不是尽在一点 收敛也不是在整个数轴都收敛，则必定有一个完全确定的正数 存在，使得 当 时，幂级数 绝对收敛 当 时，幂级数 发散 当 时，不确定 满足推论的正数 称为幂级数 的收敛半径，对应的开区间 称为幂级数的收敛区间。求幂级数的收敛域则还需考虑区间两个端点的收敛性 定理2 设幂级数为 ，若 或 则有 当 时， 当 时， 当 时， 三、幂级数的运算性质 性质1 幂级数的和函数在收敛区间内连续 性质2 幂级数的和函数在收敛区间内可积，且对 有逐项积分公式 性质3 幂级数的和函数内有连续的导数，且对 有逐项求导公式 8.4 函数展开成幂级数 一、泰勒级数 幂级数 称为函数 在 的泰勒级数 特别地，当 时，幂级数 称为函数 的麦克劳林级数 定理1 设函数 在 的某个邻域 内具有任意阶导数，则函数 在该邻域内能展开成泰勒级数的充要条件是 的泰勒公式中的余项 满足 定理2 如果函数 在含 的区间 能展开成泰勒级数，则右端的幂级数是唯一的 二、函数展开成幂级数 1. 直接展开法 直接使用泰勒公式 2. 间接展开法 逐项求导与逐项积分 变量代换法 几个基本的幂级数展开式 四则运算法 8.5 幂级数的应用 不考 8.6 傅里叶级数 一、三角级数 二、三角函数系的正交性 称之为三角函数系 三角函数系在 上正交即三角函数系中任意两个不同的函数乘积在区间 上的积分为零 三、欧拉-傅里叶系数公式 如果上述公式的积分都存在，这时就定出了三角级数的系数 ，它们称为 的傅里叶系数。具有傅里叶系数的三角级数称为函数 的傅里叶级数，记为 四、傅里叶级数的收敛问题 定理（狄利克雷收敛定理） 设 是以 为周期的周期函数，如果其在区间 上连续或只有有限个第一类间断点，并且只有有限个极值点，则其傅里叶级数收敛，并且有 当 是函数 的连续点时，有 当 是函数 的间断点时，有 若函数只在 上有定义且满足狄利克雷定理的条件，可以在 或 外补充 的定义使其成为以 为周期的周期函数 ，这种拓广定义域的方法成为周期延拓 8.7 正弦级数与余弦级数 一、奇偶函数的傅里叶级数 奇函数 偶函数 $$ b_n=0 \\ a_n={-}^f(x)nxdx ={0}^f(x)nxdx (n=0,1,2,) $$ 二、函数展开成正弦级数与余弦级数 将只在 上有定义的函数 补充函数在 上的定义，使其成为奇函数（若 规定 ）或偶函数在做周期延拓，这种方法成为奇延拓或偶延拓 8.8 任意周期函数的傅里叶级数 一、周期为 的周期函数的傅里叶级数 定理1 设周期为 的周期函数 在 上满足地理课类收敛定理的条件，则其傅里叶展开式为","categories":[{"name":"微积分","slug":"微积分","permalink":"https://20021123.xyz/categories/%E5%BE%AE%E7%A7%AF%E5%88%86/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"微积分 第七章 多元向量值函数积分学","slug":"微积分-第七章-多元向量值函数积分学","date":"2022-06-20T16:10:07.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2022/06/21/微积分-第七章-多元向量值函数积分学/","link":"","permalink":"https://20021123.xyz/2022/06/21/%E5%BE%AE%E7%A7%AF%E5%88%86-%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%A4%9A%E5%85%83%E5%90%91%E9%87%8F%E5%80%BC%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/","excerpt":"","text":"第七章 多元向量值函数积分学 7.1 第二类曲线积分 一、第二类曲线积分的概念与性质 定义 设 为 面内从 到 的一条有向光滑曲线弧，函数 在 上有界，用 上的点 把 分成 个有向小弧段，设 ，点 为 上任意取定的点，若当各小弧段长度的最大值 时， 的极限存在，则称此极限为函数 在有向曲线弧 上对坐标 的曲线积分（或称第二类曲线积分） 记作 记 ，则 若 为闭曲线则记为 性质 如果把 分为 和 ，则 设 是有向曲线弧， 是与 方向相反的有向曲线弧，则 即对坐标的曲线积分与曲线的方向有关 二、第二类曲线积分的计算 定理 设 在曲线弧 上有定义且连续， 的参数方程为 当参数 单调地由 变到 时，点 从 的起点 沿 运动到终点 ， 在以 为端点的闭区间上具有一份连续导数，且 ，则曲线积分 存在，且 三、两类曲线积分之间的关系 设有向平面曲线弧为 ， 上点 处的切向量 的方向角为 ，则 7.2 第二类曲面积分 一、有向曲面 若点在曲面上任意连续移动，其法向量也随之连续变化，当点再回到原来的位置时，其法向量的指向不变，称这样的曲面为双侧曲面 对于一个给定的双侧曲面，曲面的侧可通过曲面上单位法向量的指向来确定，曲面上任一点处的单位法向量有两个方向，选定一个方向，即取定曲面上的法向量都指向同一侧，这样就确定了曲面的侧，这种确定了侧的曲面称为有向曲面，例如，对于曲面 ，我们可以用单位法向量确定曲面的上策或下册 曲面 在点 处的法向量 为 因此，曲面的上侧或下侧可用一下单位法向量来确定 上侧 下侧 我们规定在曲面上任一点处的曲面面积微元：其方向与指定一侧的单位法向量 一致，其大小为曲面面积微元 ，即 二、第二类曲面积分的概念与性质 定义 设 为一光滑的有向曲面，指定它的一侧。设向量值函数 在曲面上有界，将曲面 任意划分成 个有向小曲面 ，在每个有向小曲面 上任取一点 ，作点积 其中 是曲面在点 处指向给定一侧的单位法向量，如果无论曲面 如何划分，点 如何选取，当所有小曲面的直径的最大值 时，上述和式存在且为同一常数，则称此极限值为向量值函数 在有向曲面 上的第二类曲面积分，记为 上式右端就是第二类曲面积分的坐标形式，因此第二类曲面积分又被称为对坐标的曲面积分 通常将向量值函数 在有向曲面 上的第二类曲面积分称为函数 对曲面 的通量 性质 设 为两个常数，则 若用 表示有向曲面 的另一侧，则 若将有向曲面 分为两块曲面 ，且 与 同侧，则 三、第二类曲面积分的计算 分面投影法 合一投影法 前面已知在曲面 上任一点处指向上侧的法向量为 ，单位法向量为 根据两类曲面积分的联系与第一类曲面积分的计算公式，有 $$ $$ 上下侧方向与正负号的问题只需乘上对应的单位法向量方向即可，无需额外符号 7.3 微积分基本定理的推广 一、格林公式 设 为平面区域，如果 内任意闭曲线所围成的部分都属于 ，则称 为单连通区域，否则称为复连通区域 对平面区域 的边界曲线 ，我们规定当人沿 行进时， 内在他近处的那一部分总在其左边.根据此规定，单连通区域边界曲线 的正方向为逆时针方向，二内边界曲线 的正方向为顺时针方向 定理1（格林公式） 设 是由分段光滑的曲线 围成的平面单连通区域，函数 在 上具有一阶连续偏导数，则有 其中 是 的取正方向的边界曲线 设 是由分段光滑的曲线 围成的平面复连通区域，函数 在 ​ 上具有一节连续偏导数，则有 其中 是 的取正方向的外（内）边界曲线 格林公式的简单运用 在格林公式中，令 ，就可得到一个用第二类曲线积分计算平面闭区域 面积 的公式 二、高斯公式 定理2（高斯公式） 设空间区域 是由分片光滑的闭曲面 所围成，函数 在 上具有一节连续偏导数，则有 其中 是 的边界曲面的外侧 三、斯托克斯公式 定理3（斯托克斯公式） 设 为分段光滑的空间有向闭曲线， 为以 为边界的分片光滑的有向曲面.函数 在包含曲面 在内的一个空间区域内有一节连续偏导数，则 其中 的方向与 的侧符合右手定则，即用右手四指表示 的方向，大拇指的方向与曲面 的侧同向 为了便于记忆，斯托克斯公式又常写为 $$ $$ 7.4 曲线积分与路径的无关性 一、曲线积分与路径无关的条件 定理1 设 为平面上的单连通区域，函数 在 上有一阶连续偏导数，则下列四个命题等价 对于 内任一光滑的简单闭曲线 ，有 曲线积分 的值在 内与路径无关 被积表达式 在 内是某个二元函数 的全微分，即 在 内每一点都满足 如果函数 在单连通区域 内具有一节连续偏导数，且 ，根据定理1， 是 内某个函数 的全微分，这时我们称 为 的原函数，与定积分的牛顿-莱布尼茨公式类似，有 空间一维单连通区域的定义 设 是空间某区域，若对该区域内任意一条闭曲线 ，都能作出以 为边界且全部位于该区域的曲面，称之为空间一维单连通区域 定理2 设 为空间一维单连通区域，函数 在 内有一节连续偏导数，则下列四个命题等价 对于 内任一光滑的简单闭曲线 ，有 曲线积分 的值在 内与路径无关 被积表达式 在 内是某个三元函数 的全微分，即 在 内每一点都满足 即 与平面情况类似，我们称函数 为 的原函数，其积分路径可选取平行坐标轴的折线，则 二、全微分方程 对于一个如下形式的一阶常微分方程 如果存在某个函数 使得 则称此方程为全微分方程 如果 是微分方程的解，那么有 所以 ，这表明 是由方程 所确定的隐函数 如果方程式全微分方程，则其通解为 ，其中 为任意常数 有时方程 不是全微分方程，但如果存在连续可微函数 ，使 为全微分方程，则称函数 为方程的一个积分因子 7.5 场论初步 一、场的概念 如果在全部空间或部分空间的每一点，都对应着某个物理量的一个确定的值，那么就成这空间内确定了该物理量的场 如果这物理量是数量，就称此场为数量场，如温度场、密度场、电位场 如果这物理量是向量，就称此场为向量场，如力场、速度场 在空间引入坐标系后，一个与时间无关的数量场可以用一个数量值函数 来表示，一个与时间无关的向量场可以用一个向量值函数函数 来表示 需要注意的是，场及场论中有关概念的固有含义与坐标系的选取无关，引入坐标只是为了便于用数学方法研究其性质 函数 的梯度 就是一个向量场，它是由数量场 产生的一个向量场，也称为梯度场 二、通量与散度 给定义向量场 为场内某有向曲面， 上指定一侧的单位法向量为 ，向量场 沿曲面 的第二类曲面积分 称为向量场 通过有向曲面 指定一侧的通量 如果 是一分片光滑的闭曲面， 为外法向量， 为 所包围的空间区域，由高斯公式有 将 称为向量场 的散度，记为 ，即 于是高斯公式可写成如下的向量形式 散度是一个数量，它是由向量场 产生的数量场，称为散度场 散度 表示速度场 在 出“源头”的强度，如果 ，称此点为”源“；如果 ，称此点为”汇“；如果 ，则称向量场 为无源场 由这一共识可看出，散度与坐标轴的选取是无关的. 由高斯公式可知，在无源场 中任一闭曲面的通量为零，即 三、环量与旋度 给定义向量场 设 为场内一有向闭曲线， 上与指定方向一致的单位切向量为 ，则曲线积分 称为向量场 沿有向闭曲线 的环量 设 是以 为边界的有向曲面，曲线 的方向与曲面 的侧符合右手规则，有斯托克斯公式有 向量 称为向量场 的旋度，记为 ，即 于是可将斯托克斯公式写成如下形式 旋度是一个向量，它是由向量场 产生的向量场，称为旋度场 当 ，即沿任意闭曲线的环量为零时，称 为无旋场，此时流体流动时不形成旋涡 四、几种特殊的向量场 如果向量场内第二类曲线积分只与起点和终点有关而与积分路径无关，这种场称为保守场 一个场为保守场的充要条件是该向量场为无旋场，同时我们还知道必存在函数 使得 即 因此有 此时函数 称为向量场 的势函数，向量场 称为有势场，其为函数 的梯度场 向量微分算子 ，即哈密顿算子 其运算法则是：对于数量值函数 ，有 对于向量值函数 利用算子 可将梯度写成 ，散度写成 ，旋度写成 ，从而可将高斯公式与斯托克斯公式表示成更简单的形式，即 若向量场 既是无源场又是无旋场，即 则称向量场 为调和场 因为调和场 是无旋场，所以也是有势场，及存在势函数 ，使 又因为 是无源场，所以有 即 上式称为拉普拉斯方程， 称为拉普拉斯算子.因此，调和场的势函数必满足拉普拉斯方程","categories":[{"name":"微积分","slug":"微积分","permalink":"https://20021123.xyz/categories/%E5%BE%AE%E7%A7%AF%E5%88%86/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"微积分 第六章 多元数量值函数积分学","slug":"微积分-第六章-多元数量值函数积分学","date":"2022-06-20T16:09:35.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2022/06/21/微积分-第六章-多元数量值函数积分学/","link":"","permalink":"https://20021123.xyz/2022/06/21/%E5%BE%AE%E7%A7%AF%E5%88%86-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%A4%9A%E5%85%83%E6%95%B0%E9%87%8F%E5%80%BC%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/","excerpt":"","text":"第六章 多元数量值函数积分学 6.1 多元数量值函数积分的概念和性质 一、物体的质量 平面薄片的质量 计算面密度为连续函数 的平面薄片 的质量 分割 近似 作极限 其中 为所有小区域的最大直径 空间物体的质量 计算体密度为连续函数 的空间区域 的质量 空间曲线的质量 计算线密度为连续函数 的曲线 的质量 物体的质量分布在一块曲面 上 设面密度为 ，在 上连续且点 二、多元数量值函数积分的概念 定义 设 为有界闭区域的几何形体且 可以度量，设有界函数 ，将 任意分割成 个小块 ， 也表示每块的度量，任取一点 ，作 ，令 为 个小块的最大直径，当 时，若 存在，称函数 在 上可积，记为 ：称为积分区域 ：称为被积表达式或积分微元 注 当 为几何形体 的密度函数时，其质量是 当被积函数 时， 就是几何形体 的度量 当 在 上连续时，函数 在 上必可积 三、不同几何形体 上积分的表达式 设几何形体 是一平面区域 ，在 上的积分称为二重积分，记为 在直角坐标系下用平行于坐标轴的直线来划分区域 ，面积元素为 设几何形体 是一空间区域 ，那么在 上的积分就称为三重积分，记为 在直角坐标系中，如果用平行于坐标面的平面来划分 ，体积元素为 设几何形体 为第一条平面或空间曲线 ，那么在 上的积分就称为第一类曲线积分或对弧长的曲线积分 记为 或 如果 是闭曲线，常记为 或 设几何形体 为一曲面 ，那么在 上的积分就称为第一类曲面积分或对面积的曲面积分 记为 如果 是闭曲面，常记为 四、积分的性质 注：以下性质的证明于定积分的证明完全类似 性质1 函数的和（或差）的积分等于各个函数积分的和（或茶），即 性质2 或闭区域 可分为两个闭区域 且 无公共内点则 性质3 如果在 上满足 ，则 特别地，由于 故有不等式 性质4 设 是 在闭几何形体 上的最小最大值，则 的度量的度量 性质5 设 在闭几何形体 上连续，则存在 使得 的度量 6.2 二重积分的计算 一、二重积分的几何意义 以 面上的闭区域 为底面，以 的边界曲线为准线，母线平行于 轴的柱面为侧面，以曲面 为顶的以空间立体的体积 二、直角坐标系下计算二重积分 如果区域 可以表示为 ，其中 在 上连续 先对 后对 的二次积分通常记为 确定积分顺序时，应注意积分区域 为X-型的特点 结论：对于二重积分 ，积分区域 关于 轴对称 若 是关于 的奇函数，则 若 是关于 的偶函数，则 上 三、在极坐标中的计算 由二重积分的定义可知 现在用一族同心圆 以及从极点出发的一族射线， 将 划分为任意的 个小闭区域 当 与 充分小时，忽略高阶无穷小量 有 又因为 得 令 ，得 注：面积元素 四、二重积分换元法 设 在 上闭区域 内连续，变换 ，且雅可比行列式 则有 在极坐标变换 下 五、无界区域上的反常二重积分 设 是 平面上的无界区域， 是 内任一有界子区域，函数 在 上有界，在 上的二重积分存在；让 以任一方式无限扩展为 ，如果极限 存在，则称函数 在无界区域 上的反常二重积分 收敛，并称该极限值为反常二重积分的值，即 反之则发散 定理2 设函数 在无界区域 上有定义且 ，则反常二重积分 收敛的充要条件是 内存在有界子区域 ，当 时有 其中 为常数，此时成无且区域上的反常二重积分 收敛于 6.3 三重积分的计算 6.4 第一类曲线积分的计算 一、曲线的弧长 直角坐标系下曲线弧微分与弧长的计算 设曲线弧 ，其中 在 上有一阶连续导数，取积分变量为 ，在 上人去小区间 以对应小切线段的长代替小弧段的长 小切线段的长 弧长元素 推广：空间曲线弧长的计算公式 设其参数方程为 其中 在 上有连续导数 则空间曲线的弧长公式为 二、第一类曲线积分的计算 定理 设 在曲线弧上连续 的参数方程为 其中 在 上有一阶连续导数，则 6.5 第一类曲面积分的计算 6.6 积分在物理上的应用 一、质心 二、转动惯量 三、引力","categories":[{"name":"微积分","slug":"微积分","permalink":"https://20021123.xyz/categories/%E5%BE%AE%E7%A7%AF%E5%88%86/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"微积分 第五章 多元函数微分学","slug":"微积分-第五章-多元函数微分学","date":"2022-06-20T16:08:48.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2022/06/21/微积分-第五章-多元函数微分学/","link":"","permalink":"https://20021123.xyz/2022/06/21/%E5%BE%AE%E7%A7%AF%E5%88%86-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/","excerpt":"","text":"第五章 多元函数微分学 5.1 多元函数 一、邻域 设点 集合 或 称为点 的 邻域 若点 不包含在该邻域内，则称该邻域为点 的空心邻域，记为 二、内点、外点、边界点、聚点 内点 设 是平面点集，如果存在 的某一邻域 ，则称 为 的内点 边界点 如果点 的任一邻域既有属于 的点，也有不属于 的点（点 本身可以属于 也可以不属于），则称 为 的边界点 即 外点 设 ，并且存在 的某一邻域使 ，则称 为 的外点 边界 的边界点的集合称为 的边界 聚点 如果在点 的任何邻域 总含有 中非 的点，则称点 是 的一个聚点 即 点集 的聚点可以属于 ，也可以不属于 例： 中 是聚点但不属于集合 例： 边界上的点都是聚点也都属于集合 三、区域 开集 设 是平面点集，如果点集 中每一个点都是 的内点，则称 为开集 区域 设 是开集，如果对于 中任何两点都可用折线连结起来且折线上的点都属于 ，则称开集 是联通的开集，联通的开集称为区域或开区域 开区域连同其边界称为闭区域 有界区域 对一个区域 ，如果 ，使得 内任何点到原点的距离都小于 ，则称这个区域为有界闭区域 否则成这个区域为无界闭区域 在 为空间 中的推广 （1）两点间的距离 设两点 则 （2）邻域的概念 邻域： 类似地，可以定义 维空间 中的内点、外点、区域点等 四、多元函数的概念 定义1 设 ， 为是书记，若 的映射，即 ，则称 为定义在 上的二元函数 记为 ，其中 为自变量， 为因变量， 为 的定义域记为 ， 为函数的至于，类似地可定义三元及三元以上函数，当 时， 元函数统称为多元函数 元函数简记为：，其中 当 时叫做一元函数 当 时分别叫做二元、三元函数 二元函数 的图像： 表示一张曲面，里 的图像表示旋转抛物面 五、等值线 的图像在 为一曲面，若在定义域 上满足 （常数）的点集： 是 平面上的曲线，则将此曲线称为二元函数的等值线 六、多元函数的极值 定义2 设函数 的定义域为 ， 为 的聚点，，若存在常数 时的 当 时有 成立，则称 为函数 当 时的极限，记为 或 （二重极限） 注意区分二次极限： 或 定义3 设 元函数 的定义域为 ， 为 的聚点，若存在常数 使得 ，当 时，有 ，则称 为 元函数 当 时的极限（又称 重极限） 证明多元函数极限不存在，选择不同路径，极限值不相等即可 例： 令 和 例： 多元函数极限计算往往借助一元函数极限的各种公式，但不能直接应用 七、多元函数的连续性 定义4 设二元函数 的定义域 ， 是 的聚点且 ，若 则称 在 处连续 定义5 设 原函数 的定义域为 ， 为其聚点且 ，如果 则称 元函数 在 连续 设 是函数 定义域的聚点，如果 在 不连续则称 是 的间断点 二次函数间断点可以是孤立的点或一条或几条曲线 如果 在开区域（或闭区域） 内每一点都连续，则称函数 在 内连续，或成 是 内的连续函数 多元函数的连续性及运算法则与一元函数有类似的结果 一切多元初等函数在其定义区域内都是连续的 有界闭区域上多元连续函数的性质 最大和最小值定理 有界闭区域 上的多元连续函数，如果在 上取得两个不同的函数值 ， 为介于 之间的任意数值，则至少存在点 使得 推论 如果 是连续函数 在有界闭区域 上的最小值和最大值 之间的一个数则至少存在点 使得 5.2 偏导数 设函数 ，令 暂时固定， 取得改变量 ，则过点 的水平直线上得一点 ，此时，函数的增量称为函数关于 的偏增量，记为 ，关于 的偏增量，记为 一、偏导数的概念 定义 设函数 在点 的某一领域内有定义，当 固定与 而 在 处有增量 时，相应地函数有偏增量 如果 存在，则称此函数为函数 在点 处对 的偏导数，记为 ，， 或 同理可定义函数 对 的偏导函数，记为 ，， 或 偏导数定义的本质上是导数！！！ 如果函数 在区域 内任一点 处对 的偏导数都存在，那么这个偏导数就是 的函数，称为函数 对自变量 的偏导函数，记作 ，， 或 同理可定义函数 对自变量 的偏导函数，记作 ，， 或 二、函数的偏导数与函数连续性的关系 一元函数可导必连续 多元时，偏导数存在未必连续 例： 在 不连续但关于 偏导均存在 三、偏导数的几何意义 在 中，固定 是一个变量 的函数，从几何上看它是曲面 和平面 相交形成的一条曲线 偏导数 就是一元函数 在 的导数，故 表示这条曲线 在点 处的切线 对 轴的斜率，及 四、高阶偏导数 设 在 内的两个偏导数 均存在，它们都是 的函数，如果这两个函数的偏导数也存在，则称这些偏导数是函数 的二阶偏导数 $$ $$ 后两项称为混合偏导 二阶混合偏导数相等的充分条件：偏导数连续 定理 若二元函数 的两个二阶混合偏导数 在点 处连续，则 同理， 的所有三阶偏导数都连续时有 5.3 全微分及其应用 一、全微分的概念 设 在 内有定义， 则成这两点的函数值之差为函数在点 对应于自变量增量 的全增量，记作 ，即 定义 如果全增量 可表示为 其中 是两个仅与点 有关而与 无关的常数，， 是 时关于 的高阶无穷小，则称 在 可微， 的线性主部 称为函数 在 的全微分，记为 ，又可记为 如果 在 内每点都可微，则称函数在 内可微 二、可微的性质 定理1 如果函数 在点 处可微，则该函数在点 处两个偏导数必存在且 定理2 若函数 在点 处可微，则该函数在 处必连续 两个均为 在 可微的必要非充分条件 例： 函数 在 处的两个偏导数存在但不连续故一定不可微 例： 在 连续且两个偏导数都存在但不可微 三、可微的充分条件 定理3 设函数 的两个偏导数 在点 的某领域内存在，且在 处连续，则函数在点 可微 四、全微分在近似计算中的应用 近似计算 误差分析 和、差的绝对误差不大于绝对误差的和，积、商的相对误差不大于相对误差的和 1234graph TD; 偏导数连续--&gt;可微; 可微--&gt;偏导数存在; 可微--&gt;函数连续; 5.4 多元复合函数的求导法则 一、复合函数求导的链式法则 定理 设 在点 处的偏导数均存在，函数 在对应的点 可微，则复合函数 在点 的偏导数 均存在，且有链式法则 几种情况的分析 中间变量多于两个的时候 设 ，则 其余类似 中间变量只有一个的情况 设 ，，则 自变量只有一个时的情况 设 则 是 的一元复合函数，它对 的导数称为全导数，有 设 则 二、一阶全微分形式的不变性 设 可微，若 都是自变量则 如果 不是自变量而是中间变量 ，仍有 由定义 其中 这一性质称为一阶全微分形式不变性 注：高阶微分形式不具有不变性 三、复合函数的高阶偏导数 引进符号 表示对第一个中间变量 求偏导数 表示对第二个中间变量 求偏导数 表示对第一个中间变量 求偏导数，再对第二个中间变量 求偏导数，以此类推 5.5 隐函数求导法 一、一个方程的情形 定理1 设函数 满足 在 的某领域内有连续偏导数 则 在 的某领域内能惟一确定一个单值连续的函数 满足 ，且 定理2 设函数 满足 在 的某领域内有连续偏导数 则 在 的某领域内能惟一确定一个单值连续的函数 满足 ，且 二、方程组的情形 由 的偏导数组成的（雅可比）行列式 定理3 设函数 满足 在 的某领域内有各个变量的连续偏导数 设方程组 在点 的某一邻域能唯一确定一组单值连续的函数 满足 且有连续偏导数 两边对 求偏导得 其中要求分母 5.6 偏导数在几何上的应用 一、空间曲线的切线与法平面（线线面） 空间曲线由参数方程表示的情况 设空间曲线方程 中的 对 均可导 如果 都在 上连续且 , 称这样的曲线为光滑曲线 曲线在 处的切线方程 切向量（切线的方向向量） 法平面：过 点且与切线垂直的平面 空间曲线方程为 如果 满足方程组隐函数存在定理的条件，则可唯一确定一组连续可微的函数 ，表明曲面 确定了一条光滑的曲线 ，其方程为 ，于是曲线 在 的切向量为 二、空间曲面的切平面和法线（面面线） 空间曲面由隐式给出的情形 设曲面方程为 在曲面上任取一条过点 的曲线 曲线在 的切向量 显然 将方程两边对 求导， 代入 得 引入向量 则上面的方程可表示为 这表面曲面上过 点的任一曲线在该店的切向量 都与向量 垂直，所以这些切向量应该在同一平面上，称为曲面在 的切平面 切平面方程为 如果曲面具有连续转动的切平面，也就是 上均连续，称此曲面为光滑曲面 过 且与切平面垂直的直线，称为曲面在 的法线 方程为 曲面由显函数给出的情形 空间曲面方程为 另 曲面在 的切平面方程为 曲面在 的法线方程为 全微分的几何意义 函数 在点 的全微分，在几何上表示曲面 在点 处的切平面上竖坐标 的改变量 5.7 方向导数与梯度 一、方向导数 定义 函数的增量 与 两点间的距离 之比值，当 沿着 趋于 时，如果此比值的极限存在则称这极限为函数在点 沿方向 的方向导数，记为 方向导数与偏导数区别 方向导数： 全增量， 射线方向的变化率 单向 偏导数： 偏增量， 坐标轴方向的变化率，双向 方向导数的存在性与函数在该点的偏导数的存在性无关 例： 在 的方向导数 以及 方向导数为： 偏导数 所以 不存在 定理 如果函数 在 可微，则函数在该点沿任意方向 的方向导数都存在且有 其中 为 的方向余弦 二、梯度 设函数 在 可微，称向量 为 在 的梯度，记为 即 设 为 的单位向量则 函数 在点 沿 方向的方向导数等于 在 方向的投影 ，其中 为 与 的夹角 函数 在点 的所有的方向导数不会超过 的模 当 时， 达到最大，即当 的方向就是 的方向时， 最大即沿着梯度方向，函数的变化率最大，函数值增长最快 方向导数 的最大值为 当 时当 取负梯度方向 时方向导数达到最小值为 类似地，梯度的概念可以推到三元以上的函数 设 ，则 在 的梯度为 可简记为 5.8 二元函数的泰勒公式 定理1 二元函数在 的某领域内有连续的二阶偏导数， 为此领域内的任一点，则存在 使 5.9 多元函数的极值与最大（小）值 一、无条件极值 定义 设函数 在点 的某领域内有定义对于该领域内异于 的点 若满谁不等式 则成 是函数 的极大值 若满谁不等式 》 则成 是函数 的极小值 极大值极小值统称为极值 设函数 在点 具有偏导数，且在 处有极值，则他在该点的偏导数必然为零 类似于一元函数，凡能使一阶偏导数同时为 的点均称为函数的驻点 例 的 不是极值点但 点 是 的极小值点但 不存在 定理2 （极值的充分条件） 设函数 在点 的某领域连续有一阶和二阶连续的偏导数且 另 则函数 在 是否取得极值的条件如下 ，函数有极值 当 有极大值，当 有极小值 ，函数无极值 定理失效考虑其他方法 注：定理2是针对二元函数判定极值的充分而不是必要条件 求函数 极值的一般步骤 解方程组 求实数解，得驻点 对每个驻点 ，求出二阶偏导数的值 定出 的符号，再判定是否是极值 二、有界闭区域上的最大值和最小值 求 在有界闭区域 上的最大值与最小值的一般步骤 求出 在 内的所有驻点及驻点处的函数值 求出 在边界上的最大最小值 比较 1,2 中的函数值得 上的最大最小值 对于实际问题若由于问题的性质 最大（小）值一定在 内取得且 在 内只有一个驻点则该店处的函数值就是 在 上的最大（小）值 三、条件极值和拉格朗日乘数法 极值问题 无条件极值 对自变量只有定义域的限制 有条件极值 对自变量除了定义域外还有其他极值 例 求 在条件 下的极值问题 称为目标函数 称为约束条件 从条件 中解出 代入 中得到 转化为一元函数 的无条件极值问题 构造函数 求出 对 的偏导数并使其为零 从中解出 及 ，则 就是可能的极值点。 称为拉格朗日函数， 称为拉格朗日乘数，此方法为拉格朗日乘数法","categories":[{"name":"微积分","slug":"微积分","permalink":"https://20021123.xyz/categories/%E5%BE%AE%E7%A7%AF%E5%88%86/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"微积分 第四章 常微分方程","slug":"微积分-第四章-常微分方程","date":"2022-06-20T16:08:03.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2022/06/21/微积分-第四章-常微分方程/","link":"","permalink":"https://20021123.xyz/2022/06/21/%E5%BE%AE%E7%A7%AF%E5%88%86-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/","excerpt":"","text":"第四章 常微分方程 4.1 微分方程的基本概念 含有未知函数的导数或微分的方程称为微分方程 未知函数是一元函数的称为常微分方程；未知函数是多元函数的称为偏微分方程 微分方程中出现的未知函数的最高阶导数的阶数称为微分方程的阶 一般地， 阶微分方程有如下形式 如果微分方程的左端为未知函数 及它的各阶导数的一次有理整式，则称该方程为 阶线性方程，它的一般形式是 其中 和 都是 的已知函数 如果函数 满足微分方程则称函数 为该微分方程的解，如果微分方程中含有任意常数且其中独立的任意常数的个数和微分方程的阶数相同，则称为微分方程的通解 阶微分方程的的通解含有 个独立的任意常数，其一般形式为 其中 为相互独立的任意常数，若上式表示为 则称为微分方程的显式解，否则称为隐式解或通积分 为确定某一具体运动过程的任意常数，通常会提出一些条件来确定通解中的任意常数，这种附加条件称为定解条件，最常见的是反映运动初始状态的定解条件，称为初始条件。一般 解微分方程的初始条件有 个，就是对于某个自变量 ，给定未知函数及其从一阶到 阶导数的值，即 微分方程的不含任意常数的解称为特解，一般可利用初始条件由通解确定出其中的任意常数后得到 求微分方程满足初始条件的特解问题称为初值问题 微分方程的解的曲线称为积分曲线，含有任意常数的通解的曲线称为积分曲线族 4.2 一阶微分方程 一阶微分方程的典则形式 一阶微分方程的对称形式 一、可分离变量的方程 形如 的方程称为可分离变量的微分方程 若 ，则可将方程改写为 其中 表示 的原函数， 表示 的原函数 且 的根 也是方程的解 二、齐次方程 若函数 对任意 满足 则称 为 次齐次函数，当 时为零次齐次函数或齐次函数，若 为齐次函数，领 有 如果一阶微分方程 中的 为齐次函数，则称微分方程 为齐次方程 如果 有根 ，则 也是原齐次方程的解 三、一阶线性方程 1. 一阶线性方程 若 则称为一阶齐次线性微分方程，若 则称为一阶非齐次线性微分方程 为求一阶线性非齐次方程的通解，先求其对应的一阶其次线性方程的通解，得 推得一阶非齐次线性方程的通解为 2. 伯努利方程 形如 的方程称为伯努利方程，当 时该方程是一阶线性方程；当 时该方程是可分离变量的微分方程 当 时该方程可以通过变换 转化为一阶线性微分方程，事实上，以 除以方程两端 4.3 可降阶的高阶方程 一、 型 积分 次即可 二、 型 做代换 ，则 ，有 4.4 二阶齐次线性方程 一、二阶齐次线性方程解的结构与性质 二阶齐次线性方程的一般形式为 其中 仅为 的函数 定理1 若函数 与 是二阶齐次线性方程 的两个特解，则 定理2 设 均不为零，则 和 线性相关的充要条件是两个函数之比恒等于一个常数 定理3 若函数 与 是二阶齐次线性方程 的两个线性无关的特解，那么 就是方程 的通解，其中 为任意常数 二、二阶常系数齐次线性微分方程的解法 在二阶齐次线性方程中，若 其中 为实常数，则方程变为 令 所以得 代数方程 称为微分方程 的特征方程，这种方法叫做欧拉待定指数函数法 当 时，微分方程的通解 当 时，微分方程的通解 当 时，特征方程的共轭复根为 ，微分方程的通解 用特征方程求二阶常系数齐次线性方程通解的方法可以推广到高阶 特征方程的根 微分方程通解中的对应项 单实根 给出一项 一对单复根 给出二项 重实根 给出 项 一对 重复根 给出 项 4.5 二阶非齐次线性方程 一、二阶非齐次线性方程解的结构与性质 二阶非齐次线性方程的一般形式为 二、二阶常系数非齐次线性方程的解法 若 则二阶常系数非齐次线性方程 具有形如 的特解，其中 为与 次数相同的多项式，而 按 不是特征方程的根，是单根，是重根依次取 其中 是常数， 是 的 次多项式，则其特解有形式 其中 是系数待定的 次多项式，，而 视 不是，是特征方程的根而取 三、欧拉方程 不会","categories":[{"name":"微积分","slug":"微积分","permalink":"https://20021123.xyz/categories/%E5%BE%AE%E7%A7%AF%E5%88%86/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"微积分 第三章 一元函数积分学","slug":"微积分-第三章-一元函数积分学","date":"2022-06-20T16:07:10.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2022/06/21/微积分-第三章-一元函数积分学/","link":"","permalink":"https://20021123.xyz/2022/06/21/%E5%BE%AE%E7%A7%AF%E5%88%86-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6/","excerpt":"","text":"第三章 一元函数积分学 3.1 定积分的概念和性质 一、引例 设函数 在区间 上非负、连续、由曲线 即直线 所组成的图形曲边梯形 分割 近似 求和 取极限 二、定义 定义 设函数 在 上有界，在 中任意插入 个分点： 把 分成 个小区间 ，每个小区间长度依次记作 ，在们个 上任意取一点 ，作乘积，记 无论 或 怎么选取，和 总趋近于确定的常数 ，则称函数 在 上可积，并称此极限 为函数 在 上的定积分，记为 叫积分区间 被积变量 被积函数 被积表达式 积分和 说明 当函数 在区间 上的定积分存在时，称 在区间 上可积，有界是可积的必要条件 定义中区间的分法和 的取法是任意的 积分值仅与被积函数和积分区间有关，而与积分变量用什么符号的字母表示无关 定义中 不能换成 （因为不一定是均分） 用 语言定义为 若 在 上有界，若存在常数 ，，如果不论对 的任意分法及 在 上的任意取法，只要 就有 则称 为 在 上的定积分，记为 定积分是一个数 三、存在定理 定理1 若函数 在 上连续，则 在区间 上可积 定理2 若函数 在区间 上有界，且只有有限个第一类间断点，则 在区间 上可积 四、定积分的几何意义 ，曲边梯形的面积 ，曲边梯形的面积的负值 的几何意义 它是介于 轴、函数 得到图形及两条直线 之间的各部分面积的代数和 在 轴上方的面积取正号，在 轴下方的面积取负 五、定积分的性质 规定 性质1 性质2 性质3 性质4 性质5 如果在区间 上 ，则 ，（） 推论1 如果在区间 上 则 ，（） 即 性质6 设 及 是函数 在 上的最大最小值，则 性质7 如果函数 在闭区间 连续，则至少存在一点 使得 3.2 微积分学基本定理 一、问题引入 设指点以速度 沿直线运动， 在 上连续且 ，求质点在 内的路程 一方面，由定积分的定义知 另一方面，若一直物体运动的路程 则这段路程可表示为 一般地，若 则 二、积分上限函数 设函数 且 为 上的一点，考察定积分 如果上限 在区间 上任意变动，则对于每个取定的 ，定积分有一个对应值，所以它在 上定义了一个函数，称为积分上限函数，记为 定理1 如果 在 上连续，则积分上限函数 在 上可导，且其导数为 证明 由积分中值定理得 称 为 在 上的一个原函数 定理2 若 ，则 在 上必有原函数 三、牛顿——莱布尼兹公式 定理3 如果 是连续函数 在区间 上的原函数，则 ，则 定理3称为微积分基本定理，上述公式称为牛顿——莱布尼兹公式，它是微积分学中的基本公式，通常将 记为 3.3 不定积分的概念和性质 一、不定积分的概念 定义 若在区间 内， 是函数 的一个原函数，则 的所有原函数的一边表达式 （ 为任意常数）称为 的不定积分，记为 ，即 被积函数 被积表达式 积分变量 积分符号 二、不定积分的性质 性质1 性质2 积分基本公式 3.4 换元积分法 一、第一换元法 定理1 设 具有原函数， 可导，则有换元公式 第一类换元公式（凑微分法） 求 二、第二换元法 思想方法 改变中间变量的设置方法 定理2 设 是单调可导函数，且 ，又设 有反函数，则有换元公式 其中 为 的反函数 注1 三角代换的目的是化掉根式 ，可令 ，可令 ，可令 注2 积分中为了化掉根式是否一定采用三角代换并不是绝对的，需要根据被积函数的情况来定 说明3 当分母/的次数较高时，可采用倒代换 说明4 当被积函数含有两种及以上的根式时 时，可采用 ， 定积分的换元积分法 定理 假设 函数 ，在 上单值且有连续导数 当 在区间 上变化时， 的值在 上变化，且 则有 3.5 分部积分法 一、不定积分的分部积分法 定理1 设函数 和 都有连续导数，则有 称为不定积分的分部积分公式 被积函数具有 时可将 看作 （因为 容易求得原函数，同时使用一次分部积分公式后 降低一次幂 被积函数具有 时均令 ，虽然会使 升幂，但可以尽快去掉不易积分的对数函数或反三角函数 如果分部积分计算过程中又出现了所求的积分，则可以移项求出 有时可以将被积函数拆项，对其中一项分部积分后使不易求出或不能求出的积分相互抵消 二、定积分的分部积分法 定理2 设函数 ，则 $$ $$ 3.6 有理函数的积分 一、有理函数的积分 有理函数：两个实系数多项式的商所表示的函数 其中 都是非负整数， 及 都是实数，且 假定分子分母之间没有公因式 ，这有理函数叫真分式 ，这有理函数叫假分式 任意假分式可以化成一个多项式和一个真分式的和 任意真分式都可以分解为若干个最简分式的和 代数学基本定理：每个次数大于等于 的实系数多项式在实数遇上可以唯一分解成一次因式和二次不可约因式的乘积 结论 分母中若有因式 ，则分解后为 其中 都是常数，特殊的： 分解后 分母中若有因式 ，其中 ，则分解后 其中 都是常数，特殊的： 分解后为 二、三角函数有理式的积分 做变换 ，可将积分 化为 的有理函数的积分，事实上 所以 当三角有理函数满足 时，可令 ，则 3.7 反常积分 一、无穷区间上的反常积分 定义1 设函数 在无穷区间 上连续，且 ，则极限 称为 在 上的反常积分，记为 ，即规定 如果上式右段的极限存在，则称反常积分 收敛，否则称其发散 为了方便，可以使用如下简记法 其中 是 在 上的一个原函数 同样可定义 在 的反常积分为 对于在 上的连续函数 ，则规定 在 上的反常积分为 如果上式右端两个反常积分都收敛则称反常积分 收敛，否则称其发散 二、无界函数的反常积分 定义2 设函数 在区间 上连续，在 的左邻域内无界，则极限 称为 在 上的反常积分，记为 ，即规定 如果上式右段的极限存在，则称反常积分 收敛，否则称其发散 其中 是 在 上的一个原函数，而 表示 同样可定义 在 上的反常积分为 对于在 上除点 外连续，在 的某邻域内无界的连续函数 ，则规定 上的反常积分为 如果上式右端两个反常积分都收敛则称反常积分 收敛，否则称其发散 三、 函数与 函数 1. 函数 反常积分 在数学和其他学科中都有广泛的应用。对于每个正实数，可以证明这个积分都是收敛的，由此所确定的函数称为 函数，记为 而且， 在 是连续的 性质 特别地，当 为正整数时，有 2. 函数 在应用和理论上时常遇到含两个参数 的反常积分 在 和 时是常义积分，当 或 时则是无界函数的反常积分 可以证明其收敛，于是当 时上述积分有确定的值，确定了一个关于 的函数，称为 函数，记为 性质 （对称性） 特别地，当 时有 易混 当 时收敛， 时发散 当 时收敛， 时发散 四、总结 定义：定积分+极限 收敛的充要条件是极限存在 计算： 先求定积分，再求极限 难点：无界函数反常积分类型的判定即瑕点的确定 3.8 定积分的几何应用 一、微元法 在 上任取一小区间记为 求出相应于 的 的部分的近似值 其中 与部分两 之差是关于 的高阶无穷小 其次，以 被积式在 上作定积分得 的精确值 这种建立积分表达式的方法，称为微元法。 称为积分微元，简称微元 二、求平面图形的面积 直角坐标系下平面图形的面积 直角坐标系下曲线 及直线 所围平面图形的面积 面积微元是 所求面积是 极坐标系下平面图形的面积 曲线 及射线 所围成的曲边扇形的面积 面积微元是 面积是 三、求体积 求已知平面截面面积的立体体积 一立体过 轴上两点 所做的与 轴垂直的两平行平面之间，且过 上任一点 所做的垂直于 轴的平面与立体的体积的截面面积是 的已知连续函数 体积微元是 立体体积是 求旋转体的体积 连续曲线 及 轴围成的曲边梯形绕 轴一周的一旋转体，过 上任一点 做垂直于 轴的平面截此立体，截面面积为 得旋转体体积为 平面图形 绕 轴旋转一周所得的旋转体体积为 略去 的高阶无穷小 后，将 作为体积微元，即 旋转体体积为","categories":[{"name":"微积分","slug":"微积分","permalink":"https://20021123.xyz/categories/%E5%BE%AE%E7%A7%AF%E5%88%86/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"微积分 第二章 一元函数微分学","slug":"微积分-第二章-一元函数微分学","date":"2022-06-20T16:05:51.000Z","updated":"2022-07-12T18:25:30.000Z","comments":true,"path":"2022/06/21/微积分-第二章-一元函数微分学/","link":"","permalink":"https://20021123.xyz/2022/06/21/%E5%BE%AE%E7%A7%AF%E5%88%86-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6/","excerpt":"","text":"第二章 一元函数微分学 2.1 导数的概念 一、引例 1. 切线的斜率 割线的极限位置——切线 设 割线 的斜率 切线 的斜率为 2. 平均速度和瞬时速度问题 设一物体做变速直线运动，其运动规律为 其中 为物体在时刻 离开起点的位移 平均速度 瞬时速度 二、导数的定义 定义 设函数 在点 的某个领域 内有定义 如果 时， 极限存在，则称 在点 处可导，并称这个极限为函数 在点 处的导数，记为 或 若 不存在，则称函数 在 处不可导，若 为方便记为 如果函数 在开区间 内每点处都可导则称 在开区间 内可导，记为 对于任一 ，都对应着 的一个确定的导数值，则称此函数为原来函数 的导函数，记作 左、右导数 左导数 右导数 函数 在点 可导 、 均存在且相等 如果 在开区间 内可导，且 都存在，就说 在闭区间 上可导 三、导数的计算 用定义求导数的步骤 求增量 算比值 求极限 求 的导函数 四、导数的几何意义 表示曲线 点在 出的切线斜率，即 （ 为倾角） 切线方程 五、函数可导与连续的关系 定理 （可导的必要条件） 设函数 在点 可导，则 在点 处必连续 2.2 导数的四则运算法则 一、和、差、积、商的求导法则 定理 如果函数 在点 处可导，则他们的和、差、积、商（分母不为零）在点 处也可导，并且 推论 只说了连续没说可导的函数求导时用到只能通过定义求解 二、反函数的导数 定理 如果函数 在某区间 内单调、可导且 ，则 例 求函数 的导数 在 内单调，可导 且 ， 在 内有 即 同理 三、复合函数的求导法则 定理 如果函数 在点 可导且 在点 可导，则复合函数 在点 可导，其导数为 注 基本初等函数的导数公式 函数和、差、积、商的求导法则 复合函数的求导法则 2.3 隐函数及参数函数的导数 一、隐函数的导数 关键：将方程两边同时对 求导，在求导过程中将 看成 的函数 ，再利用复合函数求导法则 对数求导法 求 二、参数式函数的导数 一般地，参数方程表示为 定理 若 均可导， 存在可导的反函数，，则由 确定的函数 可导，且有 三、相关变化率问题 某一般问题中有两个变量 和 ，它们之间有某种确定的依赖关系，可用 或 表示，如果变量 都是另一变量 的可导函数，则 和 之间两个相互依赖的变化率称为相关变化率 2.4 高阶导数 一、高阶导数的定义 如果导数 的导数 在 处可导，即 存在，则称 为函数 在点 处的二阶导数，记作 二阶导数的导数称为三阶导数 三阶导数的导数称为四阶导数， 一般地， 的 阶导数的导数称为 的 阶导数 二阶及以上阶数的导数统称为高阶导数 二、高阶导数求法举例 直接法：由高阶导数的定义逐步求高阶导数 注意：求 阶导数时，求出 阶后不要急于合并，分析结果的规律性写出 阶导 高阶导数的运算法则 ——莱布尼茨公式 间接法：设利用一致的高阶导数公式，通过四则运算、变量代换等方法，求出 阶导数 ， 指定阶数的导数 例 已知参数方程 ，证明 证 已知 ，有 2.5 函数的微分 一、微分的概念 的线性函数，且为 的主要部分 的高阶无穷小，当 很小时可忽略 定义 设函数 在 内有定义， 如果 成立（其中 是与 无关的函数），则称函数 在点 可微，且称 为函数 在点 相对应于自变量增量 的微分，记作 或 ，即 微分 叫做函数增量 的线性主部 二、微分的运算法则 微分的基本公式 微分的四则运算法则 三、微分形式的不变性 设函数 有导数 若 是自变量时， 若 ，且 可微， 则 ，， 结论：无论 是自变量还是中间变量，函数 的微分形式总是 四、函数的线性近似 函数 过切点 的切线方程为 于是，切线是线性函数 有微分的几何意义知 由此，称线性函数 位 在点 的线性近似 或称 在点 将 局部线性化 2.6 微分中值定理 一、费马定理（极值的必要条件） 若 在 处可导且 是 的一个极值点，则 二、罗尔中值定理 若 且 ，则 使得 三、拉格朗日中值定理 若 则 使得 推论1 若 ，且 恒有 则 在 上恒等于一个常数 ，即 推论2 如果 且 恒有 则在 内 推论3 若 ，且 存在（或为 ）则 同理可证 四、柯西中值定理 若 若 且 ，均有 ，则 使得 2.7 不定型的极限 一、 型及 型 定义 如果当 或 时，两个函数 与 都趋于零或趋于无穷大，那么 称为 （或 ）不定 型 定理 （洛必达法则）设 满足以下三个条件 在 点的某领域内（点 本身可以除外）， 及 都存在且 存在（或 ）那么 注意 洛必达法则是求未定式的一种有效方法，但与其他求极限方法结合使用效果更好 二、 型不定型解法 关键 将其他类型不定型转化为洛必达法则可解决的类型 型 步骤 ，或 型 取对 2.8 泰勒公式 一、泰勒（Taylor）中值定理 泰勒中值定理（皮亚诺型）如果函数 在 处 阶可导，则 其中 如果 在含有 的某个开区间 内可导，，其中 在 和 之间 如果 在含有 的某个开区间 内二阶可导，，其中 在 和 之间 泰勒中值定理 如果函数 在含有 的某开区间 内具有直到 阶导数，则当 时， 可以表示为 的一个 次多项式与一个余项 之和 其中 （ 在 与 之间） 证明 由假设 在 内具有直到 阶导数， 两函数 及 在 及以 为端点的区间上满足柯西中值定理的条件，得 两函数 及 在 及以 为端点的区间上满足柯西中值定理的条件，得 如此下去，经过 次后得到 证明2 构造辅助函数 注意到 且 ，由罗尔定理得 称为 按 的幂展开的 次近似多项式， 称为 按 的幂展开的 阶泰勒公式 拉格朗日型余项 （ 在 与 之间） 皮亚诺型余项 （补充）Cauchy 余项 （ 在 与 之间） 三点说明 当 时，泰勒公式变成拉氏中值公式 取 ，在 与 之间，令 则余项 麦克劳林（Maclaurin）公式 2.9 函数的单调性和极值 单调性 一、单调性的判别法 定理 设函数 在 上连续，在 内可导 若在 内 则函数 在 上单调增加 若在 内 则函数 在 上单调减少 注 定理条件是一个充分条件 有时函数 可在个别孤立点 处 其他点满足条件，也可以断定 的点调性 例如： 在 时 ，但 在 上单调增加 若函数在其定义域的某个区间内是单调的，则该区间称为该函数的单调区间 一阶导数为零或一阶导数不存在的点为单调区间可能的分界点 该定理对 成立 二、单调区间求法 用方程 的根及 不存在的点来划分函数 的定义区间 判断区间内导数的符号，从而确定 在该区间的单调性 三、利用单调性证明不等式 推论 设 在以 为断点的闭区间上连续，开区间上可导 当 时若 则 若 则 当 时若 则 若 则 函数极值的判定 一、极值的定义 定义1 设函数 在 内有定义， 若有 成立，就称 为 的一个极大值 若有 成立，就称 为 的一个极小值 函数 的极大值和极小值统称为最值 使得函数取得极值点点叫做极值点 定理2（函数极值的第一充分条件） 设 在临界点 连续，在 可导 如果 ，有 ，而 有 ，则 在 处取得极大值 如果 ，有 ，而 有 ，则 在 处取得极小值 定理3（第二充分条件） 设 在 处有二阶导数且 ，，则 当 时，函数 在 处取得极大值 当 时，函数 在 处取得极小值 定理4 若函数 在驻点 处的 阶导数存在，且 当 为偶数时， 在 处取得极值 当 时， 在 取得极小值 当 时， 在 取得极大值 当 为奇数时，点 不是 的极值 2.10 函数的凸性与曲线的拐点 一、函数凸性的定义 定义1 设 在区间 上连续，若曲线 上的任意两点间的弧段，总是位于连接这两点的弦之下，则称函数 在 内下凸；若曲线 上的任意两点间的弧段，总是位于连接这两点的弦之上，则称函数 在 内上凸；函数下凸或上凸的性质统称为函数的凸性 定义1‘ 设 若对 ， 且 ，若 则称 在 内下凸 若 则称 在 内上凸 在不等式中若 则分别有 二、函数凸性的判定 定理1 若 ，在 上二阶可导 若 ，则 在 内下凸 若 ，则 在 内上凸 定义2 设 在 的某邻域内连续，若 在 的左右两侧凸性相反，则称点 为曲线 的拐点 拐点的求法（拐点的费马定理） 定理2 若 在 内存在二阶导数，则称 是拐点的必要条件是 定理3 若 在 内二阶可导，，若在点 的两侧附近 异号，则点 为曲线 的拐点 2.11 函数作图 一、曲线的渐近线 定义 如果曲线上的懂点沿着曲线原理原点时，该店与某定直线的距离趋近于零，则称此定直线为曲线的渐近线 水平渐近线 如果曲线 的定义与是无穷区间，且 或 则直线 为曲线 的一条水平渐近线 垂直渐近线 如果曲线 ，有 或 则称直线 为曲线 的一条垂直渐近线 斜渐近线 对曲线 如果存在常数 使得 或 则直线 为曲线 的一条斜渐近线 二、图形描绘的步骤 确定函数 的定义域，对函数进行奇偶性、周期性、曲线与坐标轴交点等性质的讨论，求出函数的一阶导数 和二阶导数 求出方程 和 在函数定义域内全部实根，用这些根同函数的简短点或导数不存在的点把函数定义域划分成几个部分区间 确定在这些部分区间内 和 的符号，并由此确定函数的增减性与极值及曲线的凸性与拐点（可列表讨论） 确定函数图形的水平、垂直渐近线、斜渐近线及其他变化趋势 描出与方程 和 的根对应的曲线上的点，有时还需要补充一些点，再综合前四步讨论的结果画出函数的图形 2.12 函数的曲率 一、弧微分 曲线弧长的微分称为弧微分 设曲线 在区间 内具有连续导数，则称曲线 在区间 内为光滑曲线 直角坐标系下的弧微分 极坐标下的弧微分 二、曲率 单位弧段上切线转角的大小来表达弧段 表达弧段 的平均弯曲程度，把这个比值叫做弧段 的平均曲率 当 时，平均曲率的极限称为曲线在 点的曲率，记作 ，即 有些实际问题中， 同 比较起来很小（记为 ）可以忽略不计，此时由 可得曲率的近似公式 设曲线 在点 处的曲率为 ，在 处曲线的法线上，在凸的内侧取一点 ，使 ，称这个圆为曲线在点 的曲率圆；曲率圆的圆心 称为曲线在点 的曲率中心；曲率圆的半径 称为曲线在点 的曲率半径 曲线 在 处的曲率中心坐标 为 曲率圆方程","categories":[{"name":"微积分","slug":"微积分","permalink":"https://20021123.xyz/categories/%E5%BE%AE%E7%A7%AF%E5%88%86/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"微积分 第一章 函数 连续与极限","slug":"微积分-第一章-函数-连续与极限","date":"2022-06-20T16:04:13.000Z","updated":"2022-07-12T18:25:14.000Z","comments":true,"path":"2022/06/21/微积分-第一章-函数-连续与极限/","link":"","permalink":"https://20021123.xyz/2022/06/21/%E5%BE%AE%E7%A7%AF%E5%88%86-%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%87%BD%E6%95%B0-%E8%BF%9E%E7%BB%AD%E4%B8%8E%E6%9E%81%E9%99%90/","excerpt":"","text":"第一章 函数 连续与极限 1.1 集合与函数 一、概念 集合：特定性质，彼此区别的总体 元素：集合内的事物 二、集合的表示法 1.列举法：按任意顺序列出，花括号 2.描述法： 三、全集与空集 全集：所有对象的集合 空集：不含任何元素的集合 四、子集 集合 的任一元素都是 的元素称 为 的子集 空集是任意集合的子集 互为子集则相等 五、集合的运算 交集： 并集： 补集： 差集： 函数的几种简单性质 一、函数的有界性 若 有 成立，则称函数 在 上有界，否则称无界 二、函数的单调性 若 当 时恒有 成立，则称函数 在区间 是单调减少的 三、函数的奇偶性 设 关于原点对称，若 ， 有 则称 为偶函数 设 关于原点对称，若 ， 有 则称 为奇函数 任意定义域关于原点对称的函数均可拆成一个奇函数与一个偶函数的和 四、函数的周期性 设 ，若 ，使得 恒成立，则称 为周期函数 满足这个等式的最小正数 ，称为函数的周期 狄利克雷函数 周期为任意有理数故无最小正周期 反函数与复合函数 一、反函数 设 ，若 有一个确定的且满足 的 与之对应，其对应规则记作 ，这个定义在 上的函数 称为 的反函数，或称它们互为反函数 直接函数与反函数的图形关于直线 对称 二、复合函数 设 ，称 是由 ， 复合而成的函数， 称为中间变量， 为自变量 初等函数 一、基本初等函数 三角函数和反三角函数 二、初等函数 由基本初等函数经过有限次四则运算和有限次的函数复合步骤构成可用一个式子表示的函数，称为初等函数 是初等函数 双曲函数常用公式 和差化积 积化和差 1.2 极限的概念 一、数列的定义 按照一定顺序一次排成的无穷多个数 称为无穷数列，简称数列，其中每个数称为数列的项， 称为通项，数列记作 二、数列的简单性质 单调数列 对数列 ，若对 ，都有 则称 为（严格）单调增加（减少）数列 若对 ，都有 则称 为单调不减（不增）数列 有界性 对于数列 ，若 ，使 ，具有 ，则称 为有界数列，否则称为无界数列，即对 ，总 使 既有上界也下界的数列必有界 三、数列的极限 当 无限增大时， 无限接近 ，等价于 可以任意小 给定 ，只要 时，有 成立 如果对于 ，总存在一个正整数 ，当 时， 恒成立，则称当 趋于无穷大时，数列 以常数 为极限 记作 或 如果数列没有极限，就说数列是发散的 定义： 任意性，固定性 但不唯一 ，去掉或增加有限项不改变数列极限 等价于 几何解释：当 时，所有的点 都落在 内，只有有限个（至多 个）落在其外 是一个确定的常数 定义只能用来验证极限，不能计算极限 计算 的方法 利用不等式直接反解 ，然后取整 利用题目中给出的已知极限的 找到 对不等式进行合理的放缩再反解 ，找到 定理一 有界性 收敛的数列必定有界 推论：无界数列必定发散 定理二 唯一性 每个收敛的数列只有一个极限 证明：同一法；反证法 定理三 保号性 定理四 设且存在，则 注 且 存在 定理五 海涅定理 设极限存在则的所有子数列极限均存在，且 （一般用于判定极限不存在） 极限的运算性质 定理 设 均存在，则 注意 极限必须存在 分母不为零 只能求有限项的极限 函数的极限 一、当自变量趋于无穷大时函数的极限 时的情形 定义 设 时定义在 上的函数， 是常数，对于任意正数 总存在正数 ，使对于任何 都有 ，则称 为 趋于正无穷大时 的极限，记为 时的情形 时的情形 几何解释 当 或 时，函数 的图形完全落在以 为中心线，宽为 的带型区域时 二、自变量趋向有限值时函数的极限 表示 任意小 表示 过程中的某一时刻之后 体现 接近 程度 1. 定义 设函数 在 有定义，若对于任意给定的正数 总存在正数 使得对于适合不等式 的一切 ，对应的函数值 都满足不等式 ，则称常数 为函数 当 时的极限，记作 或 （当 时） 2. 几何解释 当 在 的去心 邻域时，函数 的图形完全落在以 为中心线，宽为 的带型区域时 3. 左右极限 例如 证明 从左侧无限趋近 ，记作 或 从右侧无限趋近 ，记作 或 左极限 使当 时恒有 记作 或 右极限 使当 时恒有 记作 或 定理： 三、函数极限的性质 1. 有界性 若在某个过程中 有极限，则存在过程的一个时刻，在此时刻以后 有界 2. 惟一性 若在 的变化过程中 的极限存在，则极限惟一 3. 不等式性质 局部保号性 若 ，且 （或 ）则 ，当 时，（或 ） 保序性 设 若 ，，有 ，则 4. 函数极限与数列极限的关系 设 在 的某去心邻域 有定义，则 的充要条件是 对任何以 为极限且含于此空心邻域的数列 都有 1.3 无穷小&amp;无穷大量 一、无穷小 1. 定义 极限为零的变量称为无穷小 零是无穷小 2. 无穷小与函数极限的关系 定理 其中 是当 时的无穷小 3. 无穷小的运算性质 定理2 有限个无穷小的代数和还是无穷小 定理3 有界函数与无穷小的乘积还是无穷小 在同一过程中，有极限的变量与无限小的乘积时无穷小 常数与无穷小的乘积时无穷小 有限个无穷小的乘积也是无穷小 二、无穷大 定义2 当 时有 成立，则称 当 时为无穷大，记为 三、无穷小与无穷大的关系 定理4 在同一过程中，无穷大的倒数为无穷小；恒不为零的无穷小的倒数为无穷大 ### 四、无穷小的比较 极限不同，反映了无穷小趋向于零的“快慢“程度不同 定义：设 是同一过程中的两个无穷小，且 如果 就说 是比 高阶的无穷小，记作 ； 如果 就说 是比 同阶的无穷小；特殊地 如果 ，则称 与 是等价的无穷小，记作 ； 常用等价无穷小 五、等价无穷小的替换 定理（等价无穷小替换定理） 设 且 或 ，则 推论 若 时 与 是等价无穷小，且 （或 ），则 （或 ） 用等价无穷小可给出函数的近似表达式 即 于是有 ，等量代换 例如： 1.4 极限与运算法则 一、极限运算法则 定理 设 则 （1） （2） （3），其中 常数因子可以提到极限记号外面 二、求极限方法举例 注意： 但 时 1.5 极限存在准则 两个重要极限 一、极限存在准则 1. 夹逼准则（迫敛性法则） 准则Ⅰ 如果当 时，有 那么 存在且等于 2. 单调有界准则 准则Ⅱ 单调有界数列必有极限 如果数列 满足条件 单调增加有上界 单调减少有下界 则有极限 二、两个重要极限 1.6 连续函数 一、函数的连续性 1. 函数的增量 设函数 在 内有定义，， 称为自变量在点 的增量， 称为函数 相应与 的增量 2. 连续的定义 定义1 设函数 在 内有定义，如果当自变量的增量 趋向于零时，对应的函数增量 也趋向于零，即 或 那么就称函数 在点 连续， 称为 的连续点 定义2 设函数 在 内有定义，如果函数 当 时的极限存在，且等于它在点 处对应的函数值 即 那么就称函数 在点 连续 定义3 ，使当 时，恒有 3. 左、右连续 若函数 在 内有定义，且 即 ，则称 在点 处左连续 若函数 在 内有定义，且 即 ，则称 在点 处右连续 定理 函数 在 处连续等价于函数 在 处同时左连续又右连续 4. 连续函数与连续区间 在 上每一点都连续的函数，叫做 上的连续函数，或者说函数在 上连续 如果函数在开区间 连续，并在在左端点 处右连续，在右端点 处左连续，则称函数 在闭区间 连续 表示在开区间 内全体连续函数构成的集合 如果函数 在开区间 内连续，记为 表示在闭区间 内全体连续函数构成的集合 如果函数 在闭区间 内连续，记为 连续函数的图像是一条连续而不间断的曲线 二、函数的间断点 函数 在点 连续必须满足的三个条件 在点 处有定义 存在 如果上述三个条件中只要有一个不满足，则称函数 在点 处不连续（间断），并称点 是 的不连续点（间断点） 间断点的分类 定义 若点 为 的间断点，但 在点 的左右极限均存在则称点 为 的第一类间断点，凡不是第一类间断点的间断点称为第二类间断点 第一类间断点又可以分为 可去型间断点：如果 在点 处的极限存在（），但 或 在点 处无定义，则称点 为函数 的第一类可去型间断点 跳跃型间断点：如果 在点 处的左、右都存在且不相等，则称点 为函数 的第一类跳跃型间断点 注意 可去间断点只要改变或者补充间断处函数的定义，即可将其改成连续点 第二类间断点： 在点 处的左右极限至少有一个不存在 有一侧极限为无穷大，称为第二类无穷型间断点 形如 称为第二类震荡型间断点 三、连续函数的四则运算 定理1 若函数 在点 处连续，则 ，， 在点 处也连续 例如 在 上连续，故 在其定义域连续 四、反函数与复合函数的连续性 定理2 单调连续函数的反函数必单调连续 定理3 若 ，函数 在点 连续，则有 定理4 设函数 在点 连续，且 ，而函数 在点 连续，则复合函数 在点 也连续 五、闭区间上连续函数的的性质 一、最大值和最小值定理 定义 对于在遇见 上有定义的函数 如果有，使得对于任一 都有 ，则称 是函数 在区间 上的最大（小）值 定理1（最大值和最小值定理） 在闭区间上连续的函数一定存在最大值和最小值 若 则 ，使得 有 ， 注意 若区间是开区间或区间内有间断点则不一定成立 定理2（有界型定理） 在闭区间上连续的函数一定在该区间上有界 二、介值定理 定理3（介值定理） 若 且 ，则 ，都 使得 推论1 若 ，最大值、最小值分别为 ，且 ，则 ， 使 推论2（零点存在定理） 设函数 在闭区间 上连续，且 与 异号，那么在开区间 内有函数 的一个零点，即至少有一点 使得 ，即方程 在 内至少存在一个实根","categories":[{"name":"微积分","slug":"微积分","permalink":"https://20021123.xyz/categories/%E5%BE%AE%E7%A7%AF%E5%88%86/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"LOJ2474","slug":"loj2474","date":"2020-04-26T04:00:00.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2020/04/26/loj2474/","link":"","permalink":"https://20021123.xyz/2020/04/26/loj2474/","excerpt":"","text":"LOJ2474 Description 对于一颗树 ，定义无向简单图 中上的两点 之间有边当且仅当 中 之间的路径上的所有点编号都小于 。 有一棵树 ，初始时只有一个点，编号为 ，接下来有 次操作，操作有以下两种： 表示加入一个编号为 的节点并与当前编号为 的节点相连（保证任何时刻不会有两个编号相同的节点）； 表示查询 中点 到 的最短路（每条边长度均为 ）。 请你回答所有查询。 Input 第一行两个整数 ，表示编号的最大可能值及询问个数。 接下来 行每行三个整数 ，以题目描述中的格式描述一次操作。 Output 依次对于每一个 类型的操作，输出一行一个整数表示其对应的答案。 Sample Input 12345678910117 101 1 21 2 31 3 51 5 62 1 61 1 42 1 61 1 72 1 62 3 6 Sample Output 12344322 Solution 假定读者已经大致看过论文和 zx2003 的博客了 重点就是两个函数：qry(x,y) 和 add(x,y) qry(x,y) 只需要分别找 到 LCA（或其祖先） 的最小步数和最后一步之前（即跳”最小步数 “步）的位置，再判断 能否一步到 即可 即实现一个 query(x,z) 函数返回 pair(step,point) 先求跳的步数，发现就是 C 中 到 或其祖先的路径上（不包括最后的 或其祖先）点权之和 ； 特殊的，如果在跳到 （及其祖先）之前最上面的点权为 ，则不用 ，相当于已经算过跳上去这一步的贡献 query.png 再求跳了最小步数 能跳到哪里，不难发现是跳到 （及其祖先）之前最上面的那一个 \"1\" 的前驱（如果 \"1\" 恰好是 （及其祖先）之前最上面的一个则忽略这个 \"1\" ，用第二个 \"1\" 来找前驱） 求 能否一步到 即判断在 C 上 是否能到达 ，即 向其含有 的子树内连的一条链的链底是否是 的子孙。 易得 连的链底就是 到 路径上离 最近的点，然后就可以 check 了 add(x,y) 先判掉 的情况，这时直接 C 中连一下且 F 中 否则 ， 会插入成 的祖先。C 中 会向 及其祖先连边直到 本身 到 在 C 中形成的链的一部分后缀的点的 F 中的 fa 会改为 需要把这条链上的点权都变成 同时可能会影响某些点权为 的点，需要把它们点权变为 并把他们 LCT 上的父亲改为指向它们的 F （具体见最后一部分） 特别注意这里的 access 每次不是跳 F 中的 fa 而是 C 中的 fa ！！！ （因为 C 中的 fa 不一定是 F 中的 fa，当点权为 时相当于跳了一大段 C 中的祖先） 然后把跳到 的链上的点的点权全变成 ，链顶点权设为 并接在 上 至于 在 C 及 F 上的父亲，可以发现和之前在 位置上的点（ 祖先中最大的编号小于 的点）相同。 关于 0 变 1 的处理 一种是从定义上，可以发现是 到其在 C 中的父亲所夹的连通块中的最大值，可以通过求连通块任意一点一直跳 fa 直到 之前的最后一点得到 一种是考虑特殊处理 LCT 上的链，若能保证每个链头点权都为 那么直接找 u 在 LCT 上的后继即可；（但这种 access 要多写一堆东西防止断边出现链头 ……） add 函数中特殊情况新建的链头以及 access 时断开的链的链头都会变 1； query 函数中 access 提取一条链时可能会断开一个链使得 作为链头，这时可以直接强行将其点权变为 ，即强行让其指向它 F 中的父亲 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497#include&lt;bits/stdc++.h&gt;#define FIO \"L2474\"#define ll long long#define pii std::pair&lt;int,int&gt;//#define DEBUGconst int N=1e5+5,Q=5e5+5,lgN=18;using namespace std;int premax,vis[N];int n,q,op[Q],u[Q],v[Q];struct Graph{ int h[N],to[N&lt;&lt;1],nxt[N&lt;&lt;1],ecnt; int fa[N]; int dfn[N],sz[N],cnt; inline void adde(int u,int v){nxt[++ecnt]=h[u];h[u]=ecnt;to[ecnt]=v;} inline void add(int u,int v){adde(u,v);adde(v,u);}}T,C;struct DSU{ int f[N]; inline void init(){ for(int i=1;i&lt;=n;i++)f[i]=i; } inline int find(int x){ while(x^f[x])x=f[x]=f[f[x]]; return x; } inline void merge(int x,int y){ if((x=find(x))==(y=find(y)))return; C.add(x,y); f[x]=y; }}U;int mx[N&lt;&lt;1][lgN],lg[N&lt;&lt;1];int dcnt,id[N];set&lt;int&gt;s[N];int top[N],mxs[N],cfa[N];inline void dfsC(int u,int fa=0){ C.dfn[u]=++C.cnt; C.sz[u]=1; mx[id[u]=++dcnt][0]=u; for(int i=C.h[u],v;i;i=C.nxt[i])if((v=C.to[i])^fa){ cfa[v]=u; dfsC(v,u); if(C.sz[v]&gt;C.sz[mxs[u]])mxs[u]=v; C.sz[u]+=C.sz[v]; mx[++dcnt][0]=u; }}inline void dfs2(int u,int tp){ top[u]=tp; if(mxs[u])dfs2(mxs[u],tp); for(int i=C.h[u],v;i;i=C.nxt[i])if((v=C.to[i])^cfa[u]&amp;&amp;v^mxs[u]) dfs2(v,v);}std::vector&lt;int&gt;son[N];inline int cmp(const int &amp;x,const int &amp;y){ return T.dfn[x]&lt;T.dfn[y];}inline void dfsT(int u,int fa=0){ T.dfn[u]=++T.cnt; T.sz[u]=1; for(int i=T.h[u],v;i;i=T.nxt[i])if((v=T.to[i])^fa){ T.fa[v]=u; dfsT(v,u); T.sz[u]+=T.sz[v]; son[u].push_back(v); }}inline int lca(int x,int y){ x=id[x];y=id[y]; if(x&gt;y)std::swap(x,y); int t=lg[y-x+1]; return std::max(mx[x][t],mx[y-(1&lt;&lt;t)+1][t]);}inline void init(){ U.init(); for(int u=1;u&lt;=n;u++){ for(int i=T.h[u],v;i;i=T.nxt[i])if((v=T.to[i])&lt;u){ U.merge(v,u); } } for(int i=n;i;i--)if(!id[i])dfsC(i); for(int i=n;i;i--)if(!top[i])dfs2(i,i); for(int i=1;i&lt;=n;i++)if(!T.dfn[i])dfsT(i); lg[0]=-1; for(int i=1;i&lt;=dcnt;i++)lg[i]=lg[i&gt;&gt;1]+1; for(int j=1;(1&lt;&lt;j)&lt;=dcnt;j++) for(int i=1;i+(1&lt;&lt;j)-1&lt;=dcnt;i++) mx[i][j]=std::max(mx[i][j-1],mx[i+(1&lt;&lt;(j-1))][j-1]);}int ch[N][2],fa[N];int w[N],sum[N];#define lx ch[x][0]#define rx ch[x][1]#define chk(x) ((x)==ch[fa[x]][1])#define isrt(x) (ch[fa[x]][0]!=x&amp;&amp;ch[fa[x]][1]!=x)inline void pushup(int x){ sum[x]=sum[lx]+w[x]+sum[rx];}inline void rotate(int x){ int y=fa[x],z=fa[y],t=chk(x); fa[ch[x][!t]]=y; ch[y][t]=ch[x][!t]; fa[x]=z; if(!isrt(y))ch[z][chk(y)]=x; ch[x][!t]=y; fa[y]=x; pushup(y); pushup(x);}/*inline void out_lct(){ for(int i=1;i&lt;=n;i++)if(vis[i]){ printf(\"%d:fa=%d ch=(%d,%d) w=%d s=%d\\n\",i,fa[i],ch[i][0],ch[i][1],w[i],sum[i]); } puts(\"\");}vector&lt;int&gt;STA;int tim,lst[N];inline void dfs(int x,int tim){ if(!x)return; lst[x]=tim; dfs(lx,tim); STA.push_back(x); dfs(rx,tim);}inline void checkGG(){ for(int i=1;i&lt;=n;i++)if((ch[i][0]&amp;&amp;i&gt;ch[i][0])||i&lt;ch[i][1]){ printf(\"GG in %d\\n\",i); cout.flush(); assert(i&lt;=ch[i][0]&amp;&amp;i&gt;=ch[i][1]); }}inline void out_C(){ for(int i=1;i&lt;=n;i++)if(vis[i]){ printf(\"%d:C.fa=%d\\n\",i,C.fa[i]); }}*/inline void splay(int x){ assert(x); for(int y=fa[x];!isrt(x);rotate(x),y=fa[x])if(!isrt(y)) rotate(chk(x)^chk(y)?x:y);}/*inline void checkorder(){ tim++; for(int i=1;i&lt;=n;i++)if(lst[i]!=tim){ STA.clear(); splay(i); dfs(i,tim); for(int i=1,sz=STA.size();i&lt;sz;i++){ if(STA[i]&gt;STA[i-1]){ out_lct(); printf(\"STA=\"); for(int i=0;i&lt;sz;i++) printf(\"%d \",STA[i]); puts(\"\"); } cout.flush(); assert(STA[i]&lt;=STA[i-1]); } }}*/inline int find_fir(int x){ while(lx)x=lx; return x;}inline int find_one(int x,int prefer){ if(!sum[x])assert(0); while(x){ if(sum[ch[x][prefer]])x=ch[x][prefer]; else if(w[x])return x; else x=ch[x][!prefer]; } assert(0);}inline int find_pre(int x){ splay(x); if(!lx)return fa[x]; x=lx; while(rx)x=rx; return x;}inline void link(int x,int y,int flag=1){ if(y)assert(x&lt;y); splay(x); if(y)splay(y); w[x]=1; pushup(x); if(flag&amp;&amp;y){ if(ch[y][1]){ int tmp=find_fir(ch[y][1]); fa[ch[y][1]]=0; splay(tmp); ch[y][1]=0; if(!w[tmp]){ link(tmp,find_pre(find_one(y,1)),0); } } ch[y][1]=x; pushup(y); } fa[x]=y;}inline int upper_floor(int x,int z){ int ret=x; while(x){ if(x&lt;z){ ret=x; x=lx; }else x=rx; } return ret;}inline pii query(int x,int z){ if(x==z)return pii(0,x); pii ret; ret.second=x; int y=0; while(x){ splay(x); if(rx){ int w=rx; rx=0; w=find_fir(w); pushup(x); if(!::w[w]){ splay(w); fa[w]=0; int tt=find_pre(find_one(x,1)); link(w,tt,0); } splay(x); } rx=y; pushup(x); if(!(fa[x]&amp;&amp;fa[x]&lt;z))break; y=x; x=fa[x]; } //printf(\"x=%d lower=%d\\n\",x,upper_floor(x,z)); splay(x); x=upper_floor(x,z); splay(x); ret.first=sum[rx]+1; if(sum[rx]) ret.second=find_pre(find_one(rx,0)); return ret;}inline bool in(int *dfn,int *sz,int x,int y){ return dfn[y]&lt;=dfn[x]&amp;&amp;dfn[x]&lt;dfn[y]+sz[y];}inline int get_down(int x,int y){ if(!in(T.dfn,T.sz,y,x))return T.fa[x]; assert(x^y); int z=*--upper_bound(son[x].begin(),son[x].end(),y,cmp); return z;}inline bool check(int x,int y){ if(x==y)return 1; cout.flush(); int z=get_down(y,x); return in(C.dfn,C.sz,z,x);}inline int qry(int x,int y){ //printf(\"------------\\nqry %d %d\\n\",x,y); int z=lca(x,y); pii a=query(x,z),b=query(y,z);#ifdef DEBUG printf(\"a=(%d,%d)\\n\",a.first,a.second); printf(\"b=(%d,%d)\\n\",b.first,b.second); printf(\"lca=%d\\n\",z);#endif return a.first+b.first+!(check(a.second,z)&amp;&amp;check(b.second,z));}inline int access(int x){ int y=0; while(x){ splay(x); if(rx){ int w=rx; rx=0; pushup(x); w=find_fir(w); if(!::w[w]){ splay(w); fa[w]=0; int tt=find_pre(find_one(x,1)); link(w,tt,0); } splay(x); } rx=y; pushup(x); if(!fa[x]||sum[x])break; y=x; x=fa[x]; } if(sum[x]) return find_one(x,1); else return find_fir(x);}inline int getson(int x,int y){ int ret=x; assert(x); while(top[x]^top[y]){ if(s[top[x]].size()) ret=*s[top[x]].rbegin(); x=cfa[top[x]]; } set&lt;int&gt;::iterator it=s[top[x]].lower_bound(y); if(it!=s[top[x]].begin()){ ret=*--it; } /* while(C.fa[x]&amp;&amp;C.fa[x]&lt;y){ x=C.fa[x]; if(vis[x])ret=x; } */ return ret;}inline void add(int x,int y){ if(x&gt;y){ link(y,x,0); C.fa[y]=x; s[top[y]].insert(y); return; } int z=getson(x,y); s[top[y]].insert(y); std::vector&lt;int&gt;v; int lstx=0; while(x){ v.push_back(x); x=access(x); int z=find_pre(x); if(z&gt;y){ v.pop_back(); break; } splay(x); lstx=x; fa[lx]=fa[x]; w[x]=fa[x]=lx=0; pushup(x); x=C.fa[x]; }#ifdef DEBUG printf(\"v={\"); for(int i=0,szv=v.size();i&lt;szv;i++)printf(\"%d,\",v[i]); puts(\"}\");#endif for(int i=0,szv=v.size();i&lt;szv-1;i++){ splay(v[i]); splay(v[i+1]); assert(!ch[v[i+1]][1]); ch[v[i+1]][1]=v[i]; fa[v[i]]=v[i+1]; pushup(v[i+1]); } if(v.size()) link(lstx,y,0); /* * !!! the same as { splay(v.back()); link(find_fir(v.back()),y,0); } */ C.fa[y]=C.fa[z]; C.fa[z]=y; if(!C.fa[y]){ return; } splay(z); //printf(\"Before add y to tree:(son=%d)\\n\",x); out_lct(); ch[y][0]=ch[z][0]; if(ch[z][0])fa[ch[z][0]]=y; ch[z][0]=y; fa[y]=z; w[y]=w[z]; w[z]=0; pushup(y); pushup(z);}int main(){ scanf(\"%d%d\",&amp;n,&amp;q); for(int i=1;i&lt;=q;i++){ scanf(\"%d%d%d\",&amp;op[i],&amp;u[i],&amp;v[i]); if(op[i]==1){ T.add(u[i],v[i]); } } vis[1]=1; init(); for(int i=1;i&lt;=q;i++){ if(op[i]==1){ premax=max(premax,v[i]); vis[v[i]]=1; add(u[i],v[i]); }else printf(\"%d\\n\",qry(u[i],v[i]));#ifdef DEBUG //out_lct(); out_C(); puts(\"===========\");#endif } return 0;}","categories":[{"name":"LOJ","slug":"LOJ","permalink":"https://20021123.xyz/categories/LOJ/"}],"tags":[{"name":"图论","slug":"图论","permalink":"https://20021123.xyz/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"LCT","slug":"LCT","permalink":"https://20021123.xyz/tags/LCT/"}]},{"title":"FFT&NTT","slug":"fft","date":"2020-02-18T14:08:01.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2020/02/18/fft/","link":"","permalink":"https://20021123.xyz/2020/02/18/fft/","excerpt":"","text":"FFT&amp;NTT FFT DFT 单位根定义 得到 单位根性质 令 得到 每一项系数 对第 个点值表示的贡献是 IDFT 把DFT的过程写成矩阵的形式 尝试得到左边矩阵（记为 ）的逆，精心构造得到： 发现若 所以得到 即 把IDFT的系数取倒数（即直接虚部取相反数）做一遍DFT再除以 即可 NTT 对于一个质数 ，其原根 满足 在模 意义下两两不同 所以 这就需要 是 的幂 所以 因为 且 所以 所以 看上去都没什么问题 所以 DFT 等操作的写法和 FFT 基本等价 HDU 6067 每次更改一个多项式的一项系数 对于其点值表示的影响可以顺次算出来 再算一个所有多项式的对应的 个点值表示，改了一个就先除去再修改再乘上即可 因为可能有 不能直接除要记录一下 的个数 最后求 不能每次都还原多项式算和可能常数太大，发现最后求的是一堆多项式的第 项和，直接记录点值和，最后再从这个点值反推回所有的多项式的和对应系数和即可 过了这题才发现一直以来的`NTT``的单位根都处理反了... 一开始以为NTT长度只用到 然而是每个数最多出现 次，NTT长度是 记得去掉第 位的答案，因为不存在只有 位的数字 这题模数小最好预处理逆元到 不然复杂度多个 可能过不了 cf286E 每个能表示出来的数一定能被至多两个数表示出来，否则假如只能由 表示，那么就一定不能表示 相当于这个集合对加法封闭 直接对集合里出现的数做集合幂级数再并上一个 即可 考虑每一位： 如果原来为 现在不为 那么这个集合不是封闭的输出NO 如果原来不为 现在为 不可能因为 次项是 如果原来为 现在也为 不影响 如果原来不为 现在也不为 那么看它的值是否是 是的话就只能是 和 凑出来，这个数就必选;否则一定有两个非零的和为 ，这个数可以被其他数表示出来所以不必选 BZOJ4836 二元运算 在值域上分治，每次直接算两遍左边卷右边的东西贡献到答案数组上 最后每次 出答案 cf553E Kyoya and Train 设 表示在时间 时点 到 所需要的最短路的期望 则 令后者为 即第 条边的东西 转移就成了 然后这个 的转移即为 是一个卷积的形式，直接分治 fft 就搞完了 然后记得当把 更新到 时的 数组要开 而不是 因为要把 对 的贡献全部算进去而不是只是 这样 注意边界的最小最大值各取什么，不要想着有clang++查错，一个边界的小问题可能卡半个多小时 BZOJ4451 Frightful Formula 这已经可以直接任意模数NTT做了，只是常数大 由于这题的形式特殊，尝试再推一些东西 令 则上面那个东西就是 边界是 后两项是类似的，以 为例 边界 得到 当 时有 同理 然后递推的时候直接 非常优质 cf958F 相当于求一堆 的积的某一项 直接分治FTT常数可能有点问题 改成启发式合并，用个堆维护当前最小的多项式的 ，每次合并果子一样合并就行了 cf623E 每个数至少使“前缀或”多一位的 ，最多 位所以当 时直接puts(\"0\") 所以现在 同阶了 感觉其他人搞得状态有点麻烦就自己搞了一种（然后发现差不多麻烦） 令 表示前 个数，一共在 个位置下有 的方案数，注意这 个位置是在 中的 最后答案就是 一开始想的转移是 然后发现这个转移太慢了，每次似乎可以转移多个数： 那个 是因为对于右边的 个数的每一个来说，左边 位可以任选 所以是 然后高兴地打了个分治，然后样例就挂了 因为这个 是考虑了 位在 中的位置的，而我们的 相当于已经给这 位确定了位置 所以 还要除以 才是不考虑在 中顺序的方案数 转移即为 然后又调了一年： fft精度差要+0.5 每次 时精度丢失也很严重","categories":[{"name":"总结","slug":"总结","permalink":"https://20021123.xyz/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"NTT","slug":"NTT","permalink":"https://20021123.xyz/tags/NTT/"},{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"},{"name":"FFT","slug":"FFT","permalink":"https://20021123.xyz/tags/FFT/"}]},{"title":"cf886E","slug":"cf886E","date":"2020-02-05T02:43:37.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2020/02/05/cf886E/","link":"","permalink":"https://20021123.xyz/2020/02/05/cf886E/","excerpt":"","text":"cf886E Description 对于一个 个数的排列，定义这个排列的极大值为第一个满足它比后面的 个数都大的数（如果后面不足 个则只需要比后面的数大即可） 给定 求有多少个长为 的排列满足其极大值不为 ，对 取模。 Input 一行两个整数 Output 一行一个整数，即满足条件的排列个数 Sample Input 15 2 15 3 16 3 Sample Output 122 16 184 Hint 样例二的所有情况： Solution 考虑容斥计算所有合法的情况 定义 为 个数极大值在最后 个中（如果 则任意）的排列数（可以发现这时最大值一定等于极大值））。 （这样定义是因为在后面接上一个更大的数则极大值就一定不在这前面 个数之中） 转移是枚举这 个数中的最大值 在最后 个数中的哪一个，右边任意排列且左边的极大值在左边的最后 个中（这样才能被新加入的 覆盖掉）的方案数 可以通过计算 的前缀和来加速转移 所有极大值等于 的排列数就是：枚举 的位置 ，在 个数中选 个放到左边且前面 个数的极大值在这 个数的最后 个之中（这样整个排列的极大值才会被覆盖成 ），后面任意排的方案 复杂度 Code 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;bits/stdc++.h&gt;#define ll long long#define FIO \"cf886E\"#define mul3(a,b,c) mul(mul(a,b),c)using namespace std;const int N=1e6+5,MOD=1e9+7;inline int add(int a,const int &amp;b){return (a+=b)&gt;=MOD?a-MOD:a;}inline int sub(int a,const int &amp;b){return (a-=b)&lt; 0?a+MOD:a;}inline int mul(const int &amp;a,const int &amp;b){return 1ll*a*b%MOD;}inline int&amp; inc(int &amp;a,const int &amp;b){return a=add(a,b);}inline int&amp; dec(int &amp;a,const int &amp;b){return a=sub(a,b);}inline int&amp; pro(int &amp;a,const int &amp;b){return a=mul(a,b);}inline int qpow(int a,int b){int c=1;for(;b;b&gt;&gt;=1,pro(a,a))if(b&amp;1)pro(c,a);return c;}int fac[N],inv[N],invc[N];inline int C(const int &amp;a,const int &amp;b){return mul3(fac[a],invc[b],invc[a-b]);}int n,k,f[N],g[N],pre[N];int main(){ freopen(FIO\".in\",\"r\",stdin); //freopen(FIO\".out\",\"w\",stdout); fac[0]=fac[1]=inv[0]=inv[1]=invc[0]=invc[1]=1; for(int i=2;i&lt;N;i++) fac[i]=mul(fac[i-1],i),inv[i]=mul(MOD-MOD/i,inv[MOD%i]),invc[i]=mul(invc[i-1],inv[i]); scanf(\"%d%d\",&amp;n,&amp;k); f[0]=pre[0]=1; for(int i=1;i&lt;=n;i++){ f[i]=mul(fac[i-1],sub(pre[i-1],i&gt;=k+1?pre[i-k-1]:0)); pre[i]=add(pre[i-1],mul(f[i],invc[i])); } printf(\"%d\\n\",sub(fac[n],mul(fac[n-1],pre[n-1]))); return 0;}","categories":[{"name":"codeforces","slug":"codeforces","permalink":"https://20021123.xyz/categories/codeforces/"}],"tags":[{"name":"计数","slug":"计数","permalink":"https://20021123.xyz/tags/%E8%AE%A1%E6%95%B0/"},{"name":"容斥","slug":"容斥","permalink":"https://20021123.xyz/tags/%E5%AE%B9%E6%96%A5/"}]},{"title":"csp2019游记","slug":"CSP2019游记","date":"2019-11-24T15:28:15.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2019/11/24/CSP2019游记/","link":"","permalink":"https://20021123.xyz/2019/11/24/CSP2019%E6%B8%B8%E8%AE%B0/","excerpt":"","text":"CSP2019 游记 转眼就过了一年，去年看着高二学长的状态就感觉他们的心境会和当时的我完全不同，现在看来的确如此。在这样事关重大的赛季伊始，过去的种种都不影响了，现在一个失误就可能葬送全局1，即使平时自诩心态还行的我也在考前有些许担心。 Day 1 开场看到三道题后两道没大看懂怎么做，剩下 T1 试着在脑中回想一下格雷码的构造无果一看题意才发现直接给出了构造（然而要是考到构造明明见过却记不住，这也许是平时看书当做消遣却不认真记录的后果），直接写了个递归（有趣的是 SCOI2019 D1T1 也直接写了个递归以为可以过就没管了最终挂 50）想了下大概需要开 unsigned，然后一遍过了所有样例感觉还行但极限数据 时却输出不正确，乱改一通没什么作用，把左移的一些东西预处理出来才过。（考后得知因为左移 64 位是 ub（undefined behavior） 所以可能挂，而且题面中还有一个 分的部分分是专门给没开 unsigned 的选手，居然没有发现这个提示） 第二题主要问题是求以一个节点结尾的合法括号序列个数，这个感觉很熟悉但考场上只想到了要求个区间 min 的多带了个 的辣鸡做法，还很难写导致调了巨久。在 Windows 下开栈过了最后一个样例。（写完那个 min 的判断后直觉感觉可以再优化但数据范围已经可以过了就没管） 第三题一开始以为是简单题，试着猜结论例如一条链只能覆盖一遍或者一条边只能『传』两个东西到彼此的对面，感觉样例很强就打算先写再看能不能过样例，花很长时间写了一堆线段树的东西发现过 RE，调完 RE 后过不了样例一，调完样例一才发现算法是假的而且根本修不了（中途想到了直接按边拓扑排序但是又随手造了组数据卡掉了）在没确认算法可以通过所有小样例的情况下写题，这是策略的巨大失误（原因的话我想可能主要是去年 NOIP 的 D1T3 并不难，当时就是大概感觉从小到大排序或者从大到小排就行，先把代码写完最后来调，幸好最后十分钟调出来了）导致这次对难度的预估不够）（经验主义害人）（然而 CSP 和 NOIP 没有任何关系）又试着思考一下链和菊花的部分分发现都没有任何思路，要是知道思路细节多还可以慢慢调，但当时是完全连思路都没有，感觉需要特判的条件数不胜数，搞得整个人头晕脑胀。之后可能只剩一个小时了还没有测代码在 Linux 的编译是否通过，急匆匆 rush 了个 10 分暴力打开虚拟机，发现其他样例都能过就 T2 最后一个大样例不输出弹出一个： 『已杀死』？ 我转念一想是不是没开栈？使用只有模糊记忆的命令 ulimit unlimited ，再测发现毫无作用，再凭借几乎没有的英语理解认为开栈空间就是开内存嘛，内存 = memory，所以打了一遍 ulimit -m unlimited 还是无用，当时心态就完全崩了，这 T3 一个高点的部分分没写 T2 还过不了？那不是当场退役？（主要还是去年 NOIP Day1 几乎人均 AK 导致对于 D1T3 的难度没有正确认识，以往几届 D1T3 并没有去年那么简单，然而我几乎没有系统做过往年题目又导致这个认识并没有解决） 最后半个小时各种乱改乱删，平时的代码整洁度都没有管了，只要能过！然而并没有任何作用，在 Windows 下开栈后完美运行的程序在 Linux 下就是跑不出来，写个中间过程的输出结果输出到一半就『已杀死』了，把一个调用求 min 的函数注释掉后就能跑完（这让我又确认了不是栈空间的问题，因为我凭感觉认为调用后的程序栈空间会和调用前完全一样，那么注释掉的那个函数一定是写成 ub 了。最后半小时的各种细节暂且不表，只记得最后看着各种增删填补的像扭曲污秽的打着各种补丁冒着黑烟滴着黑油的废土中的早已不能入眼的程序仍然只返回一个冰冷的『已杀死』时就像是自身也被『已杀死』那样的内心浓烈的绝望与无力感以及之前被当做玩笑话说过无数次但它可能就要发生在自身上的颓丧的一句： 也许，我就要退役了。 （最后五分钟时监考人员来收草稿纸，然而我并没有交，感觉交了就像递交了战争中的投降协议完全放弃了一般，但是到结尾也没能调出来的那种感觉或许只有完全经历过的菜人才能理解吧。） （最后出来 210 的人应该不少，还算守住了标准分） （有班上的神妹 T3 AC T2写挂分还是比我高，实力差距啊） （最后出来有人告诉我是 ulimit -s 因为栈空间是指栈 stack 和内存 memory 是两个东西。当时的想法可能有许多：如果我早知道这个或许最后半小时能多拿一个 T3 的部分分？我平时都用的 Linux 却把开栈的命令记错了？可能种种都有，最主要的只有希望它的确是因为这个的缘故被卡的） Day 2 T1 看到题想到是容斥+背包（D2T1 考 998244353 ，真有你的），T3 部分分似乎很多，T2像是斜率优化。（顺带确认了下默认的虚拟机是没开栈的，昨天似乎确实是没开栈的问题） 中间过程暂且不提，最终 T1 写的太久 T2 先想到了个 感觉可以优化成 写完发现是假的过不了样例 3，写了个边界可能有误的 过不了任何一个样例，最后只能写个 匆忙跑路。T3 部分分有 75 比昨天 T3 良心多了就没去想正解（时间安排也只留了 75 分）（要是有足够的实力也就不会这样『限制自己』的时间了吧，也是以为 T2 比 T3 简单，但真正有实力的选手 T1 会几分钟内解决，T2 第一遍 就可以直接过掉所有大样例，也不会存在没时间想 T3 正解的情况）写完后尝试改 T2 边界无果，最终老师又来收草稿纸选择了交出去，像是认同了事先预料到的这样的结果一样，大致检查了下文件就到时间了。模拟考许多人会的题不会，正式考试又能『超常发挥』到哪去呢？ （出来的时候的确基本上同班的所有人都会 ，又如 THUSC 一样掉在了没拿满标准分的坑里，不过实力比不过也确实是只有认栽吧） （写这篇不知道在写什么的东西时候有的班上同学已经改完了今天的题，我却半点没动，实力啊） 总结： 目前为止成绩没出，在班上各种民间数据是处于倒三的状态，至少应该能去 THUWC ，NOIWC 不清楚不过不是重点，至少希望接下来几个月能提高点实力 写到这忽然想写一些一直想写的毫无作用的碎碎念，（如果这次退役了以后就没机会写了）对游戏有 PTSD 的可以关掉了：其实一直以来有个感觉就是 OI 和电子竞技有着许多类似之处（比如都是用电脑打比赛？），（比如CSP 考前一个月正好是 LOL S9 全球总决赛）。今年最终夺冠的是一支赛前人气并不是很高的来自中国赛区的战队，但比起这支战队来说，另两只中国赛区的战队『似乎』队内都有着更强的选手，但却都没有走到最后的领奖台上，个人认为主要是因为他们都或多或少有着某个致命的缺陷或短板，能看出来的是只有最强的一个人可能不能带领全队走向胜利，但有着默契协同和完美配合的五个人可能加起来会产生远远大于五的效果（并且这支队伍还有一个完美的节奏发动机）。感觉就和 OI 中各个板块类似，一个人只精通某些类型但比赛可能完全不考那类题，就会陷入毫无用武之地，你需要至少能做出每个版块的中档位置的题最好还有一个精通的版块才有希望考出理想的成绩。 另一个方面来看是：能走到全球总决赛的舞台上的（至少纸面实力上）无一是弱旅，但正式比赛中却常有出现『不知道该怎么赢』，就是团战有来有回两边看上去还差不多，实际上两边的实力有着天壤之别，在暗中两者的经济差早已拉开，劣势的一方只是在像无头的苍蝇一样四处乱撞，一步步走向优势方的陷阱中最终被一波击溃。这或许和平时模拟赛大家都看上去考的都差不多，背后的实力差别却可能早已产生，像是温水煮青蛙一样，可能最终的一次重要考试在『打醒』某些人时就会一并将其『打死』了。（目前看来我可能还没有陷入被『打死』这个境地，顶多是一次『打醒』吧） ——LOL 英雄卡莎↩︎","categories":[{"name":"随笔","slug":"随笔","permalink":"https://20021123.xyz/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://20021123.xyz/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"洛谷5577","slug":"洛谷5577","date":"2019-11-08T08:23:54.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2019/11/08/洛谷5577/","link":"","permalink":"https://20021123.xyz/2019/11/08/%E6%B4%9B%E8%B0%B75577/","excerpt":"","text":"洛谷5577 Description 个不超过 位的 进制数，每次随意取出一些数 （注意可以一个数都不选）， 然后把这些数进行 进制下不进位加法。 求最终 的每个数字被表示出来的方案数对 取模 Input 第一行三个整数 意义为题目中所述。 第二行 个整数，之间用空格隔开，表示纸条上的数字。 （注意 , 纸条上的数均为 进制数） Output 共 行，你需要在第 行输出最终得到数字 的方案数模 的值。 Sample Input 123 5 11 2 3 Sample Output 1234522121 Constraints 时 时 Solution 答案是形如 的所有项的系数并且此处卷积的定义是：两个下标乘起来得到的下标是这两个下标的 进制下不进位加法得到的值。 于是就有了个 的优质做法：每次加入一个数就枚举所有下标并更新它乘上 到达的位置。可以获得 20pts 的好成绩 如果这是普通的多项式乘法那么直接对于每个数 DFT 一遍算出许多点值再对应乘起来再把这些点值 IDFT 回去就是答案。 然后你大概感性理解意会一下题目中的「 进制下不进位加法」的卷积其实也可以类似的做：把每个下标看成一个 维的向量 且其中每一位 （就是 进制下的每一位），那么一个下标 和 的卷积 就是向量中对应的每一位在模 意义下的循环卷积。 循环卷积的例子：模 意义下的 就变成了 我们尝试对于一个 如何进行 维下的 DFT 回想一下一般的一维 DFT 含义：对于第 项系数它对 DFT 的结果中位置 的贡献的系数是 二维的话位置 对位置 的贡献就是 直接先对每一行 DFT 再对每一列 DFT 就行 那么似乎可以直接套到多维上去：对于一个向量 ，其对结果中位置 的贡献是 回到题目。 因为模 意义下不存在 和 的整数解，但我们又需要表示出 和 ，以下内容均在扩域后的意义下进行 即把每个「数」看成是 易证这个域里的「数」满足加法和乘法的封闭性 结合 20pts 做法，注意到每次乘上的只有两项，其中 它对所有位置都会造成 的贡献；而 对于每个位置 会造成 的贡献 那我们对于 个数可以每次 DFT 得到 个形如 的的点值，一共求 遍对于每一位把它对应的 个 乘起来最后再 IDFT 回去就是答案 这样做复杂度可能是 的无疑是过不了的。 但是发现 的范围很大但 却小得多似乎指引我们按照值域做。 仔细一想对于某一位来说，似乎并不需要求出所有的 个 分别是多少，只需要对于每个 知道有多少个 就行了（只需要个数，至于它们具体属于 个中的哪几个是无关紧要的） 那问题就转化为有 个数 ，每一项对于位置 的贡献都是上面那个很长的式子。求对于每个位置 的每个 ，在这 个数中有多少个数对于他的贡献是 这东西看上去异常的难以下手，出题人的标程里写的好像是什么奇奇怪怪的折半引理消去引理的奇淫技巧看不懂 讨论区里又有一位 djq 大爷说是什么单位根反演，但（道理我都懂板子我都抄过，哪里有单位根反演啊/晕） 然后我不知道怎么搞直接把每个值对应下标加一然后做一遍 DFT ，令人惊奇的发现它！就！对！了！ （我写到这里一看上面我写的，就想问自己，这**为什么不对啊） 但这里给读者讲一下（也给将来的我自己）（看懂的就直接跳过好了）： 大概是对应下标加一后位置 的系数就是这个 出现的次数，对于每一个 它对于每个下标 的影响都是个定值 。那么有 个，贡献就是 。那么我们直接把这 个一起做 DFT 肯定是没有问题的（我们每次是 加一（而没有改变后面的 的项的系数 ），所以最后乘出来对于每个位置的贡献确实就是 有多少个算多少个）感觉跟没讲一样，有啥问题评论区问吧 现在我们知道了对于一个位置 和 有多少个数最后对其的贡献是 （记为 。那么这些数点积时都会是 的形式，那么最后点积出来位置 的值就是 最后再做一遍 IDFT 就能得到最终的答案了，总复杂度大概是 左右，如果快速幂没有预处理（见实现细节）可能还要多个 好你就这样高高兴兴的写完然后输出每个答案 ( ) 中的 就发现样例都过不了？？？ 你一看题解发现要输出 才行？？？而且写了就直接能过？？？ 如果你做过 cf1103E 的话可能也会对洛谷上唯一的题解里最终输出的是 a[i].a[0]-a[i].a[4] 而不是 a[i].a[0] 感到疑惑（然而题解并没有提到这个 magic number 是哪来的（以及他把 写成 为啥是对的都没有解释，像我等蒟蒻看的真是难受）） 这里就方便一下我等蒟蒻略作证明（不需要的可以跳过看代码了）： 先说结论：可以证得： （可以像那篇题解一样「带进去检验」，然而对于我等来说真不容易） 我的证法是：你可以发现最终这个东西一定是个整数，并且无论我们把 中的哪一个带入答案都会是整数（这个我确实不会证，应该和 FFT 最后会是不带虚部的实数是同一个原因） 那么我们在复平面中画出所有的 的幂 pic1 我们最后要得到 是一个不带虚部的整数 有 而 所以得到 又因为 ，由上面的第二个式子得到 ，又由第一个式子得到 于是就有 实际上不严谨的证明大概想一下上下对应的系数一定相同才能使得最后 被抵消完落在 轴上成为不带虚部的整数，左右两边如果相同的话就是 是个有理数 感觉是对的 知道这个后求值就很简单了： 当然也可以直接用刚才三角函数的式子： 也差不多，不知道其他人怎么证的我还是画了个图： pic2 和刚才类似的，我们可以得到 ，我们得到 以及 这里并不能保证上下对应位置的系数相等了（即不能保证 ），但由 可以得到 得到 答案就是 （题解里好像是 所以应该可以证明 ？感觉我还不会证，欢迎交流。反正打表出来是对的那我们就当它是对的 ） 一些实现上的细节 求 在 的时候是 注意不要对应系数直接赋值成 了 的时候快速幂可能被卡常，可以预处理出 的幂来加速 也可以用 表示（ ）不用分类讨论 DFT 时的单位根只有一项有值，可以把 的乘法优化成 我太懒了就没写 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include&lt;bits/stdc++.h&gt;#define FIO \"P5577\"#define ll long longchar buf[1&lt;&lt;20]; int bufl,bufr;#define getch ((bufl^bufr||(bufl=0,bufr=fread(buf,1,1&lt;&lt;20,stdin)))?buf[bufl++]:EOF)template &lt;class T&gt;inline void read (T &amp;x,const int &amp;bas=10) { T f=1; x=0; char ch=getch; for (; !isdigit (ch)&amp;&amp;ch!='-'; ch=getch); if (ch=='-')f=-1,ch=getch; for (; isdigit (ch); ch=getch)x=x*bas+ch-'0'; x*=f;}const int MOD=998244353,V=6,N=pow(5,7)+5;inline int add(int a,const int &amp;b){a+=b;return a&gt;=MOD?a-MOD:a;}inline int sub(int a,const int &amp;b){a-=b;return a&lt; 0?a+MOD:a;}inline int mul(const int &amp;a,const int &amp;b){return 1ll*a*b%MOD;}inline int&amp; inc(int &amp;a,const int &amp;b){return a=add(a,b);}inline int&amp; dec(int &amp;a,const int &amp;b){return a=sub(a,b);}inline int&amp; pro(int &amp;a,const int &amp;b){return a=mul(a,b);}inline int qpow(int a,int b){int c=1;for(;b;b&gt;&gt;=1,pro(a,a))if(b&amp;1)pro(c,a);return c;}int n,k,m;struct Com{ int a[V]; inline void clear(){a[0]=a[1]=a[2]=a[3]=a[4]=a[5]=0;} inline Com(){clear();} inline int&amp; operator [](int x){return a[x];} inline const int&amp; operator [](const int &amp;x)const{return a[x];} inline Com operator +(const Com &amp;b)const{Com c;for(int i=0;i&lt;k;i++)c[i]=add(a[i],b[i]);return c;} inline Com operator -(const Com &amp;b)const{Com c;for(int i=0;i&lt;k;i++)c[i]=sub(a[i],b[i]);return c;} inline Com operator *(const int &amp;b)const{Com c;for(int i=0;i&lt;k;i++)c[i]=mul(a[i],b);return c;} inline Com&amp; operator +=(const Com &amp;b){return *this=*this+b;} inline Com&amp; operator *=(const int &amp;b){return *this=*this*b;} inline Com operator *(const Com &amp;b)const{ static ll r[V&lt;&lt;1]; const ll Moc=8ll*MOD*MOD; for(int i=0;i&lt;k;i++)if(a[i])for(int j=0;j&lt;k;j++)if(b[j]){ r[i+j]+=1ll*a[i]*b[j]; if(r[i+j]&gt;=Moc)r[i+j]-=Moc; } Com c; for(int i=0;i&lt;k;i++)c[i]=(r[i]+r[i+k])%MOD,r[i]=r[i+k]=0; return c; } inline Com&amp; operator *=(const Com &amp;b){return *this=*this*b;} inline void out(){for(int i=0;i&lt;k;i++)printf(\"%d%c\",a[i],i^(k-1)?' ':'\\n');} inline int val(){ return sub(add(a[0],a[1]),add(a[2],a[3])); }}a[N],w[2][V],b[N];inline void pre(){ w[0][0][0]=w[1][0][0]=1; w[0][1][1]=w[1][1][k-1]=1; for(int i=2;i&lt;k;i++) w[0][i]=w[0][i-1]*w[0][1],w[1][i]=w[1][i-1]*w[1][1];}//inline Com qpow(Com a,int b){Com c;c[0]=1;for(;b;b&gt;&gt;=1,a*=a)if(b&amp;1)c*=a;return c;}const int B=1000;Com pw0[B+5],pw1[B+5];inline Com qpow(Com a,int b){return pw1[b/B]*pw0[b%B];}inline void getpow(){ for(int i=0;i&lt;n;i++)b[i][0]=1; for(int i=0;i&lt;k;i++){ Com omega; //!!! i=1 gg omega[0]=1;omega[i]++; pw0[0][0]=pw1[0][0]=1; for(int i=1;i&lt;=B;i++)pw0[i]=pw0[i-1]*omega; pw1[1]=pw0[B]; for(int i=1;i&lt;=B;i++)pw1[i]=pw1[i-1]*pw1[1]; for(int id=0;id&lt;n;id++)b[id]*=qpow(omega,a[id][i]); } for(int i=0;i&lt;n;i++)a[i]=b[i];}int pw[V];inline void fft(int opt){ pw[0]=1;for(int i=1;i&lt;m;i++)pw[i]=pw[i-1]*k; for(int i=0;i&lt;m;i++){ for(int j=0;j&lt;n;j++) if(!((j/pw[i])%k)){ static Com f[V]; for(int x=0;x&lt;k;x++) for(int y=0;y&lt;k;y++) f[y]+=a[j+pw[i]*x]*w[opt][x*y%k]; for(int x=0;x&lt;k;x++) a[j+pw[i]*x]=f[x],f[x].clear(); } } if(opt)for(int i=0,inv=qpow(n,MOD-2);i&lt;n;i++)a[i]*=inv;}int main(){ freopen(FIO\".in\",\"r\",stdin); freopen(FIO\".out\",\"w\",stdout); read(n);read(k);read(m); for(int i=1,x;i&lt;=n;i++)read(x,k),a[x][0]++; n=qpow(k,m); pre(); fft(0); getpow(); fft(1); for(int i=0;i&lt;n;i++)printf(\"%d\\n\",a[i].val()); return 0;}","categories":[{"name":"洛谷","slug":"洛谷","permalink":"https://20021123.xyz/categories/%E6%B4%9B%E8%B0%B7/"}],"tags":[{"name":"FFT","slug":"FFT","permalink":"https://20021123.xyz/tags/FFT/"},{"name":"扩域","slug":"扩域","permalink":"https://20021123.xyz/tags/%E6%89%A9%E5%9F%9F/"}]},{"title":"cf1214F","slug":"cf1214F","date":"2019-09-10T14:43:37.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2019/09/10/cf1214F/","link":"","permalink":"https://20021123.xyz/2019/09/10/cf1214F/","excerpt":"","text":"cf1214F Description Two large companies \"Cecsi\" and \"Poca Pola\" are fighting against each other for a long time. In order to overcome their competitor, \"Poca Pola\" started a super secret project, for which it has total n vacancies in all of their offices. After many tests and interviews n candidates were selected and the only thing left was their employment. Because all candidates have the same skills, it doesn't matter where each of them will work. That is why the company decided to distribute candidates between workplaces so that the total distance between home and workplace over all candidates is minimal. It is well known that Earth is round, so it can be described as a circle, and all m cities on Earth can be described as points on this circle. All cities are enumerated from 1 to m so that for each i (1≤i≤m−1) cities with indexes i and i+1 are neighbors and cities with indexes 1 and m are neighbors as well. People can move only along the circle. The distance between any two cities equals to minimal number of transitions between neighboring cities you have to perform to get from one city to another. In partialicular, the distance between the city and itself equals 0. The \"Poca Pola\" vacancies are located at offices in cities a1,a2,…,an. The candidates live in cities b1,b2,…,bn. It is possible that some vacancies are located in the same cities and some candidates live in the same cities. The \"Poca Pola\" managers are too busy with super secret project, so you were asked to help \"Poca Pola\" to distribute candidates between workplaces, so that the sum of the distance between home and workplace over all candidates is minimum possible. Input The first line contains two integers m and n (1≤m≤109, 1≤n≤200000) — the number of cities on Earth and the number of vacancies. The second line contains n integers a1,a2,a3,…,an (1≤ai≤m) — the cities where vacancies are located. The third line contains n integers b1,b2,b3,…,bn (1≤bi≤m) — the cities where the candidates live. Output The first line should contain the minimum total distance between home and workplace over all candidates. The second line should contain n different integers from 1 to n. The i-th of them should be the index of candidate that should work at i-th workplace. Sample Input 12310 31 5 510 4 6 Sample Output 1231 2 3 Solution 先给出不会证明正确性的 代码 123456for(int i=1;i&lt;=n;i++){ int cur=0; for(int j=1;j&lt;=n;j++) cur+=dis(a[j],b[(i+j-2)%n+1]); ans=min(ans,cur);} 然后考虑一个分段函数 枚举 ，把 对应 的情况的答案设为 同理 注意两个不等式不等价，比如 的时候一个符号为正一个符号为负，使用尺取即可， 细节见代码把 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;bits/stdc++.h&gt;#define ll long long#define FIO \"cf1214F\"using namespace std;const int N=2e5+5;int n;double m;struct node{ int id,x; inline void rd(const int &amp;i){scanf(\"%d\",&amp;x);id=i;} inline bool operator &lt;(const node &amp;t)const{ return x&lt;t.x; }}a[N],b[N];ll ans[N];int out[N];int flag;inline void add(int x,int l,int r,int v){ if(l&gt;r)return; if(flag){ l=(n+x-l)%n+1; r=(n+x-r)%n+1; swap(l,r); }else{ l=(l+n-x)%n+1; r=(r+n-x)%n+1; } if(l&gt;r){ ans[l]+=v; ans[1]+=v; ans[r+1]-=v; }else{ ans[l]+=v; ans[r+1]-=v; }}inline void getans(node *a,node *b){ //1~j1 j1+1~j2 j2+1~j3 j3+1~n // ai-m/2 ai ai+m/2 for(int i=1,j1=0,j2=0,j3=0;i&lt;=n;i++){ while(b[j1+1].x&lt;a[i].x-m/2&amp;&amp;j1&lt;n)j1++; while(b[j2+1].x&lt;a[i].x&amp;&amp;j2&lt;n)j2++; if(!flag)while(b[j2+1].x&lt;=a[i].x&amp;&amp;j2&lt;n)j2++; while(b[j3+1].x&lt;=a[i].x+m/2&amp;&amp;j3&lt;n)j3++; add(i,1,j1,-a[i].x); add(i,j1+1,j2,a[i].x); add(i,j2+1,j3,-a[i].x); add(i,j3+1,n,a[i].x); if(!flag){ add(i,1,j1,m); add(i,j3+1,n,m); } }}int main(){ freopen(FIO\".in\",\"r\",stdin); //freopen(FIO\".out\",\"w\",stdout); scanf(\"%lf%d\",&amp;m,&amp;n); for(int i=1;i&lt;=n;i++)a[i].rd(i); for(int i=1;i&lt;=n;i++)b[i].rd(i); sort(a+1,a+n+1); sort(b+1,b+n+1); getans(a,b); flag=1; getans(b,a); for(int i=1;i&lt;=n;i++)ans[i]+=ans[i-1]; int mn=1; for(int i=1;i&lt;=n;i++)if(ans[i]&lt;ans[mn])mn=i; printf(\"%lld\\n\",ans[mn]); for(int i=1;i&lt;=n;i++) out[a[i].id]=b[(i+mn-2)%n+1].id; return 0;}","categories":[{"name":"codeforces","slug":"codeforces","permalink":"https://20021123.xyz/categories/codeforces/"}],"tags":[{"name":"思维","slug":"思维","permalink":"https://20021123.xyz/tags/%E6%80%9D%E7%BB%B4/"}]},{"title":"HDU4997","slug":"HDU4997","date":"2019-08-15T12:07:34.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2019/08/15/HDU4997/","link":"","permalink":"https://20021123.xyz/2019/08/15/HDU4997/","excerpt":"","text":"HDU4997 Description People are weak. Relationship between people like friendship or love is weak too. But a group of persons can have strong relationship, umm, 2-edge-connected relationship. Suppose there are n persons. If two persons, A and B, are in a relationship, then we add an un-directional edge between them. In this way we can have a relationship graph, which is an un-directional graph without self-loops or multiple edges. If this graph is 2-edge-connected, then we say these persons have a strong relationship. Now we have a group of persons without relationship between any two of them. And some pair of persons even hate each other. You will introduce some pairs of persons to know each other and set up a relationship between them to make the group of persons have a strong relationship. But notice that you can't set up a relationship between a pair of persons who hate each other. How many ways you can do that? (Two ways are different if there exists a pair of persons which have relationship in one way but not in another way). output the answer modulo 1e9+7 Input The first line contains an integer , denoting the number of the test cases. For each test case, the first line contains 2 integers n and m, denoting the number of persons in the group and the number of pairs of persons who hate each other. Then m lines follow, each line containing 2 integers and , denoting that and B hate each other. The persons are indexed from . Output For each test case, output the answer in a line. Sample Input 12345635 010 05 21 22 3 Sample Output 12325346699727618 Hint A 2-edge-connected graph is a graph which is connected and if you remove an edge from it, it is still connected. Note that , so we can ignore the issue that whether a single vertex is 2-edge-connected or not :). Solution 1.计算集合 形成的连通图的方案数 直接做是 这里说一下 做法：定义集合幂级数的乘法为子集卷积， 为形成连通图的方案的集合幂级数， 为形成任意子图的方案的集合幂级数( 项的系数是 ) 2. 计算集合 形成的双连通图的方案数 为计算双连通子图的方案 ，再记录一个h[S][T]表示将 划分为若干不相互连通的连通子集 使得所有子集 都有且仅有一条连向 的边 （两条就双连通了） 一开始特别菜的不知道怎么预处理这个 以为只能 一看其他人写的直接 即可，我容斥不过关 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;bits/stdc++.h&gt;#define ll long long#define FIO \"hdu4997\"using namespace std;const int N=10,SN=1&lt;&lt;N,MOD=1e9+7,N2=N*N;inline int add(int a,const int &amp;b){return (a+=b)&gt;=MOD?a-MOD:a;}inline int sub(int a,const int &amp;b){return (a-=b)&lt; 0?a+MOD:a;}inline int mul(const int &amp;a,const int &amp;b){return 1ll*a*b%MOD;}inline int&amp; inc(int &amp;a,const int &amp;b){return a=add(a,b);}inline int&amp; dec(int &amp;a,const int &amp;b){return a=sub(a,b);}inline int&amp; pro(int &amp;a,const int &amp;b){return a=mul(a,b);}inline int qpow(int a,int b){int c=1;for(;b;b&gt;&gt;=1,pro(a,a))if(b&amp;1)pro(c,a);return c;}inline int inv(const int &amp;a){return qpow(a,MOD-2);}int n,T,m,d[N][N],E[SN],f[SN],g[SN][N+1],h[SN][SN],up,ans[SN],bin[N2];inline void clear(){ memset(d,0,sizeof d); memset(E,0,sizeof E); memset(f,0,sizeof f); memset(g,0,sizeof g); memset(h,0,sizeof h);}inline void add(int *a,int *b){for(int i=0;i&lt;=n;i++)inc(a[i],b[i]);}inline void sub(int *a,int *b){for(int i=0;i&lt;=n;i++)dec(a[i],b[i]);}inline void getln(int *f){ static int tmp[N+1]; for(int i=0;i&lt;=n;i++)tmp[i]=f[i]; for(int i=1;i&lt;n;i++){ int cur=0; for(int j=0;j&lt;i;j++)inc(cur,mul(mul(j+1,f[j+1]),tmp[i-j])); dec(f[i+1],mul(inv(i+1),cur)); }}inline int edge(int S,int T){return sub(E[S^T],add(E[S],E[T]));}inline void getf(){ for(int S=1;S&lt;up;S++)g[S][__builtin_popcount(S)]=bin[E[S]]; for(int S=1;S&lt;up;S&lt;&lt;=1)for(int i=0;i&lt;up;i++)if(i&amp;S)add(g[i],g[i^S]); for(int S=1;S&lt;up;S++)getln(g[S]); for(int S=1;S&lt;up;S&lt;&lt;=1)for(int i=0;i&lt;up;i++)if(i&amp;S)sub(g[i],g[i^S]); for(int S=1;S&lt;up;S++)f[S]=g[S][__builtin_popcount(S)];}inline void getans(){ for(int S=0;S&lt;up;S++)h[0][S]=1; for(int S=1;S&lt;up;S++){ int lst=S&amp;-S; for(int T=up-1^S;T;T=(T-1)&amp;(up-1^S)) for(int s=S^lst;~s;s=s?(s-1)&amp;(S^lst):-1) inc(h[S][T],mul(mul(h[S^s^lst][T],f[s^lst]),edge(s^lst,T))); } for(int S=0;S&lt;up;S++){ int lst=S&amp;-S; ans[S]=f[S]; if(S^lst) for(int s=(S^lst)&amp;((S^lst)-1);~s;s=s?(s-1)&amp;(S^lst):-1) dec(ans[S],mul(ans[s^lst],h[S^s^lst][s^lst])); }}int main(){ freopen(FIO\".in\",\"r\",stdin); //freopen(FIO\".out\",\"w\",stdout); scanf(\"%d\",&amp;T); bin[0]=1;for(int i=1;i&lt;N2;i++)bin[i]=add(bin[i-1],bin[i-1]); while(T--){ clear(); scanf(\"%d%d\",&amp;n,&amp;m); up=1&lt;&lt;n; while(m--){ int u,v; scanf(\"%d%d\",&amp;u,&amp;v); u--;v--; d[u][v]++; d[v][u]++; } for(int S=0;S&lt;up;S++) for(int i=0;i&lt;n;i++)if(S&gt;&gt;i&amp;1) for(int j=i+1;j&lt;n;j++)if(S&gt;&gt;j&amp;1)E[S]+=!d[i][j]; getf();getans(); printf(\"%d\\n\",ans[up-1]); } return 0;}","categories":[{"name":"HDU","slug":"HDU","permalink":"https://20021123.xyz/categories/HDU/"}],"tags":[{"name":"计数","slug":"计数","permalink":"https://20021123.xyz/tags/%E8%AE%A1%E6%95%B0/"},{"name":"容斥","slug":"容斥","permalink":"https://20021123.xyz/tags/%E5%AE%B9%E6%96%A5/"}]},{"title":"UOJ37","slug":"UOJ37","date":"2019-08-12T09:16:44.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2019/08/12/UOJ37/","link":"","permalink":"https://20021123.xyz/2019/08/12/UOJ37/","excerpt":"","text":"UOJ37 Description 响应主旋律的号召，大家决定让这个班级充满爱，现在班级里面有 个男生。 如果 爱着 ，那么就相当于 和 之间有一条 的有向边。如果这 个点的图是强联通的，那么就认为这个班级是充满爱的。 不幸的是，有一些不好的事情发生了，现在每一条边都可能被摧毁。我作为爱的使者，想知道有多少种摧毁的方式，使得这个班级任然充满爱呢？（说人话就是有多少边的子集删去之后整个图仍然强联通。） Input 第一行两个数 和 ，表示班级里的男生数和爱的关系数。 接下来 行，每行两个数 和 ，表示男生 爱着男生 。同时 不等于 。 所有男生从 到 标号。 同一条边不会出现两遍，但可能出现 爱着 ， 也爱着 的情况，这是两条不同的边。 Output 输出一行一个整数，表示对 取模后的答案。 Sample Input 123456789101112131415165 154 34 22 52 11 25 13 24 11 45 43 45 32 31 53 1 Sample Output 19390 Constraints 对于 的数据满足: ; 对于 的数据满足: ; 对于 的数据满足: ; 对于 的数据满足: 。 时间限制：1s 空间限制：256MB Solution 表示把集合 分为非强连通分量的方案数 表示把集合 分为 个 的方案数 表示把集合 分为 个 的方案数（也即是 ） 定义其中的 对于 , 令 后两项可以通过预处理一个点的出度集合和入度集合来快速计算 Q： 算 时要用到 但算 时不是应该加上当前的 吗， 又要通过 求？ A: 想一下我们现在求的是什么：当前情况的合法状态数 。这个要通过 实现，那么就要把之前算的答案导致的不合法情况容斥掉，而 的意义只是为了我们后面再算的时候降低复杂度，是我们“定义”出来的一个值，没有什么实际含义，即我们只需要算之前的 导致的不合法情况并删除，剩下的就是现在合法的情况数，然后再用这个去更新现在的 以便以后用到的时候值正确 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;bits/stdc++.h&gt;#define ll long long#define FIO \"uoj37\"#define cnt(x) __builtin_popcount(x)using namespace std;const int N=15,N2=N*N,SN=1&lt;&lt;N,MOD=1e9+7;inline int add(int a,const int &amp;b){return (a+=b)&gt;=MOD?a-MOD:a;}inline int sub(int a,const int &amp;b){return (a-=b)&lt; 0?a+MOD:a;}inline int mul(const int &amp;a,const int &amp;b){return 1ll*a*b%MOD;}inline int&amp; inc(int &amp;a,const int &amp;b){return a=add(a,b);}inline int&amp; dec(int &amp;a,const int &amp;b){return a=sub(a,b);}inline int&amp; pro(int &amp;a,const int &amp;b){return a=mul(a,b);}inline int qpow(int a,int b){int c=1;for(;b;b&gt;&gt;=1,pro(a,a))if(b&amp;1)pro(c,a);return c;}int n,m,up;int E[SN],f[SN],g[SN],ans[SN],bin[N2],edge[SN],id[SN],d[N][N],in[N],out[N];int main(){ freopen(FIO\".in\",\"r\",stdin); freopen(FIO\".out\",\"w\",stdout); scanf(\"%d%d\",&amp;n,&amp;m); up=1&lt;&lt;n; for(int i=0;i&lt;n;i++)id[1&lt;&lt;i]=i; bin[0]=1;for(int i=1;i&lt;N2;i++)bin[i]=add(bin[i-1],bin[i-1]); for(int i=1,u,v;i&lt;=m;i++)scanf(\"%d%d\",&amp;u,&amp;v),d[--u][--v]++,in[v]|=1&lt;&lt;u,out[u]|=1&lt;&lt;v; for(int S=1;S&lt;up;S++){ int lst=S&amp;-S; E[S]=E[S^lst]+cnt(in[id[lst]]&amp;(S^lst))+cnt(out[id[lst]]&amp;(S^lst)); } for(int S=1;S&lt;up;S++){ int lst=S&amp;-S; if(S==lst){ g[S]=ans[S]=1; continue; } edge[S]=0; for(int T=(S-1)&amp;S;T;T=(T-1)&amp;S){ int lst=(S^T)&amp;-(S^T); edge[T]=edge[T^lst]-cnt(out[id[lst]]&amp;(T^lst^S))+cnt(in[id[lst]]&amp;T); } for(int T=(S^lst)&amp;((S^lst)-1);~T;T=T?(T-1)&amp;(S^lst):-1){ dec(g[S],mul(ans[T^lst],g[T^lst^S])); } for(int T=S;T;T=(T-1)&amp;S){ inc(f[S],mul(g[T],bin[edge[T]+E[S^T]])); } inc(g[S],ans[S]=sub(bin[E[S]],f[S])); } printf(\"%d\\n\",ans[up-1]); return 0;} ​","categories":[{"name":"UOJ","slug":"UOJ","permalink":"https://20021123.xyz/categories/UOJ/"}],"tags":[{"name":"计数","slug":"计数","permalink":"https://20021123.xyz/tags/%E8%AE%A1%E6%95%B0/"},{"name":"容斥","slug":"容斥","permalink":"https://20021123.xyz/tags/%E5%AE%B9%E6%96%A5/"}]},{"title":"字符串选讲","slug":"字符串选讲","date":"2019-08-10T02:01:10.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2019/08/10/字符串选讲/","link":"","permalink":"https://20021123.xyz/2019/08/10/%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%80%89%E8%AE%B2/","excerpt":"","text":"字符串选讲 只会讲几个简单模版，觉得简单的可以跑路了整理一下概念，难度随机排列 有几个概念一直绕来绕去的： 区间/全局+位置不同/本质不同+子/回文+序列/串 1. 全局+位置不同+子串 不会的可以丢出去了... 2.全局+本质不同+子串 同上 3. 全局+位置不同+子序列 同上 4.全局+位置不同+回文串 manacher 什么你不会manacher? 5.全局+本质不同+子序列 序列自动机+记忆化搜索+高精度 什么你不会序列自动机？ 就是个二维数组好吧 该怎么构造怎么构造1 1234567int trans[N][26],nxt[26];for(int i=n;i;i--){ memcpy(trans[i],nxt,sizeof nxt); nxt[s[i]-'a']=i;}memcpy(trans[0],nxt,sizeof nxt); 6.全局+位置不同+回文序列 表示我只会DP $$ $$ 欢迎暴打讲课人 7. 全局+本质不同+回文串 听说有manacher+后缀数组做法，然而不是很懂那些人在写什么会的人可以上来讲 我今天只是来讲板子的，于是： 回文自动机即可。2 回文自动机上一个节点代表一个本质不同的回文串，总节点个数 个根节点就是本质不同的回文串个数，这样讲能听懂了吧=.= 什么你不会回文自动机？ 8. 全局+本质不同+回文序列 完全不会搞=.=, dfs吗？只是凑数的 欢迎暴打讲课人X2 9. 区间+位置不同+子串 ：妹神，这题咋做啊。 ：我不会 ：你题都没看你就说不会，你咋这么假 ：不是，我是真不会 ：哦，那好嘛，让你看几秒，现在会了吗 ：还是不会 ：？？？这妹神怎么走水，丢出去丢出去3 10.区间+位置不同+子序列 ：该怎么怎么 ：不是，这题你还要？ ：哦，我傻了 ：哎哟~~~假死了4 11. 区间+位置不同+回文串 这好像是道原题但不是所有人都改了（记不到题号了，欢迎某神妹说一下） 蜜汁画外音：预处理出串的manacher数组，然后你瞎搞一下就完了。5 ？？？ =.= 设manacher预处理出来的每个位置最多往左右延伸的距离数组为f 相当于求 解不等式 所以取可得对于 左边限制更强 然后继续解 然后就是查满足 且 的 的 之和以及 之和以及个数，没被“挡住”的 的个数直接用 去减，右边是相似的，然后就随便写完了 可以用树状数组优化常数，也可以用主席树在线 12. 区间+本质不同+子串 课件里提到过（当时在冬眠？完全没印象了） 先离线询问，然后变成右端点r每次往右拓展。怎么算答案？使用线段树记录对于每个左端点l有多少个子串最后一次出现是从l开始的，答案即l-r的区间和。 怎么维护？考虑拓展之后以当前r结尾的串一定在后缀树上是一条到根的链。之前这条链上有一些点，这些点的最后一次出现位置（的右端点）将要变为r， 即用LCT维护，每个节点记一下所属的right集合最大值，然后新加一个点就是对于一条链的right集合最大值全部赋值为r，即access操作。 (例如从右往左加入到 时) (图来自冬令营课件，因为懒得画了) 加入前： 区间本质不同子串 加入后： 区间本质不同子串2 然后可以知道在这棵LCT中所有在同一棵splay上的节点的right集合最大值都是相等的（归纳法） 每次右端点右移时直接区间 都加上 ，表示左端点在 右端点在 的子串出现次数都加上 ，但是有可能以 结尾的某些子串在之前出现过，那么它们在右端点移到 之前的最后一次出现的左端点的值则要减去 ，（这些子串最后一次出现位置改变了）这可以在access途中维护。 ZGZ7kD.png 即把一些左端点在 右端点在 的点的贡献删掉，再把其右端点改为当前的 代码应该好懂 （注意mnlen的含义） 1234567891011121314151617181920//hackerrank how many substrings//or hdu4622(Weakened version)inline void pushup(int x){mnlen[x]=min(mnlen[lx],min(len[sam::fa[x]]+1,mnlen[rx]));}inline void pushdown(int x){ rig[lx]=max(rig[lx],rig[x]); rig[rx]=max(rig[rx],rig[x]);}inline void access(int x,int n){ for(int y=0;x;x=fa[y=x]){ splay(x); pushdown(x); if(len[x]&amp;&amp;rig[x]) mdy(rig[x]-len[x]+1,rig[x]-mnlen[x]+1,-1); rx=y; pushup(x); if(!fa[x])rig[x]=n; }} 13.区间+本质不同+子序列 好像又是原题，不过原题字符集大小只有 ，改成 也差不多吧 好像讲过了，那我就不讲了再讲一遍 设dp[i][j]表示从左到右到第i位，以字符j结尾的子序列个数 于是 $$ $$ 转移看成矩阵可得：(假设字符集大小为3) (矩阵公式太难打以下矩阵全部识别自原题解) 然后肉眼观察手推6可得出转移矩阵的逆矩阵 然后答案即为 然后预处理前缀积可做到 然后可以通过非零项只有项来做到我不会 讲下最优解 考虑 矩阵左乘另一个矩阵的含义 即 对于这一项 否则 这是什么意思？相当于 矩阵的第s[这一项]列的每一个数都变成所在行的行和了，其余不变 这个是可以通过维护每一行行和维护的 对于右乘一个矩阵是相当于每行的除了第s[这一项]列的这个数都减等于这个数（这真可以手推），维护一下每一行所有数一共减了多少即可 再来看我们求什么，一个全是 的行向量右乘 相当于只有 行，预处理出来列和，然后一个只有最后一项的列向量左乘 只有 列，预处理出行和，然后即可（ 即 )复杂度是 的 123456789101112131415161718192021222324252627282930//可能预处理的是A^-1左乘，A右乘，不过等价的//B即是A^-1for(int i=0;i&lt;M;i++)A[i][i]=B[i][i]=sum_A[i]=1;preB[0][M-1]=1;for(int i=1;i&lt;=n;i++){ int v=s[i]-'a'; for(int j=0;j&lt;M;j++){ dec(sum_A[j],A[v][j]); inc(A[v][j],sum_A[j]); inc(sum_A[j],A[v][j]); inc(B[j][v],sum_B[j]); dec(sum_B[j],B[j][v]); dec(B[j][v],sum_B[j]); /* 上面三行等价于 int tmp=sum_B[j]; sum_B[j]=sub(0,B[j][v]); B[j][v]=add(mul(2,B[j][v]),tmp); */ } for(int j=0;j&lt;M;j++){ preA[i][j]=sum_A[j]; preB[i][j]=add(B[j][M-1],sum_B[j]); }}//算答案for(int i=0;i&lt;M;i++)inc(ans,mul(preB[l-1][i],preA[r][i])); 14.区间+本质不同+回文串 有一个性质就是一个回文串的所有回文后缀可以分为不超过 个等差数列（证明可以翻鏼课件） 还是和求区间本质不同子串相似的做法，先离线，考虑右端点每次右移，不同的是直接维护左端点在每个位置时的答案。 考虑怎么求以新增的r结尾的串的贡献 区间本质不同回文串 大概这个样子，会造成若干个回文串最后一次出现位置被更新，例如红色回文串就会以红色串上次出现左端点 到这次红色串出现的左端点为左端点的区间内的本质不同回文串个数加一，绿色的同理，但可以注意到它们可以恰好拼成一个区间，那么就可以一起修改了。 =.=不对吧，如果绿色除了r结尾最后一次出现不以红色开头呢？不会算成（如下绿色框）吗？ 比如这样 区间本质不同回文串2 =v=你冷静观察下就会发现红色串在回文树上的父亲不是绿色串而是蓝色串，根据回文树的定义蓝色串一定是最长的，绿色的出现位置会形成一个等差数列，（意会一下可以知道）形成的回文串出现位置一定是连着的，所以还是没有问题的 12345678910111213141516171819202122232425262728//bzoj5384inline void append(int n){ int p=lst,c=s[n]-'a'; while(s[n-len[p]-1]^s[n])p=fa[p]; if(!ch[p][c]){ int q=fa[p]; while(s[n-len[q]-1]^s[n])q=fa[q]; len[++ptr]=len[p]+2; fa[ptr]=ch[q][c]; ch[p][c]=ptr; dif[ptr]=len[ptr]-len[fa[ptr]]; anc[ptr]=dif[ptr]^dif[fa[ptr]]?fa[ptr]:anc[fa[ptr]]; } lst=ch[p][c];}for(int i=1;i&lt;=n;i++){ for(int u=pos[i];u;u=anc[u]){ int l=max(1,qry(id[u],id[u]+sz[u]-1)-len[u]+2); int r=i-(len[anc[u]]+len[u]-len[fa[u]])+1; bit.add(l,r); } mdy(id[pos[i]],i); while(!q[i].empty()){ pii x=q[i].back();q[i].pop_back(); ans[x.first]=bit.qry(x.second); } } 15 区间+位置不同+回文序列 同，只会 &gt;_&lt; 16.区间+本质不同+回文序列 完全不会=.= ：Ber！这不XX题吗，就XXOJXXXX和XXOIXXXX的那道一样的 （其他做过该题的与没做过该题的）：？？？ ：哦，那还是差不多嘛，你看都是XX再套个XX就完了 ：？？？所以就一样？？？7 再讲几个板子来拖时间吧 （毕竟除了板子就啥都不会了） 真一点的广义后缀自动机 可能插入一个新节点时已经有从之前到现在的转移边了，判断一下len，可能需要拆之前的点（其实和之前拆点的写法几乎一样） 1234567891011121314151617181920212223242526272829303132inline void append(int c){ int p=lst; if(ch[p][c]){ if(len[ch[p][c]]==len[p]+1)lst=ch[p][c]; else{ int q=ch[p][c],nq=++ptr; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); for(;ch[p][c]==q;p=fa[p])ch[p][c]=nq; lst=nq; } }else{ //printf(\"p=%d c=%d\\n\",p,c); int x=++ptr;len[x]=len[p]+1;lst=x; while(p&amp;&amp;!ch[p][c])ch[p][c]=x,p=fa[p]; if(!p)fa[x]=1; else{ int q=ch[p][c]; if(len[q]==len[p]+1)fa[x]=q; else{ int nq=++ptr; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[x]=fa[q]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); for(;ch[p][c]==q;p=fa[p])ch[p][c]=nq; } } }} 双端插入的回文自动机 记一下两端加入的回文串的最后插入位置（及总串的最长回文前缀和最长回文后缀），然后和普通回文自动机一样的写就行了，注意一点就是根据定义当插入后当前节点长度变为总长的时候要把另一端的最后插入位置也变成当前节点。=.=看代码吧 1234567891011121314151617//hdu5421//f=1 left //f=2 rightinline void append(int n,int f){ int p=lst[f-1],c=s[n]-'a',ff=f*2-3;//f=1 -&gt; ff=-1 | f=2 -&gt; ff=1 while(s[n-len[p]*ff-ff]^s[n]) p=fa[p]; if(!ch[p][c]){ int q=fa[p]; while(s[n-len[q]*ff-ff]^s[n])q=fa[q]; len[++ptr]=len[p]+2; fa[ptr]=ch[q][c]; lst[f-1]=ch[p][c]=ptr; if(r-l+1==len[ptr])lst[!(f-1)]=ptr;//! dep[ptr]=dep[fa[ptr]]+1; }else lst[f-1]=ch[p][c]; sum+=dep[ch[p][c]];} 后缀平衡树 维护一个母串，支持加后缀、删后缀、询问一个模版串出现次数。 母串模版串都反过来，变为每次在左边加减字符就可以动态的维护后缀数组。 新加入节点时最好能 比较rk ，于是使用平衡树维护一个long long数组val 类似于 最好使用重量平衡树 或替罪羊 查串 出现次数即查 ，可在平衡树上查找（这里判断字符串大小听说不知道为什么二分没有暴力for快 我不知道我瞎说的我自己这题也没过被卡常了） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768//bzoj4768inline void relabel(int x=X,ll l=L,ll r=R){ if(!x)return; val[x]=mid; relabel(ch[x][0],l,mid); relabel(ch[x][1],mid,r); if(x==X)X=0;}inline void ins(int pos,int &amp;x=rt,ll l=0,ll r=1e18){ if(!x){ x=newnode(pos,mid); return; } int t=s[x]&lt;s[pos]||(s[x]==s[pos]&amp;&amp;val[x-1]&lt;val[pos-1]); ins(pos,ch[x][t],t?mid:l,t?r:mid); if(rnd[ch[x][t]]&lt;rnd[x]){ rot(x,t); X=x;L=l;R=r; } pushup(x);}inline bool les(int x){ for(int i=0;i&lt;min(len,x);i++)if(s[x-i]^str[i]) return s[x-i]&lt;str[i]; return x&lt;len;}inline void qry(int x=rt){ while(x){ if(les(x))ans+=sz[ch[x][0]]+1,x=ch[x][1]; else x=ch[x][0]; }}switch(type[0]){ case 'Q':{ scanf(\"%s\",str); len=strlen(str); decode(mask); reverse(str,str+len); ans=0; qry(); ans=-ans; str[len++]='Z'+1; qry(); printf(\"%d\\n\",ans); mask^=ans; break; } case 'A':{ scanf(\"%s\",str); len=strlen(str); decode(mask); for(int i=0;i&lt;len;i++)s[++n]=str[i],ins(n),relabel(); break; } case 'D':{ int x; scanf(\"%d\",&amp;x); while(x--){ del(n); s[n--]=0; } break; }} 拓展KMP 国外好像叫Z-algorithm，用来 计算串 每一个后缀和串 的 设答案数组为ext[i]即S[i]与T的 再预处理出一个nxt[i]表示S[i]与S[0]的 长度 ：就，你记录一个最长延伸到的点，再用类似manacher的方法算就完了。8 ？？？ 就分三种情况讨论 这种情况我们什么也不知道，只能令 这表示 什么意思呢？即 第 位与 的 已经在第 项算过了，且肯定不会变多，可以直接赋值为 这时最上方两个蓝色的串处于红色串没包含的部分一定不相等（否则红色串将更长），只能赋值为已知的长度即 可以把 并为一种 （代码巨短无比） （这是预处理 至于计算 就基本完全一样了） 1234567891011121314151617//luogu P5410 int mid=0;for(int i=1;i&lt;n;i++){ if(nxt[mid]+mid&gt;=i+nxt[i-mid])nxt[i]=nxt[i-mid]; else nxt[i]=max(0,mid+nxt[mid]-i); while(i+nxt[i]&lt;=n&amp;&amp;s[nxt[i]]==s[i+nxt[i]])nxt[i]++; if(i+nxt[i]&gt;mid+nxt[mid])mid=i;}mid=0;while(t[ext[0]]==s[ext[0]])ext[0]++;for(int i=1;i&lt;m;i++){ if(ext[mid]+mid&gt;=i+nxt[i-mid])ext[i]=nxt[i-mid]; else ext[i]=max(0,mid+ext[mid]-i); while(i+ext[i]&lt;=m&amp;&amp;s[ext[i]]==t[i+ext[i]])ext[i]++; if(i+ext[i]&gt;mid+ext[mid])mid=i;} Lyndon分解 定义：对于字符串 ，若 的最小后缀为其本身，那么称 为 串 性质：任意字符串 都可以分解为 ，其中 为 串且 。且这种分解方法是唯一的 证明：到处都有就不搬了。。。我证明不过关9 如何构造：考虑维护当前结尾的若干个相等的 串，每次往右移，令未确定分解的开始位置为 ，当前新增位置为 , 是 这一位在之前循环的对应位置，分情况讨论 周期不变形成了一个更大的串一定不能与左边的合并了，所以记录答案再从所在的循环头部开始 大概是这样 ZJS0xO.png 123456789101112//loj129for(int i=1;i&lt;=n;){ int j=i,k=i+1; for(;k&lt;=n&amp;&amp;s[j]&lt;=s[k];k++){ if(s[k]==s[j])j++; else j=i; } while(i&lt;=j){ i+=k-j; printf(\"%d \",i-1); }} 如果有时间，再讲点奇奇怪怪的题 真 · 只讲板子.jpg CF666E Description 给你一个串 以及一个字符串数组 ， 次询问，每次问 的子串 在 中的哪个串里的出现次数最多，并输出出现次数。如有多解输出最靠前的那一个。 Sample Input 12345678suffixtree3suffixtreesareawesomecartesiantreeisworsethansegmenttreenyeeheeheee21 2 1 101 3 9 10 Sample Output 121 13 4 Constraint Solution 建出广义 每个节点使用线段树合并维护每个节点在每个 中出现次数 对 每个前缀记录匹配到广义 的哪个节点 以及匹配长度 ，查询时如果 不足 直接返回 ，否则倍增到找到最长的长度大于等于 的 的后缀树上的祖先，在该祖先的线段树里随便查询一下就行了 （注意线段树合并的时候要新建节点，不然信息（很有可能）被破坏，小样例还测不出来） Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;bits/stdc++.h&gt;#define ll long long#define pii pair&lt;int,int&gt;#define FIO \"cf666e\"using namespace std; const int N=5e5+5,M=5e4+5,C=26,lgM=18; int n,ptr=1,m;char s[N],t[M]; int rt[M&lt;&lt;1];namespace seg{ int ptr; int ch[M*80][2]; pii tr[M*80];#define lk ch[k][0]#define rk ch[k][1]#define mid (l+r&gt;&gt;1) inline void mdy(int &amp;k,int pos,int l=1,int r=m){ if(!k)k=++ptr; if(l==r){ tr[k]=pii(tr[k].second+1,-l); return; } if(pos&lt;=mid)mdy(lk,pos,l,mid); else mdy(rk,pos,mid+1,r); tr[k]=max(tr[lk],tr[rk]); } inline pii qry(int k,int ql,int qr,int l=1,int r=m){ if(!k)return pii(0,-ql); if(ql&lt;=l&amp;&amp;r&lt;=qr)return tr[k]; if(qr&lt;=mid)return qry(lk,ql,qr,l,mid); if(mid&lt;ql)return qry(rk,ql,qr,mid+1,r); return max(qry(lk,ql,mid,l,mid),qry(rk,mid+1,qr,mid+1,r)); } inline int merge(int x,int y,int l=1,int r=m){ if(!x||!y)return x|y; int z=++ptr; if(l==r){ tr[z]=pii(tr[x].first+tr[y].first,-l); return z; } ch[z][0]=merge(ch[x][0],ch[y][0],l,mid); ch[z][1]=merge(ch[x][1],ch[y][1],mid+1,r); tr[z]=max(tr[ch[z][0]],tr[ch[z][1]]); return z;} #undef lk#undef rk#undef mid} int fa[M&lt;&lt;1],ch[M&lt;&lt;1][C],len[M&lt;&lt;1],lst;inline void append(int c,int id){ int p=lst; if(ch[p][c]){ if(len[ch[p][c]]==len[p]+1)lst=ch[p][c]; else{ int q=ch[p][c],nq=++ptr; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); for(;ch[p][c]==q;p=fa[p])ch[p][c]=nq; lst=nq; } }else{ //printf(\"p=%d c=%d\\n\",p,c); int x=++ptr;len[x]=len[p]+1;lst=x; while(p&amp;&amp;!ch[p][c])ch[p][c]=x,p=fa[p]; if(!p)fa[x]=1; else{ int q=ch[p][c]; if(len[q]==len[p]+1)fa[x]=q; else{ int nq=++ptr; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[x]=fa[q]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); for(;ch[p][c]==q;p=fa[p])ch[p][c]=nq; } } } seg::mdy(rt[lst],id);} int h[M&lt;&lt;1],nxt[M&lt;&lt;1],to[M&lt;&lt;1],ecnt;inline void add(int u,int v){nxt[++ecnt]=h[u];h[u]=ecnt;to[ecnt]=v;} int anc[M&lt;&lt;1][lgM];inline void dfs(int u=1){ for(int i=1;anc[u][i-1];i++)anc[u][i]=anc[anc[u][i-1]][i-1]; for(int i=h[u],v;i;i=nxt[i])anc[v=to[i]][0]=u,dfs(v),rt[u]=seg::merge(rt[u],rt[v]);} int q,pos[N],L[N];int main(){ scanf(\"%s\",s+1); n=strlen(s+1); scanf(\"%d\",&amp;m); for(int i=1;i&lt;=m;i++){ scanf(\"%s\",t+1); int len=strlen(t+1); lst=1; for(int j=1;j&lt;=len;j++)append(t[j]-'a',i); } for(int i=2;i&lt;=ptr;i++)add(fa[i],i); dfs(); for(int i=1,p=1,l=0;i&lt;=n;i++){ int c=s[i]-'a'; while(p&amp;&amp;!ch[p][c])p=fa[p],l=len[p]; if(!p){ p=1;l=0; }else{ p=ch[p][c]; l++; } pos[i]=p;L[i]=l; } scanf(\"%d\",&amp;q); while(q--){ int l,r,ql,qr; scanf(\"%d%d%d%d\",&amp;ql,&amp;qr,&amp;l,&amp;r); l=r-l+1; if(L[r]&lt;l){printf(\"%d %d\\n\",ql,0);continue;} int u=pos[r]; for(int i=lgM-1;~i;i--)if(len[anc[u][i]]&gt;=l)u=anc[u][i]; pii ans=seg::qry(rt[u],ql,qr); printf(\"%d %d\\n\",-ans.second,ans.first); } return 0;} LuoguP4482 Description 求区间最长 长度 : 对于给定的串 ，最大的 使得 , 为 的长度。 Sample Input 12345abbabbaa31 81 72 7 Sample Output 123143 Constraint Solution 题意可以转化为对于一个 找到一个最大的 满足 使得 ，在后缀树上即是r所代表的节点的某个祖先x的right集合内大于等于l且满足 的最大的 一个在串随机的情况下的可能的算法就是每次从 r 的节点暴力往上跳使用线段树合并/Set启发式合并找到符合要求的right集合内的值，期望情况下SAM大概树高是log的，大概可以过这部分分 考虑正解链分治，之前的做法复杂度不对的原因是每个询问可能被处理树高次，在树高特别高（如全是一个字符）时会挂掉。 那么能否离线下来呢？如果只是保留下来对每个点的询问还是会查若干遍，因为要查的和len[x]和l都有关，转化式子 可以对每个节点以i为下标维护i-len[x]的最小值即求一段区间最靠右的满足 的位置 ，然后链剖，发现我们每次询问的是若干重链的前缀的信息，把询问到根的路径拆成若干条重链前缀的询问，对每个点先继承重链父亲（如果有）的状态，再加入自己的虚子树（直接暴力DFS，因为一个点最多往上走log跳虚边即最多在log个点的虚子树内），计算在这个节点的询问，再递归处理子树，然后计算答案在自己子树内时的影响（即和之前一样维护right集合，用个rig[u].lower_bound(min(ql[cur]+len[u],qr[cur]))） 区间border 如这样，从询问点到根的路径被分为 条重链的前缀。 以 的点和所求 在最上面红点到根的前缀时对答案的影响： 首先会继承继承到根的重链的虚子树部分（蓝色三角）的信息if(u^top[u])rt[u]=rt[fa[u]]; 然后对于每一个询问直接seg::qry(rt[u],qr[cur]-1,ql[cur]-1)即可 区间border2 然后是 恰为当前点的答案，加入所有虚子树（绿色三角）内right-len[x] （这时right集合还没有合并，最多有一个值） 区间border3 123456inline void dfs4(int u,int x){ if(rig[u].size())seg::mdy(rt[x],*rig[u].begin(),*rig[u].begin()-len[x]); for(int i=h[u],v;i;i=nxt[i])dfs4(v=to[i],x);} for(int i=h[u],v;i;i=nxt[i])if((v=to[i])^son[u])dfs4(v,u); 递归计算所有儿子的信息，然后合并这个点的right集合，更新答案在这个子树内的影响 区间border4 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;bits/stdc++.h&gt;#define ll long long#define FIO \"P4482\"using namespace std;const int N=2e5+5,C=26,INF=1e9;inline void chkmax(int &amp;a,const int &amp;b){if(a&lt;b)a=b;}inline void chkmin(int &amp;a,const int &amp;b){if(a&gt;b)a=b;}int n,m,fa[N&lt;&lt;1],len[N&lt;&lt;1];char s[N];set&lt;int&gt;rig[N&lt;&lt;1];int R[N&lt;&lt;1];namespace sam{ int lst=1,ptr=1,ch[N&lt;&lt;1][C]; inline void append(int n){ int c=s[n]-'a',p=lst,x=++ptr;len[x]=len[p]+1;lst=x;rig[x].insert(n);R[x]=n; for(;p&amp;&amp;!ch[p][c];p=fa[p])ch[p][c]=x; if(!p)fa[x]=1; else{ int q=ch[p][c]; if(len[q]==len[p]+1)fa[x]=q;else{ int nq=++ptr; len[nq]=len[p]+1; fa[nq]=fa[q]; fa[q]=fa[x]=nq; memcpy(ch[nq],ch[q],sizeof ch[q]); for(;ch[p][c]==q;p=fa[p])ch[p][c]=nq; } } }}int h[N&lt;&lt;1],nxt[N&lt;&lt;1],to[N&lt;&lt;1],ecnt;inline void add(int u,int v){nxt[++ecnt]=h[u];h[u]=ecnt;to[ecnt]=v;}int sz[N&lt;&lt;1],top[N&lt;&lt;1],son[N&lt;&lt;1];inline void dfs1(int u=1){ sz[u]=1; for(int i=h[u],v;i;i=nxt[i]){ dfs1(v=to[i]),sz[u]+=sz[v]; if(!son[u]||sz[v]&gt;sz[son[u]])son[u]=v; }}inline void dfs2(int u=1,int tp=1){ top[u]=tp; if(son[u])dfs2(son[u],tp); for(int i=h[u],v;i;i=nxt[i])if((v=to[i])^son[u])dfs2(v,v);}int pos[N],rt[N&lt;&lt;1];int ql[N],qr[N],ans[N];namespace seg{ int mn[N*50],ptr,ch[N*50][2];#define lk ch[k][0]#define rk ch[k][1]#define mid (l+r&gt;&gt;1) inline int qry(int k,int qr,int val,int l=1,int r=n){ if(mn[k]&gt;val)return -INF; if(l==r)return l; if(r&lt;=qr){ if(mn[rk]&lt;=val)return qry(rk,qr,val,mid+1,r); return qry(lk,qr,val,l,mid); }else{ if(qr&lt;=mid)return qry(lk,qr,val,l,mid); else return max(qry(lk,mid,val,l,mid),qry(rk,qr,val,mid+1,r)); } } inline void mdy(int &amp;k,int pos,int val,int l=1,int r=n){ if(!k)k=++ptr; chkmin(mn[k],val); if(l==r)return; if(pos&lt;=mid)mdy(lk,pos,val,l,mid); else mdy(rk,pos,val,mid+1,r); }}inline void dfs4(int u,int x){ if(rig[u].size())seg::mdy(rt[x],*rig[u].begin(),*rig[u].begin()-len[x]); for(int i=h[u],v;i;i=nxt[i])dfs4(v=to[i],x);}vector&lt;int&gt;q[N&lt;&lt;1];inline void merge(int u,int v){ if(rig[u].size()&lt;rig[v].size())swap(rig[u],rig[v]); for(set&lt;int&gt;::iterator it=rig[v].begin();it!=rig[v].end();it++)rig[u].insert(*it);}inline void dfs3(int u=1){ if(u^top[u])rt[u]=rt[fa[u]]; for(int i=0,sz=q[u].size();i&lt;sz;i++) chkmax(ans[q[u][i]],seg::qry(rt[u],qr[q[u][i]]-1,ql[q[u][i]]-1)); for(int i=h[u],v;i;i=nxt[i])if((v=to[i])^son[u])dfs4(v,u); assert(rig[u].empty()||*rig[u].begin()==R[u]); if(rig[u].size())seg::mdy(rt[u],*rig[u].begin(),*rig[u].begin()-len[u]); for(int i=h[u],v;i;i=nxt[i]){ dfs3(v=to[i]); merge(u,v); } for(int i=0,sz=q[u].size();i&lt;sz;i++){ set&lt;int&gt;::iterator it=rig[u].lower_bound(min(ql[q[u][i]]+len[u],qr[q[u][i]])); if(it!=rig[u].begin()) chkmax(ans[q[u][i]],*--it); }}int main(){ memset(seg::mn,0x3f,sizeof seg::mn); scanf(\"%s%d\",s+1,&amp;m); n=strlen(s+1); for(int i=1;i&lt;=n;i++)sam::append(i),pos[i]=sam::lst; for(int i=2;i&lt;=sam::ptr;i++)add(fa[i],i); dfs1();dfs2(); for(int i=1;i&lt;=m;i++){ scanf(\"%d%d\",&amp;ql[i],&amp;qr[i]); ans[i]=ql[i]-1; for(int u=pos[qr[i]];u;u=fa[top[u]]) q[u].push_back(i); } dfs3(); for(int i=1;i&lt;=m;i++)printf(\"%d\\n\",ans[i]-ql[i]+1); return 0;} JSOI2019节日庆典 Description 对于给定字符串 的每一个前缀 ，求出 。 定义 为最小的 满足 其中 (冒号表示字符串拼接) Sample Input 1abaacaba Sample Output 11 1 3 3 3 6 3 8 ​ Solution 可以尝试记录到当前点为止可能成为答案点的集合，这些起始点之间任意两个的 都一定能够延伸到当前点（否则的话无论后面再加什么字符，有一位大了的一定永远大于另一个） 考虑有两个候选答案 ， ，它们关系如下图 JSOI2019节日庆典 那么可以看出红色串一定是某个 串重复若干遍最后截了一部分（可能没有）形成的， 假设此时 ,那么我们可以找到 之后的第一个 开始的位置记为 ,并把最后剩下的不满一个 的记为 ， 左边记为 ， 之后 出现了 次 然后我们考虑原题中的 函数 然后考虑相邻两项大小关系的充要条件 非常神奇的发现这两个条件居然等价！所以要么是 要么是 无论哪一种 都不会是答案点，所以可以去掉，不过这一切都要建立在一个前提： 能找得到一个这样的 ，即 可以证明这样每两个相邻的候选点到最右端点的距离都至少乘 所以总共只会有 个候选点，暴力判断复杂度也才 （好像这题有 做法没看懂） 至于怎么判断候选点哪个最优，可以发现实际上就是求 前缀和 某一后缀的大小关系，用上面提到的拓展KMP算法求出 每个位置与 的 即可 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;bits/stdc++.h&gt;#define ll long long#define FIO \"P5334\"using namespace std;const int N=3e6+5;int n,nxt[N];char s[N];inline int cmp(int x,int l){ //printf(\"cmp %d %d=%d\\n\",x,l,nxt[x]&lt;l?(s[nxt[x]]&lt;s[x+nxt[x]]?-1:1):0); return nxt[x]&lt;l?(s[nxt[x]]&lt;s[x+nxt[x]]?-1:1):0;}int main(){ scanf(\"%s\",s); n=strlen(s); int mid=0; for(int i=1;i&lt;n;i++){ nxt[i]=mid+nxt[mid]&gt;=i+nxt[i-mid]?nxt[i-mid]:max(0,mid+nxt[mid]-i); while(i+nxt[i]&lt;n&amp;&amp;s[i+nxt[i]]==s[nxt[i]])nxt[i]++; if(i+nxt[i]&gt;mid+nxt[mid])mid=i; } nxt[0]=n; vector&lt;int&gt;p,q; for(int i=0;i&lt;n;i++){ p.push_back(i);q.clear(); for(int j=0,sz=p.size();j&lt;sz;j++){ while(!q.empty()&amp;&amp;s[i]&lt;s[q.back()+i-p[j]])q.pop_back(); if(q.empty()||(s[i]==s[q.back()+i-p[j]]&amp;&amp;(i-p[j]+1&lt;&lt;1)&lt;i-q.back()+1))q.push_back(p[j]); } p=q; int ans=p[0]; for(int j=0,sz=p.size();j&lt;sz;j++){ int x=p[j],opt=cmp(ans+i-x+1,x-ans); if(opt&lt;0||(!opt&amp;&amp;cmp(x-ans,ans)&gt;0))ans=x; } //printf(\"%d\\n\",ans+1); printf(\"%d%c\",ans+1,i^n-1?' ':'\\n'); } return 0;} 总结 居然水到词了...希望对大家有帮助。作图累死了，以后没事不写题解了 （这种题解可能1篇比某神人5篇长了，要是每个人题解都这样图文并茂感觉做题会轻松很多) 参考资料 该怎么dp怎么dp就行了吧————《衍芃福音——雅礼集训》第10章——数列↩︎ 贪心即可————《衍芃福音——雅礼集训》第1章——矩阵↩︎ 《衍芃福音——讲座》第?章——走水↩︎ 《衍芃福音——讲座》第?章——我傻了↩︎ 《衍芃福音——机房训练》第?章——瞎搞↩︎ 你手推嘛，我是手推的————《衍芃福音——机房评讲》第?章——讲题↩︎ 《衍芃福音——机房训练》第?章——口胡↩︎ 《衍芃福音——机房评讲》第?章——就完了↩︎ 你DP不过关!————《衍芃福音——机房评讲》第?章——怒斥↩︎","categories":[{"name":"总结","slug":"总结","permalink":"https://20021123.xyz/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://20021123.xyz/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"SPOJ DIV1CNT","slug":"SPOJDIV1CNT","date":"2019-06-14T01:29:50.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2019/06/14/SPOJDIV1CNT/","link":"","permalink":"https://20021123.xyz/2019/06/14/SPOJDIV1CNT/","excerpt":"","text":"SPOJ DIV1CNT Description Letbe the sum of positive proper divisors of . For example, and Let Given , find . Input First line contains ), the number of test cases. Each of the next lines contains a single integer . ) Output For each number , output a single line containing . Sample Input 12345676123101001000000000000000000 Sample Output 123456012323249322467033424113218863487627735401433 洛谷题面 Solution 题意即求的前缀和 现在问题就是求 相当于是求双函数在到时下方的整点数 借用一下这位老哥的图以及题解 SPOJ26073 可以看出是要求紫色部分（以下称为\"R区域\"）的整点个数 然后可以使用一个叫做树的东西(我也不会，想学自己去查吧=.=) 只需要知道它可以不重不漏的构造出所有的真既约分数 然后我们从点出发（在R区域上方），初始添加分数和，每次按照着那个树构造出的分数作为向量往下走直到走到R区域（就不走这一步了），然后在树(???)上二分出（不知道叫不叫二分，可能也不叫）下一步走的向量，答案加等于然后一直这样走，直到最后走到时每次基本都是向右走很多$ y才下格（反比例函数的性质不对是常识）（此时斜率绝对值为$）可以直接暴力，然后就完了。 ？？？？ 不是故意题解写成这样的，是膜X的后遗症 Q1：为啥初始点坐标? A1：我们要求R区域内的整点个数（包括边界），可能可以从边界上开始算，但感觉要判是不是平方数什么的，细节很多，直接从R区域上方开始，每次找到一个尽可能贴近双曲线的向量（但不相交）顺着走，这样只需考虑当前点左边的点（不包括自身）可能会好写一些，坐标是之后往下走的时候默认当前坐标所在行已经算过答案了，如果不的话就会少 时的答案 Q2：每次往下走之后答案多了哪些点呢？ A2：好问题！因为我也想了半天那个是哪里冒出来的，然而网上题解大概就两篇，不知道是不是一个人写的都没解释，拿出画图： SP26073.png 红色部分是双曲线，因为我们找到的是最贴合双曲线的向量（图中绿色），所以绿色一定不会经过其他的点（否则向量就是上面的点到这个“其他的点”了），新增的点的个数就是蓝色部分+橙色部分在R区域内的点数（我们的当前点以及走到的点都在R区域外，都不计入答案），由图像可知蓝色部分点数是, 橙色部分点数是对称的，（不对称则向量会到不对称的那个点）所以橙色部分在R区域内的点数= Q3：怎么找到最贴近双曲线的向量？ A3 ：因为我们要向量，树给我们提供的是向量的斜率的绝对值，所以为了避免难写，维护的是向量的绝对值的一个栈。相当于把最上面那个图上下翻转一下，然后维护一个从栈顶到栈底斜率越来越低的栈，如果按之前的方法走的向量再走一遍就到R区域了，那么就一直弹栈直到当前的在R区域而不在 Q3_1.png 就像这样 把记为,记为按照树的方法生成他们的合向量，然后分两种大的情况讨论 Case1: Q3_2.png 当前点走不会走进R区域 所以一定比更贴近双曲线，可以令再继续二分 Case2: Q3_3.png 如果走会到R区域内 那么分的斜率和双曲线在的斜率的大小关系讨论 试想一下之后如果之后继续二分，得到的的比现在的还要大，那么双曲线斜率就还要小，不管变得多么接近斜率仍永远比双曲线的大，所以仍一定在R区域内（或者可以考虑二分的过程，相当于是每次，而双曲线在处已经斜率小于等于了，所以无论之后加多少个仍然在R区域）直接break掉 那么之后加若干还是可能走出区域的，就令再继续二分 代码里写的是用的斜率，当然也可以求导得到等价的不用double的表达式 Q4：所以那个树有啥用啊？ A4：emmm...可能是能够保证这样一定能够造出所有斜率，不会漏解，然而直觉上感觉是对的就行了 Q5：咋暴力啊？ A5：该怎么暴力就怎么暴力 Q6：时间复杂度？ A6：不会证，参见IOI2018候选队论文《一些特殊的数论函数求和问题 朱震霆》 Q7：为啥你和哪位老哥代码那么像？ A7：因为是抄的啊 注意答案可能爆long long, 要_int128 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;bits/stdc++.h&gt;#define ll long long#define lll __int128 #define FIO \"SP26073\"using namespace std;const int N=1e7+5;struct point{ ll x,y; inline point(ll _x=0,ll _y=0){x=_x;y=_y;} inline point operator +(const point &amp;t)const{ return point(x+t.x,y+t.y); }}st[N],L,R,M;ll n;inline bool inR(ll x,ll y){return x*y&lt;=n;}inline double slope(ll x){return (double)n/x/x;}inline lll s0(){ lll ret=0; int t=0,rt=cbrt(n); st[++t]=point(1,0); st[++t]=point(1,1); ll m=sqrt(n),x=n/m,y=m+1; while(1){ //printf(\"t=%d\\n\",t); for(L=st[t--];!inR(x+L.x,y-L.y);x+=L.x,y-=L.y) ret+=x*L.y+(L.y+1)*(L.x-1)/2; if(y&lt;=rt)break; for(R=st[t];inR(x+R.x,y-R.y);R=st[--t])L=R; while(1){ M=L+R; if(!inR(x+M.x,y-M.y))st[++t]=(R=M); else{ if(slope(x+M.x)&lt;=(double)R.y/R.x)break; L=M; } } } for(int i=1;i&lt;y;i++)ret+=n/i; return ret*2-1ll*m*m;}int T;inline void write(lll x){ if(x&gt;=10)write(x/10); putchar(x%10+'0');}inline void writeln(const lll &amp;x){ write(x); putchar('\\n');}int main(){ freopen(FIO\".in\",\"r\",stdin); freopen(FIO\".out\",\"w\",stdout); scanf(\"%d\",&amp;T); while(T--)scanf(\"%lld\",&amp;n),writeln(s0()); return 0;}","categories":[{"name":"SPOJ","slug":"SPOJ","permalink":"https://20021123.xyz/categories/SPOJ/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"},{"name":"凸包","slug":"凸包","permalink":"https://20021123.xyz/tags/%E5%87%B8%E5%8C%85/"}]},{"title":"2019江苏省队集训Day6T2","slug":"2019江苏省队集训Day6T2","date":"2019-06-13T05:57:51.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2019/06/13/2019江苏省队集训Day6T2/","link":"","permalink":"https://20021123.xyz/2019/06/13/2019%E6%B1%9F%E8%8B%8F%E7%9C%81%E9%98%9F%E9%9B%86%E8%AE%ADDay6T2/","excerpt":"","text":"【2019 江苏省队第一轮集训】D6T2 计数 Description 对于一个01 串s, 定义f (s) 为. 其中是个函数, 其定义为 读入一个串01 串S , 记其所有非空子序列构成的多重集为. 比如, 那么. S 一共有$2^{|S|-1} 个不同的非空子序列于是有|P(S )| = 2^{|S|-1}$ . 求 对$998244353 取模后的值比如对于S = 010答案为f (0) + f (1) + f (0) + f (01) + f (00) + f (10) + f (010) =0 + 0 + 0 + 0 + 1 + 0 + 1 = 2$. Input 从文件$count.in 中读入数据。输入第一行读入一个字符串S$ . Output 输出到文件$count.out 中。输出_{sP(S)}f(s)对998244353 $取模后的值. Sample Input 1010 Sample Output 12 Solution 如果按照神仙的题解方式： 贪心即可。 ————《衍芃福音——雅礼集训》第1章——矩阵 搞出来 dp 就行。 ————《衍芃福音——雅礼集训》第3章——水箱 李超树板子。 ————《衍芃福音——雅礼集训》第3章——线段游戏 该怎么 dp 怎么 dp 就行了吧。 ————《衍芃福音——雅礼集训》第10章——数列 原文地址 那么就应该是 NTT即可。 搞出来卷积即可。 NTT板子。 该怎么卷积就怎么卷积就行了吧。 。。。 还是写点我等凡人能看懂的题解：=.= 有一个套路式子（我考场上就不会太菜了） 然后枚举一对使得，它们对答案的贡献就是左右各自选相等的若干个，中间的个任意选或者不选，则有 $$ 枚举相等的值 $$ 这下可以说该怎么卷积就怎么卷积了 代码里字符串是1base Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;bits/stdc++.h&gt;#define ll long long#define FIO \"count\"#define mul3(a,b,c) mul(mul(a,b),c)using namespace std;const int N=2.5e5+5,MOD=998244353,P=19;inline int add(int a,const int &amp;b){if((a+=b)&gt;=MOD)a-=MOD;return a;}inline int sub(int a,const int &amp;b){if((a-=b)&lt; 0)a+=MOD;return a;}inline int mul(const int &amp;a,const int &amp;b){return 1ll*a*b%MOD;}inline int sqr(const int &amp;a){return mul(a,a);}inline int&amp; inc(int &amp;a,const int &amp;b){return a=add(a,b);}inline int&amp; dec(int &amp;a,const int &amp;b){return a=sub(a,b);}inline int&amp; pro(int &amp;a,const int &amp;b){return a=mul(a,b);}inline int qpow(int a,int b){int c=1;for(;b;b&gt;&gt;=1,pro(a,a))if(b&amp;1)pro(c,a);return c;}int fac[N],inv[N],invc[N],bin[N],invb[N];int w[2][1&lt;&lt;P],rev[1&lt;&lt;P];inline int C(const int &amp;a,const int &amp;b){return a&gt;=b?mul3(fac[a],invc[b],invc[a-b]):0;}int n,ans;inline void pre(){ fac[0]=fac[1]=inv[0]=inv[1]=invc[0]=invc[1]=bin[0]=invb[0]=1; bin[1]=2;invb[1]=MOD+1&gt;&gt;1; for(int i=2;i&lt;=n;i++)fac[i]=mul(fac[i-1],i),inv[i]=mul(inv[MOD%i],MOD-MOD/i),invc[i]=mul(invc[i-1],inv[i]),bin[i]=mul(bin[i-1],2),invb[i]=mul(invb[i-1],invb[1]); for(int i=1;i&lt;1&lt;&lt;P;i&lt;&lt;=1){ w[0][i]=w[1][i]=1; int wn1=qpow(3,(MOD-1)/(i&lt;&lt;1)),wn0=qpow(wn1,MOD-2); for(int j=1;j&lt;i;j++) w[0][i+j]=mul(w[0][i+j-1],wn0),w[1][i+j]=mul(w[1][i+j-1],wn1); }}inline void ntt(int *f,int opt,int l){ for(int i=0;i&lt;l;i++){rev[i]=rev[i&gt;&gt;1]&gt;&gt;1|(i&amp;1)*l&gt;&gt;1;if(i&lt;rev[i])swap(f[i],f[rev[i]]);} for(int i=1;i&lt;l;i&lt;&lt;=1) for(int j=0;j&lt;l;j+=i&lt;&lt;1) for(int k=0;k&lt;i;k++){ int x=f[j+k],y=mul(f[i+j+k],w[opt][i+k]); f[j+k]=add(x,y); f[i+j+k]=sub(x,y); } if(opt)for(int i=0,inv=qpow(l,MOD-2);i&lt;l;i++)pro(f[i],inv);}char s[N];#define poly vector&lt;int&gt;inline void out(const poly &amp;a){ for(int i=0,n=a.size();i&lt;n;i++)printf(\"%d%c\",a[i],i^n-1?' ':'\\n');}inline poly operator*(poly a,poly b){ int n=a.size(),m=b.size(),l=1; while(l&lt;n+m)l&lt;&lt;=1; a.resize(l);b.resize(l); ntt(&amp;a[0],0,l);ntt(&amp;b[0],0,l); for(int i=0;i&lt;l;i++)pro(a[i],b[i]); ntt(&amp;a[0],1,l); a.resize(n+m-1); return a;}inline poly&amp; operator *=(poly &amp;a,const poly &amp;b){return a=a*b;}int main(){ freopen(FIO\".in\",\"r\",stdin); //freopen(FIO\".out\",\"w\",stdout); scanf(\"%s\",s+1); n=strlen(s+1); pre(); poly f,g; for(int val=0;val&lt;2;val++){ f.clear(); g.clear(); f.resize(n); g.resize(n); for(int i=0;i&lt;n;i++)f[i]=(s[i+1]==val+'0')?invc[i]:0,g[i]=(s[n-i]==val+'0')?invc[i]:0; f*=g; f.resize(n); for(int k=0;k&lt;n-1;k++) inc(ans,mul3(f[k],fac[k],invb[k])); } printf(\"%d\\n\",mul(ans,bin[n-2])); return 0;}","categories":[],"tags":[{"name":"计数","slug":"计数","permalink":"https://20021123.xyz/tags/%E8%AE%A1%E6%95%B0/"},{"name":"NTT","slug":"NTT","permalink":"https://20021123.xyz/tags/NTT/"}]},{"title":"SCOI2019总结","slug":"SCOI2019总结","date":"2019-04-16T15:04:58.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2019/04/16/SCOI2019总结/","link":"","permalink":"https://20021123.xyz/2019/04/16/SCOI2019%E6%80%BB%E7%BB%93/","excerpt":"","text":"SCOI2019 总结 Day -1 整个白天就打了个的板子，感觉应该要考字符串，再打了个板子题就没做什么事了，然后就颓一下午知乎。不上晚自习提前放学跑步时看到佬和几个物理组的在打球，感觉马上退役了晚自习前就也可以这么玩了。 在家里随意看了一下之前省选前定的计划发现可能还有和没学，感觉应该不会考也没多在意，上洛谷看了几道今日推荐结果全是数据结构而且题解都看得很麻烦就都没打，大致过了几个背不到的板子就睡了。 ### Day0 ### Day1 时全场都在敲键盘什么鬼，测试电脑硬件需要打板吗，一开始还没反应过来，反应过来之后就也开始“测试键盘鼠标是否正常”了（CCF：“竞”赛一年） 拿到题感觉可做区间重心不知道是个什么鬼 看了一遍咋不是直接从到过去呢？后来才发现好像很不对，一定是最小的才能跳，感觉很汉诺塔就画了个一推感觉很对，发现样例是还是对的，写了一个辣鸡递归感觉随便跑，一测大样例个点没过盲猜一测过了感觉很对的样子，曰：此乃签到，不久后突然发现可能需要高精度，但是不是很懂的限制是怎么回事，打一下表发现大多是在左右挂的，感叹原来是防止炸避免我们写高精，赞曰SCOI出题人什么时候这么良心！然后一看各种做法，然后想到了虚树的但不知怎么换根没想到，以为复杂度就乱搞了一个链剖每次枚举选哪个。写着写着发现需要可持久化，那就加吧，然后又发现要区间操作，凭着可能两周前还有的印象开始写，然后经历了一些时间消失的魔法（虚拟机卡卡卡卡卡卡卡卡卡，写区间修改主席树调调调调调调调）之后就到了，哇写完这个写个小时写不出来有毒，不过并没有慌因为平时熬夜晚上调个小时调出来并不慌，开始写特判感觉非常顺畅然后后并没有爆搜分感觉非常不可做赶紧回来调，可能发现之前的线段树写法有锅两边都有的情况写成然而这里应该是可能查了很久的错以及改半天找到的错才改完等终于过了自测小样例拍了起来。还有分钟想着先测一下虚拟机能否编译再写一下链或者高精度吧（这时候都没反应到高精要多的常数导致过不了）然后开虚拟机，然后卡死，然后测编译过了，然后点击关闭，然后卡死，然后就时间到了。辣鸡电脑毁我青春 出来之后感觉全世界都写了高精，真是菜，一下被甩，不过抱着本来就是来打酱油的心情并没有什么不好（主要终于调出开心的一比，差点写了不知道多少的代码就爆零了）。然后下午面试第一组，准备了半天的“不含个人信息及学校信息”的自我介绍没用上......直接无领导讨论，感觉有几个人是互相认识的就一直在那扯一些别的与主题不相关的东西，我提醒一遍后还是走偏了，于是感觉正常水平吧（出分后面试很菜，不知道为什么，神大以后如果还有面试分组的时候还是注意点分组比较好）然后看成绩和估分一样可还行(然而考场估分)当时感觉还行吧，不过其他人的好像被卡了，和不写高精的我一样哈哈，睡觉的时候才反应过来好像接近垫底了，不过还是没什么感觉，主要就是来打酱油也不会去想翻盘什么的。晚上并没有看（感觉这东西并不会考）而是随便翻翻书，看了会手机就睡了。 Day 2 今年的依旧有计算几何 有了昨天的经验还是早早的“测试好键盘鼠标工作正常”然后开题，一眼看过去区间叉积求绝对值最大，又看了几下感觉没什么问题开始推式子，看数据范围(昨天没写数据范围所以自信)没什么坑点，先写一个感觉很对，然后感觉前缀和一下就是直接的最大减最小不用考虑前后关系，用这两个拍了一会感觉很对，感觉的一个优化套路就是凸包啥的，草稿纸上手算一下没问题，写了一下拍过了，这么这么水，考前一周才在调一个凸包的题边界被恶心死了，结果这题一遍过样例一遍过拍???EXM???然后曰：此乃签到。然后看一眼看上去感觉送了分分类讨论，也是好像做的时间越长得分越多的样子。（这之间突然说要加模数，感觉SCOI出题人真😁不过有昨天调到十二点的经历我觉得还是达到点写不出来就换，结果到了点过电脑开始卡死了，编译一次一分钟有毒，叫了“监考人员”（还是工作人员？记不到了）于是来了一个应该也是大学生退役的来看，并没有什么用(辣鸡电脑，确实没救)。说可能换会快点，（我就是从这里跳下去，也不会用你一个! 真香）然后他就走了。测了一下编译用时秒整（神大电脑真😁😁）然后可能突然好了点十多秒就可以编译，然后写着写着又卡死了，往下翻会出现大片空白，开个一分钟，又找了一遍“监考人员”来了一个很像专家的工作人员，然后注销，然后没用，然后重启，然后好了，我问能不能加时结果对曰:“这是你程序的问题，在你程序运行之前是没有问题的。懂我意思吧。”我😁😁😁。然后继续调突然过了样例，一测小数据一答案大了一点，然后有个地方写的锅有点大，改之，然后样例过不了了...发现把一个，打反了， 改之，样例还是过不了，我xxxxx这数据真😁。然后可能突然了，不慌不忙写了的分暴力，然后一个感觉可以线性基，然后就感觉不可做了（这熟悉的套路）然后继续冷静调好像一对算了多次，加了个，过了，一拍很稳，然后时间不多了不敢开虚拟机怕又卡死就检查了下文件然后结束。 出来在楼梯上听到说什么两个的优化吓我一跳，以为自己写了个惊天假做法，然后遇到写的是一样的感觉稳多了，，感觉也没什么问题该写的都写了。下午在神大闲逛，和大神打了会球然后颓了会昨天新下回来的虚荣，老年人操作不来连跪。然后就出成绩了，还是和估分一样可还行，好像挂了不然就进队了，队长好稳啊，高二个队好稳啊，我又被初中生吊打了好菜啊，然后就该申诉的申诉，该回家的回家了。 总结 感觉省选发挥还行吧，抱着打酱油的心态就会“不以物喜不以己悲”了吧。第一天比较菜也没有影响第二天翻盘（?)，两天都调了一道两三个小时的题还都调出来了可还行吧(?)，然后可能就还是不回文化课放松(?)了吧，新装备正在路上，还是要继续努力啊！","categories":[{"name":"随笔","slug":"随笔","permalink":"https://20021123.xyz/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://20021123.xyz/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"动态DP","slug":"动态DP","date":"2018-12-07T16:24:00.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2018/12/08/动态DP/","link":"","permalink":"https://20021123.xyz/2018/12/08/%E5%8A%A8%E6%80%81DP/","excerpt":"","text":"从发现的神仙玩意，虽然可能没啥用但还是试试学一学顺便练练码力。 保卫王国 Description Z国有 座城市， 条双向道路，每条双向道路连接两座城市，且任意两座城市 都能通过若干条道路相互到达。 Z国的国防部长小Z要在城市中驻扎军队。驻扎军队需要满足如下几个条件： ● 一座城市可以驻扎一支军队，也可以不驻扎军队。 ● 由道路直接连接的两座城市中至少要有一座城市驻扎军队。 ● 在城市里驻扎军队会产生花费，在编号为的城市中驻扎军队的花费是 。 小Z很快就规划出了一种驻扎军队的方案，使总花费最小。但是国王又给小Z提出 了个要求，每个要求规定了其中两座城市是否驻扎军队。小Z需要针对每个要求逐一 给出回答。具体而言，如果国王提出的第个要求能够满足上述驻扎条件（不需要考虑 第个要求之外的其它要求），则需要给出在此要求前提下驻扎军队的最小开销。如果 国王提出的第个要求无法满足，则需要输出 。现在请你来帮助小Z。 Input 第 行包含两个正整数和一个字符串，分别表示城市数、要求数和数据类型。是一个由大写字母 ， 或 和一个数字 ，， 组成的字符串。它可以帮助你获得部分分。你可能不需要用到这个参数。这个参数的含义在【数据规模与约定】中 有具体的描述。 第 行个整数 表示编号的城市中驻扎军队的花费。 接下来 行，每行两个正整数，表示有一条uu到vv的双向道路。 接下来 行，第行四个整数，表示第个要求是在城市驻扎支军队， 在城市驻扎支军队。其中，、 的取值只有或：若 为，表示城市 不得驻 扎军队，若 为，表示城市 必须驻扎军队；若为，表示城市不得驻扎军队， 若为，表示城市 必须驻扎军队。 输入文件中每一行相邻的两个数据之间均用一个空格分隔。 Output 输出共 行，每行包含 个整数，第行表示在满足国王第个要求时的最小开销， 如果无法满足国王的第个要求，则该行输出 。 Sample Input 1234567895 3 C3 2 4 1 3 9 1 5 5 2 5 3 3 4 1 0 3 0 2 1 3 1 1 0 5 0 Sample Output 12312 7 -1 Hint 【样例解释】 对于第一个要求，在 号和 号城市驻扎军队时开销最小。 对于第二个要求，在 号、 号、 号城市驻扎军队时开销最小。 第三个要求是无法满足的，因为在 号、 号城市都不驻扎军队就意味着由道路直接连 接的两座城市中都没有驻扎军队。 【数据规模与约定】 对于 的数据， 数据类型的含义： ：城市ii与城市直接相连。 ：任意城市与城市 的距离不超过 （距离定义为最短路径上边的数量），即如果这棵树以 号城市为根，深度不超过 。 ：在树的形态上无特殊约束。 ：询问时保证即要求在城市 驻军。对没有限制。 ：询问时保证是相邻的（由一条道路直接连通） ：在询问上无特殊约束。 Solution 考场上并不会，前几天先写了个简简单单的倍增然后就草到榜一，主要就是比一般倍增记自己状态外多记父亲是否取的状态，这样才能转移 表示的级祖先在是否取及的级祖先是否取时的答案转移即是（是否取）（级祖先是否取）的级祖先（级祖先是否取级祖先是否取是否取（级祖先是否取边界情况时即自己和父亲 查询时像求一样往上倍增即可还有注意到计算方法是先减去原来这条链的答案再加现在这条链的答案。（搞不清楚循环咋搞的可以循环展开）可能会快个左右并不太大影响记得数组不要开小以及就行居然没调很久2A。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include&lt;bits/stdc++.h&gt;#define FIO \"defense\"#define ll long longusing namespace std;const int N=1e5+5;const ll INF=1e15;char type[5];int w[N],n,m,u,v,dep[N],x,y;int ecnt,head[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],fa[N][18];ll dp[N][2],f[N][18][2][2],cur[2][2],tmp[2][2];inline void add(int u,int v){nxt[++ecnt]=head[u];head[u]=ecnt;to[ecnt]=v;}inline void dfs1(int u,int p){ fa[u][0]=p;dp[u][1]=w[u];dep[u]=dep[p]+1; for(int i=1;i&lt;18;i++)fa[u][i]=fa[fa[u][i-1]][i-1]; for(int i=head[u],v;i;i=nxt[i])if((v=to[i])^p){dfs1(v,u);dp[u][0]+=dp[v][1];dp[u][1]+=min(dp[v][0],dp[v][1]);}}inline void dfs2(int u,int p){ f[u][0][0][0]=INF; f[u][0][1][0]=dp[p][0]; f[u][0][1][1]=dp[p][1]-min(dp[u][0],dp[u][1])+dp[u][1]; f[u][0][0][1]=dp[p][1]-min(dp[u][0],dp[u][1])+dp[u][0]; for(int i=1;i&lt;18;i++){ int t=fa[u][i-1]; f[u][i][0][0] = min(f[t][i-1][0][0]-dp[t][0]+f[u][i-1][0][0], f[t][i-1][1][0]-dp[t][1]+f[u][i-1][0][1]); f[u][i][1][0] = min(f[t][i-1][0][0]-dp[t][0]+f[u][i-1][1][0], f[t][i-1][1][0]-dp[t][1]+f[u][i-1][1][1]); f[u][i][0][1] = min(f[t][i-1][0][1]-dp[t][0]+f[u][i-1][0][0], f[t][i-1][1][1]-dp[t][1]+f[u][i-1][0][1]); f[u][i][1][1] = min(f[t][i-1][0][1]-dp[t][0]+f[u][i-1][1][0], f[t][i-1][1][1]-dp[t][1]+f[u][i-1][1][1]); /* 等价于 for(int j=0;j&lt;=1;j++) for(int k=0;k&lt;=1;k++) f[u][i][j][k]=min(f[t][i-1][0][k]-dp[t][0]+f[u][i-1][j][0],f[t][i-1][1][k]-dp[t][1]+f[u][i-1][j][1]); */ } for(int i=head[u],v;i;i=nxt[i])if((v=to[i])^p)dfs2(v,u);}int main(){ freopen(FIO\".in\",\"r\",stdin); freopen(FIO\".out\",\"w\",stdout); scanf(\"%d%d%s\",&amp;n,&amp;m,type); for(int i=1;i&lt;=n;i++)scanf(\"%d\",&amp;w[i]); for(int i=1;i&lt;n;i++)scanf(\"%d%d\",&amp;u,&amp;v),add(u,v),add(v,u); dfs1(1,0);dfs2(1,0); while(m--){ scanf(\"%d%d%d%d\",&amp;u,&amp;x,&amp;v,&amp;y); if(!x&amp;&amp;!y&amp;&amp;(fa[u][0]==v||fa[v][0]==u)){puts(\"-1\");continue;} if(dep[u]&lt;dep[v])swap(u,v),swap(x,y); cur[0][0]=x?INF:dp[u][0]; cur[0][1]=x?dp[u][1]:INF; cur[1][0]=y?INF:dp[v][0]; cur[1][1]=y?dp[v][1]:INF; for(int i=17;~i;i--)if(dep[fa[u][i]]&gt;=dep[v]){ tmp[0][0]=min(f[u][i][0][0]-dp[u][0]+cur[0][0],f[u][i][1][0]-dp[u][1]+cur[0][1]); tmp[0][1]=min(f[u][i][0][1]-dp[u][0]+cur[0][0],f[u][i][1][1]-dp[u][1]+cur[0][1]); cur[0][0]=tmp[0][0];cur[0][1]=tmp[0][1]; u=fa[u][i]; } if(u==v){ if(y)cur[0][0]=INF;else cur[0][1]=INF; }else{ for(int i=17;~i;i--)if(fa[u][i]^fa[v][i]){ tmp[0][0]=min(f[u][i][0][0]-dp[u][0]+cur[0][0],f[u][i][1][0]-dp[u][1]+cur[0][1]); tmp[0][1]=min(f[u][i][0][1]-dp[u][0]+cur[0][0],f[u][i][1][1]-dp[u][1]+cur[0][1]); tmp[1][0]=min(f[v][i][0][0]-dp[v][0]+cur[1][0],f[v][i][1][0]-dp[v][1]+cur[1][1]); tmp[1][1]=min(f[v][i][0][1]-dp[v][0]+cur[1][0],f[v][i][1][1]-dp[v][1]+cur[1][1]); /* 等价于 for(int j=0;j&lt;=1;j++) for(int k=0;k&lt;=1;k++) tmp[j][k]=min(f[j?v:u][i][0][k]-dp[j?v:u][0]+cur[j][0],f[j?v:u][i][1][k]-dp[j?v:u][1]+cur[j][1]); */ memcpy(cur,tmp,sizeof cur); u=fa[u][i];v=fa[v][i]; } int p=fa[u][0]; tmp[1][0]=dp[p][0]-dp[u][1]-dp[v][1]; tmp[1][1]=dp[p][1]-min(dp[v][0],dp[v][1])-min(dp[u][0],dp[u][1]); tmp[0][0]=tmp[1][0]+cur[0][1]+cur[1][1]; tmp[0][1]=tmp[1][1]+min(cur[0][0],cur[0][1])+min(cur[1][0],cur[1][1]); cur[0][0]=tmp[0][0];cur[0][1]=tmp[0][1];u=p; } for(int i=17;~i;i--)if(fa[u][i]){ tmp[0][0]=min(f[u][i][0][0]-dp[u][0]+cur[0][0],f[u][i][1][0]-dp[u][1]+cur[0][1]); tmp[0][1]=min(f[u][i][0][1]-dp[u][0]+cur[0][0],f[u][i][1][1]-dp[u][1]+cur[0][1]); cur[0][0]=tmp[0][0];cur[0][1]=tmp[0][1];u=fa[u][i]; } printf(\"%lld\\n\",min(cur[0][0],cur[0][1])); } return 0;} 然后就是本文主角 (出场这么晚)的动态(动态动态规划orz)的做法，其实就是链剖然后用线段树维护矩阵。 注意转移轻链时的情况怎么写的。然而比倍增慢太多不开洛谷上T翻了其实是我写的丑。以及开(好奇会不会有考场上写正解忘开见祖宗的神犇) Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include&lt;bits/stdc++.h&gt;#define FIO \"defense\"#define ll long longusing namespace std;const int N=1e5+5;ll INF=1e15,F[2]={INF,-INF};char type[5];int n,m,u,v,x,y;int ecnt,head[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],fa[N],top[N];ll w[N],dp[N][2];int id[N],rnk[N],cnt,son[N],sz[N],len[N];inline void add(int u,int v){nxt[++ecnt]=head[u];head[u]=ecnt;to[ecnt]=v;}inline void dfs1(int u,int p){ fa[u]=p;dp[u][1]=w[u];sz[u]=1; for(int i=head[u],v;i;i=nxt[i])if((v=to[i])^p){ dfs1(v,u);sz[u]+=sz[v];if(!son[u]||sz[v]&gt;sz[son[u]])son[u]=v; dp[u][0]+=dp[v][1];dp[u][1]+=min(dp[v][0],dp[v][1]); }}inline void dfs2(int u,int t){ len[t]++;id[u]=++cnt;rnk[cnt]=u;top[u]=t;if(son[u])dfs2(son[u],t); for(int i=head[u],v;i;i=nxt[i])if((v=to[i])^fa[u]&amp;&amp;v^son[u])dfs2(v,v);}//id[u]=i rnk[i]=u#define mid ((l+r)&gt;&gt;1)#define lk (k&lt;&lt;1)#define rk (k&lt;&lt;1|1)struct matrix{ ll v[2][2]; matrix(){v[0][0]=v[0][1]=v[1][0]=v[1][1]=INF;} inline ll *operator [](int x){return v[x];} matrix operator *(matrix t){ matrix ret; for(int i=0;i&lt;2;i++)for(int j=0;j&lt;2;j++)for(int k=0;k&lt;2;k++)ret[i][j]=min(ret[i][j],v[i][k]+t[k][j]); return ret; }}a[N&lt;&lt;2],val[N];inline void pushup(int k){a[k]=a[lk]*a[rk];}inline void build(int k,int l,int r){ if(l==r){ ll &amp;g0=a[k][0][1],&amp;g1=a[k][1][0]; g0=0;g1=w[rnk[l]]; for(int u=rnk[l],i=head[u],v;i;i=nxt[i])if((v=to[i])^fa[u]&amp;&amp;v^son[u]) g0+=dp[v][1],g1+=min(dp[v][0],dp[v][1]); a[k][1][1]=g1; val[l]=a[k]; return; } build(lk,l,mid);build(rk,mid+1,r); pushup(k);}inline matrix qry(int k,int l,int r,int ql,int qr){ if(ql&lt;=l&amp;&amp;r&lt;=qr)return a[k]; if(qr&lt;=mid)return qry(lk,l,mid,ql,qr); if(mid&lt;ql)return qry(rk,mid+1,r,ql,qr); return qry(lk,l,mid,ql,mid)*qry(rk,mid+1,r,mid+1,qr);}inline matrix qry(int u){return qry(1,1,n,id[u],id[u]+len[u]-1);}inline void modify(int k,int l,int r,int pos){ if(l==r){a[k]=val[l];return;} if(pos&lt;=mid)modify(lk,l,mid,pos); else modify(rk,mid+1,r,pos); pushup(k);}#undef mid#undef lk#undef rkinline void modify(int u,ll x){ val[id[u]][1][0]+=x-w[u];val[id[u]][1][1]=val[id[u]][1][0];w[u]=x; matrix pre,nxt; while(u){ pre=qry(top[u]); modify(1,1,n,id[u]); nxt=qry(top[u]); u=fa[top[u]]; val[id[u]][0][1]+=nxt[1][1]-pre[1][1]; val[id[u]][1][0]+=min(nxt[0][1],nxt[1][1])-min(pre[0][1],pre[1][1]); val[id[u]][1][1]=val[id[u]][1][0]; }}int main(){ freopen(FIO\".in\",\"r\",stdin); freopen(FIO\".out\",\"w\",stdout); scanf(\"%d%d%s\",&amp;n,&amp;m,type); for(int i=1;i&lt;=n;i++)scanf(\"%lld\",&amp;w[i]); for(int i=1;i&lt;n;i++)scanf(\"%d%d\",&amp;u,&amp;v),add(u,v),add(v,u); dfs1(1,0); dfs2(1,1); build(1,1,n); while(m--){ scanf(\"%d%d%d%d\",&amp;u,&amp;x,&amp;v,&amp;y); if(!x&amp;&amp;!y&amp;&amp;(fa[u]==v||fa[v]==u)){puts(\"-1\");continue;} int tmp1=w[u],tmp2=w[v]; modify(u,F[x]);modify(v,F[y]); matrix ans=qry(1); printf(\"%lld\\n\",min(ans[0][1],ans[1][1])+(x?tmp1-F[x]:0)+(y?tmp2-F[y]:0)); modify(u,tmp1);modify(v,tmp2); } return 0;} 洛谷4719 Description 给定一棵个点的树，点带点权。 有次操作，每次操作给定表示修改点的权值为。 你需要在每次操作之后求出这棵树的最大权独立集的权值大小。 ### Input 第一行，分别代表点数和操作数。 第二行， 代表个点的权值。 接下来行，,描述这棵树的条边。 接下来行，,修改点的权值为。 Output 对于每个操作输出一行一个整数，代表这次操作后的树上最大权独立集。 保证答案在范围内 Hint 对于的数据， 对于的数据， 对于的数据， Solution 动态求树上最大权独立集板子，想法类似刚才那道题。 所以考吗? 注意什么时候是什么时候是不要搞反以及矩阵初值是零不是就好(鬼知道这两个东西我找了多久) Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110#include&lt;bits/stdc++.h&gt;#define FIO \"P4719\"using namespace std;const int N=1e5+5,INF=1e9;int w[N],n,m,top[N],rnk[N],id[N],cnt,x,y,f[N][2];int head[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],ecnt,sz[N],son[N],fa[N],len[N];namespace tree{ inline void add(int u,int v){nxt[++ecnt]=head[u];head[u]=ecnt;to[ecnt]=v;} inline void dfs1(int u){ sz[u]=1;f[u][1]=max(w[u],0); for(int i=head[u],v;i;i=nxt[i])if((v=to[i])^fa[u]){ fa[v]=u;dfs1(v);sz[u]+=sz[v]; f[u][0]+=max(f[v][0],f[v][1]);f[u][1]+=f[v][0]; if(!son[u]||sz[v]&gt;sz[son[u]])son[u]=v; } } inline void dfs2(int u,int t){ rnk[++cnt]=u;id[u]=cnt;top[u]=t;len[t]++; if(son[u])dfs2(son[u],t); for(int i=head[u],v;i;i=nxt[i])if((v=to[i])^fa[u]&amp;&amp;v^son[u])dfs2(v,v); } inline void build(){ for(int i=1;i&lt;n;i++)scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),add(y,x); dfs1(1);dfs2(1,1); }}namespace seg{ struct matrix{ int v[2][2]; matrix(){v[0][0]=v[0][1]=v[1][0]=v[1][1]=0;} inline int *operator[](int x){return v[x];} matrix operator *(matrix t){ matrix ret; for(int i=0;i&lt;2;i++)for(int j=0;j&lt;2;j++)for(int k=0;k&lt;2;k++)ret[i][j]=max(ret[i][j],v[i][k]+t[k][j]); return ret; } inline void out(){ printf(\"%d %d\\n%d %d\\n-----\\n\",v[0][0],v[0][1],v[1][0],v[1][1]); } }a[N&lt;&lt;2],val[N];#define mid ((l+r)&gt;&gt;1)#define lk (k&lt;&lt;1)#define rk (k&lt;&lt;1|1) inline void pushup(int k){a[k]=a[lk]*a[rk];} inline void build(int k,int l,int r){ if(l==r){ int &amp;g0=a[k][0][0],&amp;g1=a[k][1][0]; g0=0;g1=w[rnk[l]]; for(int u=rnk[l],i=head[u],v;i;i=nxt[i])if((v=to[i])^fa[u]&amp;&amp;v^son[u]) g0+=max(f[v][0],f[v][1]),g1+=f[v][0]; a[k][0][1]=g0; val[l]=a[k]; return; } build(lk,l,mid);build(rk,mid+1,r); pushup(k); } inline matrix qry(int k,int l,int r,int ql,int qr){ if(ql&lt;=l&amp;&amp;r&lt;=qr)return a[k]; if(qr&lt;=mid)return qry(lk,l,mid,ql,qr); if(mid&lt;ql)return qry(rk,mid+1,r,ql,qr); return qry(lk,l,mid,ql,mid)*qry(rk,mid+1,r,mid+1,qr); } inline void modify(int k,int l,int r,int pos){ if(l==r){a[k]=val[l];return;} if(pos&lt;=mid)modify(lk,l,mid,pos);else modify(rk,mid+1,r,pos); pushup(k); } inline void output(int k,int l,int r){ if(l==r){printf(\"%d~%d\\n\",l,r); a[k].out();return;} output(lk,l,mid);output(rk,mid+1,r); printf(\"%d~%d\\n\",l,r); a[k].out(); } //id[u]=i rnk[i]=u#undef mid#undef lk#undef rk inline matrix qry(int u){return qry(1,1,n,id[u],id[u]+len[u]-1);} inline void modify(int u,int v) { val[id[u]][1][0]+=v-w[u]; w[u]=v; matrix pre,nxt; while(u){ pre=qry(top[u]); modify(1,1,n,id[u]); nxt=qry(top[u]); u=fa[top[u]]; val[id[u]][0][0]+=max(nxt[0][0],nxt[1][0])-max(pre[0][0],pre[1][0]); val[id[u]][0][1]=val[id[u]][0][0]; val[id[u]][1][0]+=nxt[0][0]-pre[0][0]; } }}int main(){ freopen(FIO\".in\",\"r\",stdin); freopen(FIO\".out\",\"w\",stdout); scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)scanf(\"%d\",&amp;w[i]); tree::build(); seg::build(1,1,n); while(m--){ scanf(\"%d%d\",&amp;x,&amp;y); seg::modify(x,y); //seg::output(1,1,n); seg::matrix ans=seg::qry(1); printf(\"%d\\n\",max(ans[0][0],ans[1][0])); } return 0;} 洛谷p4751 Description 同上题，强制在线 Hint , Solution （这难度咋跟上一道一样啊=.=可能是没有更高的了吧？？？）然而你谷日常入门难度打NOI+。 卡强制在线的毒瘤玩意，不过之前也不会什么离线乱搞算法，但是之前的树剖肯定于是学习了一下一个叫全局平衡二叉树的毒瘤玩意 主要想法就是考虑为什么树剖不行？个大小为的节点组成一个二叉树（堆状树）就完美挂掉了，据说对每条重链开一颗线段树可以过，但是现在好像被出题人改数据后过不了，然后又对前个询问离线下来加点权使得更接近中点结果也被卡了。数据加强了这么几次导致我做这题的时候写正解也被卡了 回到这题，本来除了链剖还有一种的做法，可惜常数太大过不了这题，而且这题平衡树可以不用改变形态，那么这传说中的全局平衡二叉树究竟是个什么玩意？ 主要思想是先链剖，然后对于每条重链找重心建平衡树，不过每个点的权重是轻儿子的个数，找到这个中心后重链左右两边再递归建下去就行，这样整颗平衡树的深度是级别的。 为什么？ 如果是重链上的父子，每次向上跳的时候子树大小（这里的子树都是平衡树上的子树，以下类同）至少乘二，（最小的情况是原树这一条链上没有任何其他节点即没有轻儿子），然后对于非重链上的父子，每次向上跳的时候子树大小也会严格大于当前子树大小乘二（因为原树上它父亲至少还有一个重儿子大小大于当前子树大小，不然它就成重儿子了），所以每次在平衡树边向上跳时子树大小都至少乘二，所以总的高度是级别。注意到是平衡树不是线段树所以pushutp时要而不是 123456789101112131415161718192021222324252627//初始化inline void init(int k){ b[k][0][0]=b[k][0][1]=dp[k][0];b[k][1][0]=dp[k][1];}//建二叉树inline int build2(int l,int r){ if(l&gt;r)return 0; int sum=0; for(int i=l;i&lt;=r;i++)sum+=sz[st[i]]; for(int i=l,k=st[i],cur=sz[k];i&lt;=r;i++,k=st[i],cur+=sz[k])if((cur&lt;&lt;1)&gt;=sum){ lk=build2(l,i-1);rk=build2(i+1,r); fa[lk]=fa[rk]=k;pushup(k); return k; } return 0;}//建原树inline int build(int x,int t){ for(int u=x;u;t=u,u=son[u]){ for(int i=head[u],v;i;i=nxt[i])if((v=to[i])^t&amp;&amp;v^son[u])fa[build(v,u)]=u; init(u); } cnt=0; for(int u=x;u;u=son[u]) st[++cnt]=u,sz[u]-=sz[son[u]]; return build2(1,cnt);} 还有注意到这题卡常，大输入输出优化+循环展开+自定义max才过的... Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;bits/stdc++.h&gt;#define FIO \"p4751\"using namespace std;const int N=1e6+5,INF=1e9;inline int maxx(int a,int b){return a&gt;b?a:b;}int w[N],n,m,x,y,lst,dp[N][2],fa[N],sz[N],son[N],rt,ch[N][2];int head[N],nxt[N&lt;&lt;1],to[N&lt;&lt;1],ecnt,cnt,st[N];char buf[1&lt;&lt;20];int bufl,bufr;#define getch ((bufl^bufr||(bufl=0,bufr=fread(buf,1,1&lt;&lt;20,stdin)))?buf[bufl++]:EOF)template &lt;class T&gt;inline void read(T &amp;x){T f=1;x=0;char ch=getch;for(;!isdigit(ch)&amp;&amp;ch!='-';ch=getch);if(ch=='-')f=-1,ch=getch;for(;isdigit(ch);ch=getch)x=x*10+ch-'0';x*=f;}char ss[30000010],tt[20];int ssl,ttl;inline int print(int x){ if(!x) ss[++ssl]='0';for(ttl=0;x;x/=10) tt[++ttl]=char(x%10+'0'); for(;ttl;ttl--) ss[++ssl]=tt[ttl];return ss[++ssl]='\\n';}inline void add(int u,int v){nxt[++ecnt]=head[u];head[u]=ecnt;to[ecnt]=v;}inline void dfs1(int u,int t){ sz[u]=1;dp[u][1]=w[u]; for(int i=head[u],v;i;i=nxt[i])if((v=to[i])^t){ dfs1(v,u);sz[u]+=sz[v]; dp[u][0]+=maxx(dp[v][0],dp[v][1]); dp[u][1]+=dp[v][0]; if(!son[u]||sz[son[u]]&lt;sz[v])son[u]=v; }}inline void dfs2(int u,int t){ if(!son[u])return; dp[u][0]-=maxx(dp[son[u]][0],dp[son[u]][1]); dp[u][1]-=dp[son[u]][0]; for(int i=head[u],v;i;i=nxt[i])if((v=to[i])^t) dfs2(v,u);}struct matrix{ int v[2][2]; inline int* operator [](int x){return v[x];} matrix(){v[0][0]=v[0][1]=v[1][0]=v[1][1]=-INF;} matrix operator *(matrix &amp;t){ matrix ret; ret[0][0]=maxx(v[0][0]+t[0][0],v[0][1]+t[1][0]); ret[0][1]=maxx(v[0][0]+t[0][1],v[0][1]+t[1][1]); ret[1][0]=maxx(v[1][0]+t[0][0],v[1][1]+t[1][0]); ret[1][1]=maxx(v[1][0]+t[0][1],v[1][1]+t[1][1]); return ret; } void out(){printf(\"%d %d\\n%d %d\\n-----\\n\",v[0][0],v[0][1],v[1][0],v[1][1]);}}a[N],b[N];#define lk ch[k][0]#define rk ch[k][1]inline void init(int k){ b[k][0][0]=b[k][0][1]=dp[k][0];b[k][1][0]=dp[k][1];}inline void pushup(int k){ a[k]=a[lk]*b[k]*a[rk];}inline int build2(int l,int r){ if(l&gt;r)return 0; int sum=0; for(int i=l;i&lt;=r;i++)sum+=sz[st[i]]; for(int i=l,k=st[i],cur=sz[k];i&lt;=r;i++,k=st[i],cur+=sz[k])if((cur&lt;&lt;1)&gt;=sum){ lk=build2(l,i-1);rk=build2(i+1,r); fa[lk]=fa[rk]=k;pushup(k); return k; } return 0;}inline void modify(int u,int x){ dp[u][1]+=x-w[u];w[u]=x; int pre[2],nxt[2]; for(;u;u=fa[u]){ pre[0]=maxx(a[u][0][0],a[u][0][1]); pre[1]=maxx(a[u][1][0],a[u][1][1]); init(u);pushup(u); nxt[0]=maxx(a[u][0][0],a[u][0][1]); nxt[1]=maxx(a[u][1][0],a[u][1][1]); if(u^ch[fa[u]][0]&amp;&amp;u^ch[fa[u]][1]){ dp[fa[u]][0]+=maxx(nxt[0],nxt[1])-maxx(pre[0],pre[1]); dp[fa[u]][1]+=nxt[0]-pre[0]; } }}#undef lk#undef rkinline int build(int x,int t){ for(int u=x;u;t=u,u=son[u]){ for(int i=head[u],v;i;i=nxt[i])if((v=to[i])^t&amp;&amp;v^son[u])fa[build(v,u)]=u; init(u); } cnt=0; for(int u=x;u;u=son[u]) st[++cnt]=u,sz[u]-=sz[son[u]]; return build2(1,cnt);}int main(){ freopen(FIO\".in\",\"r\",stdin); freopen(FIO\".out\",\"w\",stdout); read(n);read(m); for(int i=1;i&lt;=n;i++)read(w[i]); for(int i=1;i&lt;n;i++)read(x),read(y),add(x,y),add(y,x); dfs1(1,0);dfs2(1,0); //左右儿子为空时的的判断 a[0][0][0]=a[0][1][1]=0;a[0][0][1]=a[0][1][0]=-INF; rt=build(1,0); while(m--){ read(x);read(y); x^=lst; modify(x,y); print(lst=(maxx(maxx(a[rt][0][0],a[rt][0][1]),maxx(a[rt][1][0],a[rt][1][1])))); } return fwrite(ss+1,sizeof(char),ssl,stdout),0;} BZOJ4712 Description 小A走到一个山脚下，准备给自己造一个小屋。这时候，小A的朋友（op，又叫管理员）打开了创造模式，然后飞到山顶放了格水。于是小A面前出现了一个瀑布。作为平民的小A只好老实巴交地爬山堵水。那么问题来了：我们把这个瀑布看成是一个个节点的树，每个节点有权值（爬上去的代价）。小A要选择一些节点，以其权值和作为代价将这些点删除（堵上），使得根节点与所有叶子结点不连通。问最小代价。不过到这还没结束。小A的朋友觉得这样子太便宜小A了，于是他还会不断地修改地形，使得某个节点的权值发生变化。不过到这还没结束。小A觉得朋友做得太绝了，于是放弃了分离所有叶子节点的方案。取而代之的是，每次他只要在某个子树中（和子树之外的点完全无关）。于是他找到你。 ### Input 输入文件第一行包含一个数，表示树的大小。 接下来一行包含个数，表示第个点的权值。 接下来行每行包含两个数，。表示书中有一条边（，）。 接下来一行一个整数，表示操作的个数。 接下来行每行表示一个操作，若该行第一个数为，则表示询问操作，后面跟一个参数，表示对应子树的根；若为，则表示修改操作，后面接两个参数，，表示将点的权值加上。 ，保证任意都为非负数 Output 对于每次询问操作，输出对应的答案，答案之间用换行隔开。 Sample Input 1234567891044 3 2 11 21 34 24Q 1Q 2C 4 10Q 1 Sample Output 123314 Solution 矩阵转移 是的轻儿子 注意qry时是id[u],id[top[u]+len[u]-1]不是id[top[u],id[top[u]+len[u]-1] 还有不能直接用，原因...很浅显了，可为什么第一次写的时候想不到呢（答：为了压行） 还有又双叒叕没开long long 以及这东西调起来真爽 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;bits/stdc++.h&gt;#define FIO \"4712\"#define ll long longusing namespace std;const int N=2e5+5;const ll INF=1e15;int w[N],n,x,y,head[N],to[N&lt;&lt;1],nxt[N&lt;&lt;1],ecnt;ll dp[N],g[N];int top[N],id[N],rnk[N],fa[N],dep[N],son[N],sz[N],len[N],cnt,q;char ch;inline void add(int u,int v){nxt[++ecnt]=head[u];head[u]=ecnt;to[ecnt]=v;}inline void dfs1(int u){ sz[u]++; for(int i=head[u],v;i;i=nxt[i])if((v=to[i])^fa[u]){ a[v]=u;dep[v]=dep[u]+1;dfs1(v);sz[u]+=sz[v];if(!son[u]||sz[v]&gt;sz[son[u]])son[u]=v; }}//id[u]=i rnk[i]=uinline void dfs2(int u,int t){ top[u]=t;len[t]++; id[u]=++cnt;rnk[cnt]=u; if(son[u])dfs2(son[u],t),dp[u]+=dp[son[u]]; for(int i=head[u],v;i;i=nxt[i])if((v=to[i])^fa[u]&amp;&amp;v^son[u]) dfs2(v,v),g[u]+=dp[v]; if(!son[u])g[u]=INF,dp[u]=w[u]; else dp[u]=min(dp[u]+g[u],(ll)w[u]);}struct matrix{ ll v[2][2]; matrix(){v[0][0]=v[0][1]=v[1][0]=v[1][1]=INF;} inline ll* operator [](int x){ return v[x]; } matrix operator *(matrix t){ matrix ret; for(int i=0;i&lt;2;i++) for(int j=0;j&lt;2;j++) for(int k=0;k&lt;2;k++) ret[i][j]=min(ret[i][j],v[i][k]+t[k][j]); return ret; } inline void out(){printf(\"%lld %lld\\n%lld %lld\\n-----\\n\",v[0][0],v[0][1],v[1][0],v[1][1]);}}a[N&lt;&lt;2],val[N];#define mid ((l+r)&gt;&gt;1)#define lk (k&lt;&lt;1)#define rk (k&lt;&lt;1|1)inline void pushup(int k){a[k]=a[lk]*a[rk];}inline void build(int k,int l,int r){ if(l==r){ a[k][0][0]=g[rnk[l]];a[k][0][1]=w[rnk[l]];a[k][1][0]=a[k][1][1]=0; val[l]=a[k]; return; } build(lk,l,mid);build(rk,mid+1,r); pushup(k);}inline matrix qry(int k,int l,int r,int ql,int qr){ //if(k==1)printf(\"qrying%d-%d\\n\",ql,qr); if(ql&lt;=l&amp;&amp;r&lt;=qr)return a[k]; if(qr&lt;=mid)return qry(lk,l,mid,ql,qr); if(mid&lt;ql)return qry(rk,mid+1,r,ql,qr); return qry(lk,l,mid,ql,mid)*qry(rk,mid+1,r,mid+1,qr);}inline matrix qry(int u){ return qry(1,1,n,id[u],id[top[u]]+len[top[u]]-1); }inline void modify(int k,int l,int r,int pos){ if(l==r){a[k]=val[l];return;} if(pos&lt;=mid)modify(lk,l,mid,pos); else modify(rk,mid+1,r,pos); pushup(k);}inline void modify(int u,int x){ w[u]+=x;val[id[u]][0][1]+=x; while(u){ //printf(\"u=%d\\n\",u); matrix pre,nxt; pre=qry(top[u]); modify(1,1,n,id[u]); nxt=qry(top[u]); u=fa[top[u]]; //nxt.out();pre.out(); val[id[u]][0][0]+=nxt[0][1]-pre[0][1]; }}inline void output(int k,int l,int r){ printf(\"%d-%d\\n\",l,r);a[k].out(); if(l==r)return; output(lk,l,mid);output(rk,mid+1,r);}#undef mid#undef lk#undef rkint main(){ scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++)scanf(\"%d\",&amp;w[i]); for(int i=1;i&lt;n;i++)scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),add(y,x); dfs1(1); dfs2(1,1); build(1,1,n); scanf(\"%d%*c\",&amp;q); //for(int i=1;i&lt;=n;i++)printf(\"val%d:\\n\",i),val[i].out(); output(1,1,n); while(q--){ scanf(\"%c%d%*c\",&amp;ch,&amp;x); if(ch=='Q') { matrix ans=qry(x); printf(\"%lld\\n\",min(ans[0][1],ans[0][0])); //ans.out(); } else{ scanf(\"%d%*c\",&amp;y); modify(x,y); //for(int i=1;i&lt;=n;i++)printf(\"val%d:\\n\",i),val[i].out(); output(1,1,n); } } return 0;} BZOJ5210 Description 给出一棵个点、以为根的有根树，点有点权。要求支持如下两种操作： ：将点的点权改为； ：求以为根的子树的最大连通子块和。 其中，一棵子树的最大连通子块和指的是：该子树所有子连通块的点权和中的最大值 （本题中子连通块包括空连通块，点权和为）。 Input 第一行两个整数、，表示树的点数以及操作的数目。 第二行个整数，第个整数表示第个点的点权。 接下来的行，每行两个整数、，表示和之间有一条边相连。 接下来的行，每行输入一个操作，含义如题目所述。保证操作为或之一。 $1≤n,m≤200000 ，任意时刻 |w_i|≤10^9$ 。 Output 对于每个操作输出一行一个整数，表示询问子树的最大连通子块和。 Sample Input 123456789105 43 -2 0 3 -11 21 34 22 5Q 1M 4 1Q 1Q 2 Sample Output 123431 Solution （并不是）一眼得出转移式子 矩阵形式 $$ g[u]=_{v是u的轻儿子}{f[v]}\\ \\0 \\end{matrix} ]= +g[u]&amp;0\\ 0&amp;0\\ \\end{matrix} ] ]\\0 \\end{matrix} ] $$ 然后有点无聊开始写全局平衡二叉树练(cao)习(bang)。打到快一半才发现每次只是询问子树可能不能这么搞怒删行代码开始打线段树，然后发现可能要求的子块并不包含根，于是怀着这辈子不可能手打平衡树的想法就去搜了下题解发现直接可删堆就行了，而且矩阵也不是必要的，把一个点的虚儿子的贡献加在重链上这个点上后就相当于重链上查一个最大连续子段和，可以用线段树上的一般的搞法即记录每个点左边连续最大，右边连续最大，总共连续最大以及总和。 转移即为 可删堆的实现大家都懂就不赘讲了 注意数组开四倍因为是线段树上的点，由平衡树改成线段树的时候没改可能会调一会。 以及记得照着标程改完后能拍的起的时候记得测下样例，一会标程莫名其妙都改错了就直接。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116#include&lt;bits/stdc++.h&gt;#define FIO \"5210\"#define ll long long using namespace std;const int N=2e5+5,INF=1e9;int w[N],n,m,x,y,sz[N],fa[N],son[N],top[N];int h[N],to[N&lt;&lt;1],nxt[N&lt;&lt;1],ecnt,ch[N&lt;&lt;2][2],id[N],rnk[N],cnt,ptr,len[N],rt;ll f[N],g[N];inline void add(int u,int v){nxt[++ecnt]=h[u];h[u]=ecnt;to[ecnt]=v;}struct heap{ priority_queue&lt;ll&gt;de,q; inline ll top(){ while(!de.empty()&amp;&amp;!q.empty()&amp;&amp;q.top()==de.top())q.pop(),de.pop(); return q.empty()?0:q.top(); } inline void del(ll x){de.push(x);} inline void insert(ll x){q.push(x);}}q[N];//可删堆inline void dfs1(int u){ sz[u]=1;f[u]=w[u]; for(int i=h[u],v;i;i=nxt[i])if((v=to[i])^fa[u]){ fa[v]=u; dfs1(v); if(sz[v]&gt;sz[son[u]])son[u]=v; f[u]+=f[v]; sz[u]+=sz[v]; } f[u]=max(f[u],0ll);}inline ll dfs2(int u,int t){ ll ret=0; id[u]=++cnt;rnk[cnt]=u;top[u]=t;len[t]++; if(son[u])ret=dfs2(son[u],t); g[u]=w[u]; for(int i=h[u],v;i;i=nxt[i])if((v=to[i])^fa[u]&amp;&amp;v^son[u]) g[u]+=f[v],q[u].insert(dfs2(v,v)); return max(ret,max(f[u],q[u].top()));}struct node{ ll mx,lm,rm,sum; node(ll _mx=0,ll _lm=0,ll _rm=0,ll _sum=0){mx=_mx;lm=_lm;rm=_rm;sum=_sum;} node operator *(node t){ //合并两个node的操作，矩乘写惯了这题也用乘号 //建议对照上方构造函数 return node( max(rm+t.lm,max(mx,t.mx)), max(lm,sum+t.lm), max(t.rm,rm+t.sum), sum+t.sum); }}a[N&lt;&lt;2];#define lk ch[k][0]#define rk ch[k][1]#define mid ((l+r)&gt;&gt;1)inline void pushup(int k){ a[k]=a[lk]*a[rk]; }inline node qry(int k,int l,int r,int ql,int qr){ //fprintf(stderr,\"qrying%d-%d %d-%d\\n\",l,r,ql,qr); if(ql&lt;=l&amp;&amp;r&lt;=qr)return a[k]; if(qr&lt;=mid)return qry(lk,l,mid,ql,qr); if(mid&lt;ql)return qry(rk,mid+1,r,ql,qr); return qry(lk,l,mid,ql,mid)*qry(rk,mid+1,r,mid+1,qr);}inline node qry(int x){return qry(rt,1,n,id[x],id[top[x]]+len[top[x]]-1);}inline void init(int k,int u){ a[k].sum=g[u]; a[k].lm=a[k].rm=max(0ll,g[u]); a[k].mx=max(a[k].lm,q[u].top());}inline void build(int &amp;k,int l,int r){ k=++ptr; if(l==r){ init(k,rnk[l]); return; } build(lk,l,mid);build(rk,mid+1,r); pushup(k);}inline void modify(int k,int l,int r,int pos){ if(l==r){ init(k,rnk[l]); // if(l==2)printf(\"%d %d\\n\",a[k].lm,q[rnk[l]].top()); //printf(\"%d-%d\\n%lld %lld\\n%lld %lld\\n-----\\n\",l,r,a[k].lm,a[k].rm,a[k].sum,a[k].mx); return; } if(pos&lt;=mid)modify(lk,l,mid,pos);else modify(rk,mid+1,r,pos); pushup(k);}inline void modify(int u,ll del){ node pre,nxt; bool flag; while(u){ pre=qry(top[u]); g[u]+=del; //printf(\"gu=%lld\\n\",g[u]); modify(rt,1,n,id[u]); nxt=qry(top[u]); del=nxt.lm-f[top[u]];f[top[u]]=nxt.lm; //nxt.lm相当于新的这条重链上0或者包含top[u]的这个连通块（一条链）的最值 u=fa[top[u]]; if(u)q[u].del(pre.mx),q[u].insert(nxt.mx); //top[u]是fa[top[u]]的虚儿子，所以需要在对应的堆里进行更改 }}int main(){ scanf(\"%d%d\",&amp;n,&amp;m); for(int i=1;i&lt;=n;i++)scanf(\"%d\",&amp;w[i]); for(int i=1;i&lt;n;i++)scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),add(y,x); dfs1(1);dfs2(1,1); build(rt,1,n); while(m--){ char ch=getchar(); while(ch!='M'&amp;&amp;ch!='Q')ch=getchar(); scanf(\"%d\",&amp;x); if(ch=='M')scanf(\"%d\",&amp;y),modify(x,y-w[x]),w[x]=y; else printf(\"%lld\\n\",qry(x).mx); } return 0;} 总结 动态DP真是个不错的东西，它与题目半身的关联性不大，所以适用范围还是比较广的，啥时候想练练码力了可以来做一做，而且调试起来还非常方(e)便(du)。相信当你在一个寒冷的深冬的夜晚抬起头来，手指早已冻僵却仍不住的按着F5，屏幕终于从一直的时而泛紫又时候泛红到泛起一道绿光改了无数遍丑的看不下去的代码终于过了的时候,你一定会由衷的对该题的出题人表示 : ********！","categories":[{"name":"总结","slug":"总结","permalink":"https://20021123.xyz/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"DP","slug":"DP","permalink":"https://20021123.xyz/tags/DP/"},{"name":"动态DP","slug":"动态DP","permalink":"https://20021123.xyz/tags/%E5%8A%A8%E6%80%81DP/"}]},{"title":"NOIP2018杂记","slug":"NOIP2018杂记","date":"2018-11-14T14:55:08.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2018/11/14/NOIP2018杂记/","link":"","permalink":"https://20021123.xyz/2018/11/14/NOIP2018%E6%9D%82%E8%AE%B0/","excerpt":"","text":"DAY 0 考前默默打了下配置文件练手，记不到怎么调用系统复制粘贴啥的啥啥啥的，准备用自带的辣鸡寄存器复制粘贴就学习了一下命令 1234ggVG //全选\"+y //复制到系统寄存器\"+p //粘贴到系统寄存器 然后有次模拟赛就复制输入的时候出锅调试半天结果GG。。。一整天就写了几道代码量短的题，本来想打道树套树板子怕调不出来影响信心并且NOIP不考就弃了。或者是所谓的“超量恢复”？不是很懂，反正当年体考前几天也没有再跑长跑了，或许有用？ 问题就是下午到家的时候开始肚子痛，喝了点热水没啥用，当时心里还是有点慌的毕竟最后一天了不能这种时候掉链子，然后默默坐地铁，人又多又挤没座位，到站的时候各种不爽感觉凉凉，然后走到一个垃圾桶旁就吐了然后感觉好多了=.=。然后还是不能大意到酒店喝了点啥药然后好得差不多了，出去考前最后集合了一下然后回来看了下很久没看的前面内容都挺傻吊的一本通提高版 的tarjan求强连通分量然后洗洗睡了，居然没有失眠。 DAY 1 早上起来吃两个小包子不敢吃多了害怕肚子不舒服，然后一行人走去考场，一堆人开始毒奶（所以DAY1如此傻吊）一堆神仙玩意，到场没多久就进去了 进场发现过道有矿泉水和面包当时想的是会发结果并没有，然后就走到考场坐下，发现我们学校的一个高二神犇在前面问了老师哪个盘不会被清空，我都忘了这回事去问了下然后彼此点了下头就坐下了，并不让碰键盘然后就呆坐，想过上厕所但觉得不必要反而会会徒增紧张感就并没有去，然后发网络地址，开始码配置文件，发现自带mswin真好，码完配置文件编译不起发现是没加&lt;ESC&gt;还行，然后还是打了个快读板子，一遍打对没有出错涨了点自信，头文件不用bits就只用三个cstdio iostream algorithm 然后发密码飞雪连天可能是纪念金庸先生的，接下来打开第一题第一眼单调栈矩形覆盖第二眼发现傻逼原题，10分钟切了一遍过大样例稳稳，然后随便写了个玄学的暴力过了大样例开始拍。 第二题第一眼同余最短路，第二眼神仙题不可做，瞎搞搞发现有点像个背包，发现从小到大第一个不能表示的就必定在最小的系统中，比最小的数小的一定不合法，比最大的数大的一定不优想到这都没发现必定在原来的几个数中也是菜死了然后搞到九点半一遍过样例，最后半小时才发现所有部分分要开到5000 x 5000还打了一个的特判直接输出也是后来才发现一个是另一个的倍数的时候可能有锅，还要特判（都到这里了怎么还没想到正解啊喂） 慌慌张张搞到九点半没有更优做法果断选择80分瞎打了一个的乱搞一遍过了大样例后想用优化发现有锅还是要右移次复杂度还不如直接不过反正是用来对拍的就写完开始拍，后来发现应该是(考完还担心了一下然后再冷静分析一下复杂度不是值域平方而是是调和级数，主要当时不知道最大开到多少才能保证正确性怕WA，现在一想只用开到最大的可能还是可以过的。（update:刚刚洛谷跑了一下多过了一个点85其他的TLE...）不过这是后话了)还是随便跑。 然后看T3，之前T2做不动的时候看了几眼可能就像语文考试先看作文一样，没有想但后台有了个大致的思路，然后一眼二分答案，再把题意理清了感觉就是个傻逼贪心，码码码，小样例随便过大样例居然WA，简直震惊，仔细分析算法正确性可能没啥锅，应该是打挂了，于是把一开始正确的从小到大贪心改成从大到小贪心（想的是反正改起来不难怎么样过了大样例就是对的，没有手推正确性，以后要注意避免）然后当然还是WA，而且答案一样，当时就震惊了，没啥办法，想到没测会不会CE，开了个虚拟机测了下T1,T2没CE还行（不会虚拟机D2T1就凉凉了后面会说），然后可能还剩一个多小时，T2当时心里想要么是个非常高级的算法几乎不可能当场推出来（主要的数据范围非常奇怪呀）或者是个非常傻吊的东西没想到，而且这种第一眼没想到后面就难以再想到了估计再去看也是浪费时间，于是全力调T3，刚刚刚，码码码…… 一看时间我去只剩20分钟了这毒瘤题怎么还没调出来，现在代码已经是千疮百孔了各种debug,cout以及特判特别毒瘤，心里开始慌张，冷静一下（就用冻手使劲搓自己脸几下）开始用纸笔推（发现这样可能才是最好的方法）发现应该从小到大贪心啊啊啊啊啊，然后改改改。 小样例都不对，还剩分钟，手心在冒汗，不自觉想这题爆零的话今天预估分数，然后锤自己一下强行停止。 想找之前能过小样例的错误做法来凑数，改.ans为.out放到D:/noip完成，还剩分钟。 发现mfind边界不对改之，能感受到手上由寒冷导致的僵硬，还剩分钟。 愣了一会通过cout发现有的up[u]没被更新导致答案偏小（现在一直测的是小样例），还剩分钟。 改改改，改好了测试，第一个点，第二个点,那么第三个大样例也不能放松之前的反向错误做法也能过前两个样例，那么答案是...鼠标滚轮快速的划过上方的调试信息，后突然醒悟用G快捷键，翻到底是吗（因为没有过过大样例不记得答案是啥了），手在发抖，还剩分钟。 因为手太紧张，点几次都没有点到，当时想的是这就最后一次了，没过就没过去检查文件了也没时间耗了，可能是完完全全算法错了吧。点开，。恩，还剩分钟，我过大样例了。 然后以可能是这天来手速的极限删掉了所有调试信息，一个个过了样例然后才像耗尽了全身力气一样的摊在了后一个人的桌前，（椅子没有靠背特别不爽，还有要吐槽的硬件就是backspace居然只占一格大小,回车占两行，斜杠(或者叫反斜杠反正就是\\n的这个)跑到退格键的左边去，导致换行的时候每次都按错特别影响速度） 然后检查应该没有啥问题，也没时间开虚拟机了（毒瘤电脑虚拟机开半天第二天还几乎接近崩溃了见下文）（没检查memset与memcpy第二天刺激CE导致考后有点慌，也是经常有类似的什么感觉文件名打错了了啊什么直接CE了啊这种心理确实不是很好以后要注意） 然后时间到，起立，关闭两个对拍，关闭vim走出去，看到高二神犇一句话“每个数可被删去当且仅当可被另外的数表示”，感觉自己菜爆了啊。出楼，一问感觉全世界就我不会T2，太菜了哎。然后去吃饭，一行人开始讨论今天的原题，结果神仙jmr发现O好像之前出过T2加强版（顺带一提O，佬，司都提前阿克立场了太强啦orz）就在校内OJ上果然我还是太菜了，然后UOJ群又有人在说T3原题，看了下还是有区别一个要求全覆盖一个不用，除了二分以外做法还是很不同的。然后下午到酒店闲得无聊看西酱退役记（文笔太好了）感慨一下自己这条路还是很险的，然后迷迷糊糊中某阿克DAY1的神犇找我打乒乓然而当时想睡觉把拍给他就咕咕了。 然后去吃晚饭，路上一直在想T2复杂度是多少感觉会遭卡成啊，整个人都不好了，更加确信了DAY1三道傻逼题以及就我不会T2这件事，菜没啥肉差评。 在酒店大厅的时候遇到蔺老还是说了一些稳住心态啊可以看一下高二的心态跟我们不一样什么的，然后就上去了，洛谷民间数据已出，5min手打T2居然分并且都只用过不到ms，推了一下复杂度的不禁感叹为啥不开大点不过当时也不知道这回事，怕T就没开那么大，还是做了一个非常明智的选择。过了一会蔺老到来“查房”（幸好没颓咕咕）说了一下今天的情况，以及下午看起来比较丧不是肚子痛而是担心T2的缘故，估分，说了一下明天题可能会难一点不要死磕一道啥啥啥的。然后睡前又看了一会tarjan，喝了药就睡觉了，不过今天睡的不是很好一直担心T3有没有关memset啥的会不会CE，以及只测了大样例会不会WA，非常纠结（以后还是要尽量避免这种）在迷迷糊糊中睡着了。 DAY 2 跑到酒店的餐厅吃早餐然后只有一两个小房间并不是想象的那种，吃了半个烤面包有点不舒服就没吃了，然后走到考场路上一群人怎么开始讨论普及组题啊是都阿克提高了没事干吗 然后进考场，这次拿了零食感觉很好。开始看T1感觉树的形态非常可做，基环树的形态手推贪心结果都被第二个小样例卡了，没法，一看数据范围，这数据范围加上i7的新机感觉是要的节奏，枚举一下环上每个边断开然后就行了，问题是直接调用的树上的函数导致每次都会sort一遍非常不好（听说有序数列是?可能可过？(update: 民间数据都没过=.=)）当时偷懒了没重新打一个，哎。一遍过了大样例再写了个每个边断一次开始拍就做T2去了，这题可能做了将近一个小时。 T2最开始看题的时候哎那么大那么小不是太明显的状压DP吗都连续出了好几年了哎…… 然后开始推式子，恩就是右下小于等于左上嘛式子一些，手算一下应该是对的，咋是???不管，先打了再说，然后确实是对的并且是错的更不用说了，冷静分析，可能思路错了，改为一个斜线一个斜线的考虑，只能是连续的然后全是嗯嗯……手算一下样例还是过不了，没办法，时间可能已经花太多，想到昨天说的不要刚太久，估计这题不简单，选择再打了个暴力，测了下发现所有时状压都是对的，然后就分了两个subtask骗50（咋不打表找找的情况呢其实也是时间花太多也担心找不到规律太浪费时间了） 然后数据生成的验证状压正确性开始拍，拍到一半卡起动不了点击关闭也关不了，任务管理器也不行，叫老师来捣鼓一会任务管理器后也无果，说不影响收题，愿意的话可以重启（这辈子不可能的）于是就缩小到最小放在边边上免得难看zz) 打开T3一看不带修改是个非常套路的树形DP，简单的码完分就只剩40多分钟了，剩下的分一看不可做也不硬钢了，也没啥事用虚拟机（打开虚拟机的时候卡机了一分钟，吓得赶紧像老师示意，结果老师看了几秒就自己好了搞得非常尴尬，不过好了是万幸）测了一下发现T1居然CE！！！论memcpy不加cstring的后果（以后不用bits的时候记得写四个头文件了）还是比较惊心动魄的，不过时间比较充裕，改完后继续对拍。 可能检查了几分钟的文件后猛的发现datamaker没有srand!!!这可真刺激，不过还是拍起了，问题不大=.=。 还有十多分钟的时候反应过来深度&lt;=100的点可以从下往上更新两条链的答案复杂度很对，不过写起来太麻烦而且怕调不出来就弃了。稳稳当当检查了十多遍文件名（昨天就几分钟检查，还在担心文件名有没有打挂）（第二天不担心文件名了，却担心没有看cena用户名会不会有锅，果然是操不完的心==）（DAY2确实没有DAY1那么惊心动魄主要后面的都不会了O.O，有大把时间检查） 然后出来一问T1果然懒的写sort复杂度多了个log有锅，其他的分都差不多，基本高一都是(就我不会T1系列)然后在门口照相，吐槽了一下两天题目难度差异如此巨大，T2据说分类讨论繁杂到佬都没写完？T3据说叫做动态DP？？？不管了反正没啥大的失误就还好，之后一行人去吃了个自助餐，感觉大家都稳省一了呀还是非常强的，然后就回家颓了。 后记 今天来看的话确实没有挂题非常优秀，然后就是小的细节上比最高预估的分少了一点，考场上的考试策略还是很对的，就是考后的心态要注意调整（考前还有点担心肚子会不会疼，果然身体是革命的本钱，平时注意锻炼这种事情才不会发生）总之这次NOIP算是超额完成省一的目标了（目标就这么低吗某神仙400+还嫌少呢=.=）至于冬令营啥的也是能去就去不能去算了，去了多半也是被吊打，总之对这个结果还是很满意了。 不管怎样高一的联赛已经落下帷幕，在接下来的日子里还需继续努力！！！😝😝😝","categories":[{"name":"随笔","slug":"随笔","permalink":"https://20021123.xyz/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://20021123.xyz/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"洛谷4921","slug":"洛谷4921","date":"2018-11-02T15:19:08.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2018/11/02/洛谷4921/","link":"","permalink":"https://20021123.xyz/2018/11/02/%E6%B4%9B%E8%B0%B74921/","excerpt":"","text":"洛谷4921 Description 有 对情侣来到电影院观看电影。在电影院，恰好留有 排座位，每排包含 个座位，共 个座位。 现在，每个人将会随机坐在某一个位置上，且恰好将这 个座位坐满。 如果一对情侣坐在了同一排的座位上，那么我们称这对情侣是和睦的。 你的任务是求出当 时，共有多少种不同的就坐方案满足恰好有 k 对情侣是和睦的。 两种就坐方案不同当且仅当存在一个人在两种方案中坐在了不同的位置。不难发现，一共会有 种不同的就坐方案。 Input 输入包含多组数据。 输入的第一行包含一个正整数 ，表示数据的组数。 接下来 行，每行包含一个正整数 。 Output 对于每组输入数据，输出共 行，每行包含 个整数，分别表示 时满足恰好有 对情侣是和睦的就坐方案数。由于结果可能较大，因此输出对 取模的结果。 Sample Input 123212 Sample Output 12345021608 Hint 本题只有一个 的数据点。。。暴力还是算了吧！ Solution 看到第一眼我会 然而没分（毒瘤） 并没有怎么做过错排于是就直接看题解了 记为我们要求的恰对情侣和睦的方案数 首先我们从对CP中选这对CP有种方案数，给这对CP找排座位有种方案，每一对人对应每一排座位共有种对应方法，这对CP每一对的两个人在同一排有两种坐法(男左女右or男右女左) 在这对CP就共种 然后呢？考虑剩下的被拆散的对CP怎么搞，而且这对CP的坐法好像和无关，Emmm...有点错排的味道了 记表示对CP坐排座位并且都被拆散的方案数 所以可以得到 类似错排考虑最后一个放哪里的方法，我们考虑最后一排的两个人的情况 现在这两个人有三种情况 两男 这两个人有种选法，考虑他们的两个配偶 钦定这两个女生不坐一起，所以把她俩看作一对CP防止配对(橘里橘气) 方案数为 钦定这两个女生坐一起，共有排位置可坐，两人可以交换位置，剩下对CP还是要被拆散，即方案数为 两女 同两男即可 一男一女（并不是CP）还是一样的考虑他们的两个配偶，转移类似，不过注意的是这一男一女的选择方案数是 而不是 (男A女B和男B女A两种) 所以得到递推式 边界然后就成水题了 Code 1234567891011121314151617181920212223242526272829303132333435#include&lt;bits/stdc++.h&gt;#define FIO \"P4921\"#define INF 0x3f3f3f#define DBUG(...) fprintf(stderr,__VA_ARGS__)typedef long long ll;const int MOD=998244353,MAXN=1e3;using namespace std;char buf[1&lt;&lt;20];int bufl,bufr;#define getch ((bufl^bufr||(bufl=0,bufr=fread(buf,1,1&lt;&lt;20,stdin)))?buf[bufl++]:EOF)template &lt;class T&gt;inline void read(T &amp;x){T f=1;x=0;char ch=getchar();for(;!isdigit(ch)&amp;&amp;ch!='-';ch=getchar());if(ch=='-')f=-1,ch=getchar();for(;isdigit(ch);ch=getchar())x=x*10+ch-'0';x*=f;}int N,T,f[MAXN+5],inv[MAXN+5],fac[MAXN+5],bin[MAXN+5];inline int mul(int a,int b){return (ll)a*b%MOD;}inline int add(int a,int b){a+=b;if(a&gt;=MOD)a-=MOD;return a;}inline int CC(int a,int b){ int t=mul(fac[a],mul(inv[b],inv[a-b])); return mul(t,t);}int main(){ freopen(FIO\".in\",\"r\",stdin); freopen(FIO\".out\",\"w\",stdout); fac[0]=inv[0]=fac[1]=inv[1]=bin[0]=1;bin[1]=2; for (int i=2;i&lt;=MAXN;i++) fac[i]=mul(fac[i-1],i),inv[i]=mul(MOD/i,add(MOD,-inv[MOD%i])),bin[i]=add(bin[i-1],bin[i-1]); for (int i=2;i&lt;=MAXN;i++) inv[i]=mul(inv[i],inv[i-1]); f[0]=1; for (int i=1;i&lt;=MAXN;i++) f[i]=mul(mul(i&lt;&lt;1,2*i-2),add(f[i-1],mul(2*i-2,f[i-2]))); read(T); while (T--){ read(N); for (int i=0;i&lt;=N;i++) printf(\"%d\\n\",mul(mul(mul(CC(N,i),bin[i]),fac[i]),f[N-i])); } return 0;}","categories":[{"name":"洛谷","slug":"洛谷","permalink":"https://20021123.xyz/categories/%E6%B4%9B%E8%B0%B7/"}],"tags":[{"name":"计数","slug":"计数","permalink":"https://20021123.xyz/tags/%E8%AE%A1%E6%95%B0/"},{"name":"错排","slug":"错排","permalink":"https://20021123.xyz/tags/%E9%94%99%E6%8E%92/"}]},{"title":"BZOJ4735","slug":"BZOJ4735","date":"2018-11-02T08:50:15.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2018/11/02/BZOJ4735/","link":"","permalink":"https://20021123.xyz/2018/11/02/BZOJ4735/","excerpt":"","text":"BZOJ4735 Description 众所周知，萌萌哒六花不擅长数学，所以勇太给了她一些数学问题做练习。但是今天六花酱不想做数学题，于是他们开始打牌。现在他们手上有 张不同的牌，牌有两种：普通牌和功能牌。功能牌一共有 张，每张功能牌都有一个属性值 ，保证 现在勇太将这 张牌随机打乱（一共有 种不同的顺序）。一开始，六花先从牌堆顶端取一张牌。接着每回合六花可以选择手中的一张牌打出，如果这张牌是普通牌，那么什么都不会发生；如果这种牌是功能牌，那么六花需要从牌堆顶端再取 张牌。重复这个过程直到六花手中没有手牌或六花要摸牌的时候牌堆已经空了，如果是前者，则勇太胜利，否则六花胜利。举例来说，如果牌堆是 {3，0，2，0，0）（用 0 表示普通牌，其他数字表示 ），那么六花打牌的过程可以为： 1) 取一张牌，手中的牌为 {3}。 2) 打出 {3}，再取三张牌，手中的牌为 {0，2，0}。 3) 打出这三张牌，还需要再取两张，取到第二张的时候牌堆中已没有牌，六花胜利。 而如果牌堆是 {2，0，0，3,0}，不难发现是勇太大胜利。现在，六花想要知道，这 M! 种顺序中，有多少种是能让自己取得胜利的呢。当然这个问题对萌萌哒六花来说实在是太雉了，所以她来向你寻求帮助，你能帮帮她吗。 Input 第一行一个整数$ n。第二行n$他个空格隔开的正整数 。 通过输入你可以自己算出来 ， ### Output 输出一个整数表示答案，答案可能很大，你只需要输出对 998244353 取模后的结果。 Sample Input 1213 Sample Output 12 Hint m! 种牌堆中，{3，0，0），{0，3，0）{0，0，3）各有两个，其中只有第一种满足条件。 Solution 神仙JMR推荐的神仙题，考场上遇到直接暴力走人... 再想到从顶端取牌相当于每次还可以摸的牌数，遇到一个特殊牌即可以多摸那么多张牌，记录下这个“还可以摸的牌数”就会发现，这个数（每张牌对应一个数，下同）的排列中，把每个数都好像是要求所有前缀和都大于等于。 好像卡特兰数但一仔细看是正数和不是和。所以GG 正解的话观察样例每个数都减一后形成的数列它的总和为零(废话) 于是可以在最后补一个即求除最后一项以外其他前缀和都大于的方案数，对这个数环排列(共种方案)每种环排列钦定这个多出来的放最后所以每种排列只有唯一对应的方案。 会发现有些方案重复计算了，具体是哪些呢，比如在第个处都被算了一遍所以方案要除以的个数即普通牌数加钦点的那张牌，也即是牌总数-功能牌数+钦点的的那张牌 所以答案表达式 十分简短沙雕 ### Code 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;#define FIO \"4735\"#define INF 0x3f3f3ftypedef long long ll;const int MOD=998244353;using namespace std;char buf[1&lt;&lt;20]; int bufl,bufr;#define getch ((bufl^bufr||(bufl=0,bufr=fread(buf,1,1&lt;&lt;20,stdin)))?buf[bufl++]:EOF)template &lt;class T&gt;inline void read (T &amp;x) { T f=1; x=0; char ch=getch; for (; !isdigit (ch)&amp;&amp;ch!='-'; ch=getch); if (ch=='-')f=-1,ch=getch; for (; isdigit (ch); ch=getch)x=x*10+ch-'0'; x*=f;}int N,M,ans=1,x;int main() { read (N); for (int i=1; i&lt;=N; i++)read (x),M+=x; for (int i=1; i&lt;=M; i++)if (i^M-N+1)ans= (ll)ans*i%MOD; printf (\"%d\\n\",ans); return 0;}","categories":[{"name":"BZOJ","slug":"BZOJ","permalink":"https://20021123.xyz/categories/BZOJ/"}],"tags":[{"name":"思维","slug":"思维","permalink":"https://20021123.xyz/tags/%E6%80%9D%E7%BB%B4/"},{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"LOJ4","slug":"loj4","date":"2018-10-24T14:49:48.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2018/10/24/loj4/","link":"","permalink":"https://20021123.xyz/2018/10/24/loj4/","excerpt":"","text":"LOJ4 Description 写一个程序，使其能输出自己的源代码。 代码中必须至少包含十个可见字符。 ### Input 无 ### Output 你的源代码 Solution 不是很懂为什么天天做水题=.= 复习一下常见字符表值 (然而背不到，可能有用的就是快读中以后可以直接用（即) ### Code 简单 123#include&lt;bits/stdc++.h&gt;const char *str=\"#include&lt;bits/stdc++.h&gt;%cconst char *str=%c%s%c;%cint main(){printf(str,10,34,str,34,10);}\";int main(){printf(str,10,34,str,34,10);} 以及一份来自神仙网友的更神仙的代码(。・∀・)ノ 1print(open(__file__).read())","categories":[{"name":"LOJ","slug":"LOJ","permalink":"https://20021123.xyz/categories/LOJ/"}],"tags":[{"name":"水题","slug":"水题","permalink":"https://20021123.xyz/tags/%E6%B0%B4%E9%A2%98/"}]},{"title":"BZOJ4289","slug":"BZOJ4289","date":"2018-10-23T07:17:24.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2018/10/23/BZOJ4289/","link":"","permalink":"https://20021123.xyz/2018/10/23/BZOJ4289/","excerpt":"","text":"BZOJ4289 Description 给出一个个点条边的无向图，经过一个点的代价是进入和离开这个点的两条边的边权的较大值，求从起点到终点的最小代价。起点的代价是离开起点的边的边权，终点的代价是进入终点的边的边权。 ### Input 第一行两个整数表示共个点条边。 接下来的第到$ M+1行，一行三个整数u,v,w表示有一条从u到v边权为w$的边。 ### Output 一行一个整数表示从号点到号点的最小代价 Sample Input 1234564 51 2 51 3 22 3 12 4 43 4 8 Sample Output 112 Solution 朴素的级别的建图跑最短路肯定事跑不过这道题的，考虑优化边数，发现对于点出发的一条边 ，它到所有点出发的边的边权都是它自己的边权 ,而到所有出发比它大的的边权都是 所以可以利用类似网络流中的补流的方法，先把出发的每个边按边权排序，每条边是边的序号，下同）和它对应的反向边E[j]^1连一条边权为它本身边权的边，然后对于第大的边只用向连边权为的边，向连边权为的边，而起点出发的边和到达终点的边也是分别连到和到就是了 图建完了就最短路随便瞎搞 注意本题要开 ### Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;bits/stdc++.h&gt;#define FIO \"4289\"#define INF 0x3f3f3f#define xx first#define yy second#define pli pair&lt;ll,int&gt;typedef long long ll;const int MOD=1e9+7,MAXN=1e5+5,MAXM=2e5+5;using namespace std;char buf[1&lt;&lt;20]; int bufl,bufr;#define getch ((bufl^bufr||(bufl=0,bufr=fread(buf,1,1&lt;&lt;20,stdin)))?buf[bufl++]:EOF)template &lt;class T&gt;inline void read (T &amp;x) { T f=1; x=0; char ch=getchar(); for (; !isdigit (ch)&amp;&amp;ch!='-'; ch=getchar()); if (ch=='-')f=-1,ch=getchar(); for (; isdigit (ch); ch=getchar())x=x*10+ch-'0'; x*=f;}int n,m,u,v,w,S,T;namespace graph {int head[MAXM&lt;&lt;1],nxt[MAXM*6],to[MAXM*6],va[MAXM*6],ecnt;ll dis[MAXM&lt;&lt;1];inline void add (int u,int v,int w) { nxt[++ecnt]=head[u]; head[u]=ecnt; to[ecnt]=v; va[ecnt]=w;}inline void dijkstra() { memset (dis,INF,sizeof dis); static priority_queue&lt;pli,vector&lt;pli&gt;,greater&lt;pli&gt; &gt; q; q.push (pli (0ll,S)); while (!q.empty()) { pli u=q.top(); q.pop(); if (dis[u.yy]&lt;u.xx) continue; for (int i=head[u.yy]; i; i=nxt[i]) if (u.xx+va[i]&lt;dis[to[i]]) dis[to[i]]=u.xx+va[i],q.push (pli (dis[to[i]],to[i])); } printf (\"%lld\\n\",dis[T]);}};namespace ori {int head[MAXN],to[MAXM&lt;&lt;1],nxt[MAXM&lt;&lt;1],va[MAXM&lt;&lt;1],ecnt=1;inline bool cmp (const int &amp;x,const int &amp;y) { return va[x]&lt;va[y];}inline void add (int u,int v,int w) { nxt[++ecnt]=head[u]; head[u]=ecnt; to[ecnt]=v; va[ecnt]=w;}inline void build() { S=1; T=ecnt+1; static int a[MAXM],t=0; for (int i=1; i&lt;=n; i++) { t=0; for (int j=head[i]; j; j=nxt[j]) a[++t]=j; sort (a+1,a+t+1,cmp); for (int j=1; j&lt;=t; j++) { if (i==1) graph::add (S,a[j],va[a[j]]); if (to[a[j]]==n) graph::add (a[j],T,va[a[j]]); if (j^1) graph::add (a[j],a[j-1],0); if (j^t) graph::add (a[j],a[j+1],va[a[j+1]]-va[a[j]]); graph::add (a[j]^1,a[j],va[a[j]]); } }}};int main() { freopen (FIO\".in\",\"r\",stdin); freopen(FIO\".out\",\"w\",stdout); read (n); read (m); for (int i=1; i&lt;=m; i++) read (u),read (v),read (w),ori::add (u,v,w),ori::add (v,u,w); ori::build(); graph::dijkstra(); return 0;}","categories":[{"name":"BZOJ","slug":"BZOJ","permalink":"https://20021123.xyz/categories/BZOJ/"}],"tags":[{"name":"思维","slug":"思维","permalink":"https://20021123.xyz/tags/%E6%80%9D%E7%BB%B4/"},{"name":"图论","slug":"图论","permalink":"https://20021123.xyz/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"最短路","slug":"最短路","permalink":"https://20021123.xyz/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"BZOJ2144","slug":"BZOJ2144","date":"2018-10-17T10:48:24.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2018/10/17/BZOJ2144/","link":"","permalink":"https://20021123.xyz/2018/10/17/BZOJ2144/","excerpt":"","text":"BZOJ2144 Description 跳跳棋是在一条数轴上进行的。棋子只能摆在整点上。每个点不能摆超过一个棋子。我们用跳跳棋&gt;来做一个简单的游戏：棋盘上有3颗棋子，分别在a，b，c这三个位置。我们要通过最少的跳动把他们的位置移动成x，y，z。（棋子是没有区别的）跳动的规则很简单，任意选一颗棋子，对一颗中轴棋子跳动。跳动后两颗棋子距离不变。一次只允许跳过1颗棋子。 写一个程序，首先判断是否可以完成任务。如果可以，输出最少需要的跳动次数。 ### Input 第一行包含三个整数，表示当前棋子的位置a b c。（互不相同） 第二行包含三个整数，表示目标位置x y z。（互不相同） (输入数据均在内) Output 如果无解，输出一行NO。如果可以到达，第一行输出YES，第二行输出最少步数。 Sample Input 121 2 30 3 5 Sample Output 12YES2 Solution 对于一个三元组作为状态考虑能够转移到的所有状态再来判和是否相同的暴搜肯定是过不了这题的。然后尝试找找规律，如果一个状态中下同 则只能转移到 两种状态，而如果不等的话只能选一边跳(因为只允许跳过一个棋子)，不妨令共有三个转移 冷静分析，什么东西是特殊点两个”转移“普通点三个”转移“？ 二叉树！ （这题来说树就够了） 这一步想通了之后的就简单了 相当于每个状态都是树上的节点，可能转移到与之相邻的节点，特殊点就是两个转移的的点即为根，1问相当于问是否同属一个树，2问相当于求两点之间距离，用求LCA的方法即可。 还有一个问题就是可能两个点之间距离太小如数据可能要很久才会到达一个根，考虑每次转移的两个距离到直到发现相当于每次减了若干小的那个数，可以算出能够减多少次和当前往上跳的次数取min来直接减去以加速这个过程，代码如下： Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;#define FIO \"2144\"#define DBUG(...) fprintf(stderr,__VA_ARGS__)typedef long long ll;const int MOD=1e9+7;const int INF=1e9;const int N=4;using namespace std;template &lt;class T&gt;inline void read (T &amp;x) { T f=1; x=0; char ch=getchar(); for (; !isdigit (ch)&amp;&amp;ch!='-'; ch=getchar()); if (ch=='-')f=-1,ch=getchar(); for (; isdigit (ch); ch=getchar())x=x*10+ch-'0'; x*=f;}struct node { int v[N]; inline int&amp; operator [] (int x) { return v[x]; } inline void rd() { read (v[1]); read (v[2]); read (v[3]); if (v[1]&gt;v[2]) swap (v[1],v[2]); if (v[2]&gt;v[3]) swap (v[2],v[3]); if (v[1]&gt;v[2]) swap (v[1],v[2]); } bool operator == (const node &amp;t)const { return v[1]==t.v[1] &amp;&amp; v[2]==t.v[2] &amp;&amp; v[3]==t.v[3]; } void operator = (node t) { v[1]=t[1]; v[2]=t[2]; v[3]=t[3]; }} a,b;int L,R,mid,cur,d1,d2,ans;node up (node x,int step) { int k1,k2; if ((k1=x[2]-x[1])== (k2=x[3]-x[2])) return x; node ret=x; if (k1&gt;k2) { int delta=min (step, (k1-1)/k2); step-=delta; cur+=delta; ret[2]=ret[2]-delta*k2; ret[3]-=delta*k2; } else { int delta=min (step, (k2-1)/k1); step-=delta; cur+=delta; ret[2]+=delta*k1; ret[1]+=delta*k1; } return step?up (ret,step):ret;}int main() { freopen (FIO\".in\",\"r\",stdin); freopen(FIO\".out\",\"w\",stdout); a.rd(); b.rd(); cur=0; node x=up (a,INF); d1=cur; cur=0; node y=up (b,INF); d2=cur; if (x==y) { puts (\"YES\"); if (d1&lt;d2) swap (d1,d2),swap (a.v[1],b.v[1]),swap (a.v[2],b.v[2]),swap (a.v[3],b.v[3]); a=up (a,d1-d2); L=0; R=d2; ans+=d1-d2; while (L&lt;=R) { mid= (L+R)&gt;&gt;1; if (up (a,mid)==up (b,mid)) R=mid-1; else L=mid+1; } printf (\"%d\",ans+ (L&lt;&lt;1)); } else puts (\"NO\"); return 0;}","categories":[{"name":"BZOJ","slug":"BZOJ","permalink":"https://20021123.xyz/categories/BZOJ/"}],"tags":[{"name":"思维","slug":"思维","permalink":"https://20021123.xyz/tags/%E6%80%9D%E7%BB%B4/"},{"name":"二分","slug":"二分","permalink":"https://20021123.xyz/tags/%E4%BA%8C%E5%88%86/"}]},{"title":"杜教筛与莫比乌斯反演","slug":"杜教筛与莫比乌斯反演","date":"2018-10-13T14:51:13.000Z","updated":"2022-07-12T18:19:50.000Z","comments":true,"path":"2018/10/13/杜教筛与莫比乌斯反演/","link":"","permalink":"https://20021123.xyz/2018/10/13/%E6%9D%9C%E6%95%99%E7%AD%9B%E4%B8%8E%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/","excerpt":"","text":"首先是杜教筛套路式子 求 其中n很大一般 左右导致常规线性筛超时 一般做法： 令 再找一和卷积起来有特殊性质的函数 然后就发现右边等式最后一项除以是要求的答案 而 这玩意可以递归下去 一般会在我们的选择下比较好算 先是一道模板题 BZOJ3944 Description 给定一个正整数N(N&lt;=)求 Input 一共行 第行为数据组数 第行每行一个非负整数N，代表一组询问 Output 一共T行，每行两个用空格分隔的数ans1,ans2 对于这道题可以知道 令对于所以对于所以 具体实现我就使用map了=.= Code 12345678910inline ll solve(int opt,unsigned x){ if (x&lt;MAXN) return opt?sum1[x]:sum0[x]; if (M[opt][x]) return M[opt][x]; ll ret=opt?1ll:1ll*x*(x+1)&gt;&gt;1; for (unsigned i=2,j=2;i&lt;=x;i=j+1){ j=x/(x/i); ret-=solve(opt,x/i)*(j-i+1); } return M[opt][x]=ret;} 傻逼题讲完了T.T BZOJ3930 Description 我们知道，从区间[L,H]（L和H为整数）中选取N个整数，总共有种方案。小z很好奇这样选出的数的最大公约数的规律，他决定对每种方案选出的N个整数都求一次最大公约数，以便进一步研究。然而他很快发现工作量太大了，于是向你寻求帮助。你的任务很简单，小z会告诉你一个整数K，你需要回答他最大公约数刚好为K的选取方案有多少个。由于方案数较大，你只需要输出其除以1000000007的余数即可。 ### Input 输入一行，包含4个空格分开的正整数，依次为N，K，L和H。 ### Output 输出一个整数，为所求方案数。 Sample Input 12 2 2 4 Sample Output 13 HINT 样例解释 所有可能的选择方案：(2, 2), (2, 3), (2, 4), (3, 2), (3, 3), (3, 4), (4, 2), (4, 3), (4, 4) 其中最大公约数等于2的只有3组：(2, 2), (2, 4), (4, 2) 对于100%的数据，，， 一看这数据范围就懵逼了=.= 先都除以就变成求区间的方案了 然后看上去要杜教筛不过可以枚举选的N个数的 一堆差不超过的数的也在以内（易证） 令表示恰好为的方案数表示是的倍数的方案数可以求然后通过反演模板得 怎么求？ 区间任选个数使得都是一个数的倍数=.=快速幂搞搞 并且选的这个数不能全部一样 所以选的方案要减去这个区间的数的个数（刚好这么多种所有数都一样的方案） 还有个特判为区间是否包含1，包含的话有种全部都是时的为 Code 123456789101112inline int getf(int x){ int lt=(L%x)?L/x+1:L/x,rt=R/x; return add(qpow(rt-lt+1,N),-rt+lt-1);}int main(){ pre(); read(N);read(K);read(L);read(R); L=L%K?L/K+1:L/K;R/=K;n=R-L; for (int i=1;i&lt;=n;i++) ans=add(ans,mul(mu[i],getf(i))); if (L&lt;=1 &amp;&amp; 1&lt;=R) ans=add(ans,1);} BZOJ3529 Description 有一张 的数表，其第 行第 列（）的数值为 能同时整除 和 的所有自然数之和。给定 , 计算数表中不大于 的数之和。 ### Input 输入包含多组数据。 输入的第一行一个整数表示测试点内的数据组数 接下来行，每行三个整数，，描述一组数据。 ．， ### Output 对每组数据，输出一行一个整数，表示答案模的值。 Sample Input 12324 4 310 10 5 Sample Output 1220148 好像很难搞=.=不过1e5数据范围可以不用杜教筛 吼啊 写成数学符号就是 令求 啥玩意没听过== 先考虑简化版问题：不考虑a的影响怎么做 首先约数和可以线性筛预处理: 假设是个质数 非常好然后我们可以 令 令 所以答案就是 就可以用根号分块和预处理前缀和水了 然后考虑怎么加入a的限制 emmm N,M才，可以按排序再将a排序，动态维护下前缀和就好了 动态维护前缀和的数据结构比如说树状数组 模可以自然溢出和取与 然后这题就结束了 Code 1234567891011121314151617181920212223242526272829303132333435inline void pre(){ mu[1]=1;t[1]=1;F[1].xx=1; for (int i=2;i&lt;=MAXN;i++){ if (!vis[i]) prime[++cnt]=i,vis[i]=i,F[i].xx=i+1,t[i]=i+1,mu[i]=-1; for (int j=1;j&lt;=cnt &amp;&amp; i*prime[j]&lt;=MAXN;j++){ vis[i*prime[j]]=1; if (i%prime[j]) { mu[i*prime[j]]=-mu[i]; F[i*prime[j]].xx=F[i].xx*1+prime[j]),t[i*prime[j]]=prime[j]+1; }else { mu[i*prime[j]]=0; t[i*prime[j]]=t[i]*prime[j]+1; F[i*prime[j]].xx=F[i].xx/t[i]*t[i*prime[j]]; break; } } } for (int i=1;i&lt;=MAXN;i++) F[i].yy=i;}inline void fadd(int x){ for (int i=1;i*F[x].yy&lt;=MAXN;i++) add(i*F[x].yy,F[x].xx*mu[i]);}//这里省略sort(q+1,q+N+1); sort(F+1,F+MAXN+1);for (int i=1,j=0;i&lt;=N;i++){ while (j&lt;MAXN&amp;&amp;F[j+1].xx&lt;=q[i].a) fadd(++j); n=q[i].n;m=q[i].m; if (n&gt;m) swap(n,m); for (int l=1,r=1;l&lt;=n;l=r+1){ r=min(n/(n/l),m/(m/l)); ans[q[i].id]+=(n/l)*(m/l)*(query(r)-query(l-1)); }} BZOJ4652 Description 牛牛是一个热爱算法设计的高中生。在他设计的算法中，常常会使用带小数的数进行计算。牛牛认为，如果在 进制下，一个数的小数部分是纯循环的，那么它就是美的。现在，牛牛想知道：对于已知的十进制数 和 ，在 k 进制下，有多少个数值上互不相等的纯循环小数，可以用分数 表示,其中 ，且 是整数。一个数是纯循环的，当且仅当其可以写成以下形式：其中， 是一个整数，；对于 ，是 进制下的一位数字。例如，在十进制下，是纯循环的，它可以用 等分数表示；在十进制下，则不是纯循环的，它可以用 等分数表示。需要特别注意的是，我们认为一个整数是纯循环的，因为它的小数部分可以表示成 的循环或是 的循环；而一个小数部分非 的有限小数不是纯循环的。 ### Input 只有一行，包含三个十进制数N,M,K意义如题所述,保证 ### Output 一行一个整数，表示满足条件的美的数的个数。 Sample Input 12 6 10 Sample Output 14 HINT 满足条件的数分别是： 1/1=1.0000…… 1/3=0.3333…… 2/1=2.0000…… 2/3=0.6666…… 1/1 和 2/2 虽然都是纯循环小数，但因为它们相等，因此只计数一次；同样，1/3 和 2/6 也只计数一次。 啥，纯循环小数，没听过0.0 首先这题很显然可以看出是要求一些分子分母互质的数的个数(不互质的会重复出现) 先不管那么多式子写起来 分数在进制下纯循环 还有一个可能是对的不会证得就是对于一个纯循环小数 如果 仍与分母b互质（不然就被约分消掉了），那么应该仍是个纯循环小数（可能是错的我也不会证），然后就说明了是否为纯循环小数在分子分母互质的情况下与分子关系不大（蛤也不敢说是不是完全没有关系） 还是以为分子在进制下找找规律打表 ✔❌✔❌❌❌🐸🐸🐸✔❌✔❌✔❌ 将符合要求的分母写下来嗯没有偶数，但也跟质数不像，然后通过严谨而又细致的猜测推理我们发现这东西应该是要求分母与k互质 具体为什么=.= 证明From 神仙网友 我们先来回想一下，我们是怎样使用除法来判断一个分数 是否是纯循环小数的。显然我们是一路除下去，什么时候出现了相同的余数，那么这个数就是一个循环小数。如果第一个重复的余数是，那么这个数就是纯循环小数。这种方法实际上就是存在一个数，使得： 又由于题目要求值不重复，那么我们可以得到。所以，我们可以推出。所以我们只需即可。 所以事情变成了我们熟悉的样子 求 然后开始乱搞 好啊然后发现这个东西怎么看怎么不好算，长得很像但又多了个所以不能直接合并 所以开始打暴力可能需要分别计算 这里把记上是一会有用 对于上面那个东西由上上道题类似的想法发现 如果那么所有的都与互质 所以只需预处理的数中每个数与k互质的数的个数的前缀和（特别注意这玩意不是， 因为表示小于等于的数中与互质的数个数而不是与互质的数的个数）乘上，对于剩下的不满的再单独计算即可。代码其实就一句int f(int x){return (x/K)*F[K]+F[x%K];} 这么简单搞定了，那么能否同理呢？ 如果是这样这题就不会是最后一道了 很简单的例子比如那么但不一定等于 于是开始硬刚 然后发现当时为对答案没有贡献，所以考虑时 突然发现这式子似曾相识。。。 ！！！ 所以得到 对于k=1时找到最开始的定义 恒成立 是我们最开始讲的第一道=.=然后就完了 然后又变成简单递归题了，复杂度能过 Code 1234567891011121314151617181920212223242526272829map&lt;pii,int&gt;MA;inline int f(int x){return (x/K)*F[K]+F[x%K];}inline int g(int x,int k){//比一般杜教筛多了个参数0.0 if ((k==1 &amp;&amp; x&lt;MAXN)|| !x) return sum[x]; if (MA[pii(x,k)]) return MA[pii(x,k)]; int ret=0; if (k==1){ ret++; for (int i=2,j=2;i&lt;=x;i=j+1){ j=x/(x/i); ret-=(j-i+1)*g(x/i,1); } }else{ for (int i=1;i*i&lt;=k;i++) if (!(k%i)){//这里也只用枚举到sqrt(k)，因为因数是成对的 if (mu[i])ret+=g(x/i,i); //这里防止mu[i]等于0白算一堆 if (mu[k/i] &amp;&amp; (i*i^k)) ret+=g(x/(k/i),k/i);//i*i！=k才再算不然贡献算两遍 } } return MA[pii(x,k)]=ret;}//这里还是省略防止ctrl+c pre(); n=min(N,M); for (int i=1,j=1;i&lt;=n;i=j+1){ j=min(N/(N/i),M/(M/i)); cur=S(j,K); ans+=(ll)(cur-lst)*f(M/i)*(N/i); lst=cur; } 总结 杜教筛是看上去很难实际上也没那么难的东西，希望今天大家都听懂了=.=","categories":[{"name":"总结","slug":"总结","permalink":"https://20021123.xyz/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://20021123.xyz/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"}]},{"title":"My first blog","slug":"my first blog","date":"2018-10-09T14:55:08.000Z","updated":"2022-07-12T17:23:28.000Z","comments":true,"path":"2018/10/09/my first blog/","link":"","permalink":"https://20021123.xyz/2018/10/09/my%20first%20blog/","excerpt":"","text":"新开的博客，日常鸽0.0","categories":[{"name":"随笔","slug":"随笔","permalink":"https://20021123.xyz/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://20021123.xyz/tags/%E9%9A%8F%E7%AC%94/"}]}],"categories":[{"name":"总结","slug":"总结","permalink":"https://20021123.xyz/categories/%E6%80%BB%E7%BB%93/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://20021123.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"操作系统","slug":"操作系统","permalink":"https://20021123.xyz/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"数据库","slug":"数据库","permalink":"https://20021123.xyz/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"图形学","slug":"图形学","permalink":"https://20021123.xyz/categories/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"软件工程","slug":"软件工程","permalink":"https://20021123.xyz/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"https://20021123.xyz/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"机器学习","slug":"机器学习","permalink":"https://20021123.xyz/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"概率论与数理统计","slug":"概率论与数理统计","permalink":"https://20021123.xyz/categories/%E6%A6%82%E7%8E%87%E8%AE%BA%E4%B8%8E%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"},{"name":"教程","slug":"教程","permalink":"https://20021123.xyz/categories/%E6%95%99%E7%A8%8B/"},{"name":"大学物理","slug":"大学物理","permalink":"https://20021123.xyz/categories/%E5%A4%A7%E5%AD%A6%E7%89%A9%E7%90%86/"},{"name":"线性代数","slug":"线性代数","permalink":"https://20021123.xyz/categories/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"离散数学","slug":"离散数学","permalink":"https://20021123.xyz/categories/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"微积分","slug":"微积分","permalink":"https://20021123.xyz/categories/%E5%BE%AE%E7%A7%AF%E5%88%86/"},{"name":"LOJ","slug":"LOJ","permalink":"https://20021123.xyz/categories/LOJ/"},{"name":"codeforces","slug":"codeforces","permalink":"https://20021123.xyz/categories/codeforces/"},{"name":"随笔","slug":"随笔","permalink":"https://20021123.xyz/categories/%E9%9A%8F%E7%AC%94/"},{"name":"洛谷","slug":"洛谷","permalink":"https://20021123.xyz/categories/%E6%B4%9B%E8%B0%B7/"},{"name":"HDU","slug":"HDU","permalink":"https://20021123.xyz/categories/HDU/"},{"name":"UOJ","slug":"UOJ","permalink":"https://20021123.xyz/categories/UOJ/"},{"name":"SPOJ","slug":"SPOJ","permalink":"https://20021123.xyz/categories/SPOJ/"},{"name":"BZOJ","slug":"BZOJ","permalink":"https://20021123.xyz/categories/BZOJ/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://20021123.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"操作系统","slug":"操作系统","permalink":"https://20021123.xyz/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"数据库","slug":"数据库","permalink":"https://20021123.xyz/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"数学","slug":"数学","permalink":"https://20021123.xyz/tags/%E6%95%B0%E5%AD%A6/"},{"name":"图形学","slug":"图形学","permalink":"https://20021123.xyz/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"软件工程","slug":"软件工程","permalink":"https://20021123.xyz/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"},{"name":"计算机体系结构","slug":"计算机体系结构","permalink":"https://20021123.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"},{"name":"计算机组成原理","slug":"计算机组成原理","permalink":"https://20021123.xyz/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"name":"AI","slug":"AI","permalink":"https://20021123.xyz/tags/AI/"},{"name":"搞机","slug":"搞机","permalink":"https://20021123.xyz/tags/%E6%90%9E%E6%9C%BA/"},{"name":"Linux","slug":"Linux","permalink":"https://20021123.xyz/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://20021123.xyz/tags/Ubuntu/"},{"name":"obs","slug":"obs","permalink":"https://20021123.xyz/tags/obs/"},{"name":"KDE","slug":"KDE","permalink":"https://20021123.xyz/tags/KDE/"},{"name":"物理","slug":"物理","permalink":"https://20021123.xyz/tags/%E7%89%A9%E7%90%86/"},{"name":"图论","slug":"图论","permalink":"https://20021123.xyz/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"LCT","slug":"LCT","permalink":"https://20021123.xyz/tags/LCT/"},{"name":"NTT","slug":"NTT","permalink":"https://20021123.xyz/tags/NTT/"},{"name":"FFT","slug":"FFT","permalink":"https://20021123.xyz/tags/FFT/"},{"name":"计数","slug":"计数","permalink":"https://20021123.xyz/tags/%E8%AE%A1%E6%95%B0/"},{"name":"容斥","slug":"容斥","permalink":"https://20021123.xyz/tags/%E5%AE%B9%E6%96%A5/"},{"name":"随笔","slug":"随笔","permalink":"https://20021123.xyz/tags/%E9%9A%8F%E7%AC%94/"},{"name":"扩域","slug":"扩域","permalink":"https://20021123.xyz/tags/%E6%89%A9%E5%9F%9F/"},{"name":"思维","slug":"思维","permalink":"https://20021123.xyz/tags/%E6%80%9D%E7%BB%B4/"},{"name":"字符串","slug":"字符串","permalink":"https://20021123.xyz/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"凸包","slug":"凸包","permalink":"https://20021123.xyz/tags/%E5%87%B8%E5%8C%85/"},{"name":"DP","slug":"DP","permalink":"https://20021123.xyz/tags/DP/"},{"name":"动态DP","slug":"动态DP","permalink":"https://20021123.xyz/tags/%E5%8A%A8%E6%80%81DP/"},{"name":"错排","slug":"错排","permalink":"https://20021123.xyz/tags/%E9%94%99%E6%8E%92/"},{"name":"水题","slug":"水题","permalink":"https://20021123.xyz/tags/%E6%B0%B4%E9%A2%98/"},{"name":"最短路","slug":"最短路","permalink":"https://20021123.xyz/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"},{"name":"二分","slug":"二分","permalink":"https://20021123.xyz/tags/%E4%BA%8C%E5%88%86/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"https://20021123.xyz/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"}]}