---
title: 线性基
date: 2019-10-21 20:58:01
tags: 线性基
mathjax: true
categories: 总结
password: buzhibujue

---

# 线性基

---

### 求最大值

暴力从高到低位枚举，如果加入这一位的基答案会更大则加入

---

### 求异或值第 $k$ 小

算出所有线性基后再对于每一个有基的位消元使得没有其他的基这一位为 $1$ 。最后找出所有这样的基从小到大依次标号为 $a_0,a_1,a_2\cdots a_r$ 。问第 $k$ 小的时候就``for``一遍 $i$ 当 $k$ 第 $i$ 项为 $1$ 时就异或上 $a_i$ 

Q：为什么多了对每一位有基的位消元这一步？

A：因为这样就能保证对于所有 $i>j$ ， $a_i\oplus a_j>a_i$ 且一旦异或上一个 $a_i$ 那么前面的 $a_0,a_1,\cdots a_{i-1}$ 的一共 $2^{i}$ 种选/不选方式的值都不如这里选了，当前的排名自然就 $+=2^{i}$ ，于是这样做就是可行的

**注意特判 $0$ 如果能表示出来则 $k$ 要减一**

---

### 求交

首先两个线性基的交也是个线性基，因为比如 $X=a_1\oplus a_2=b_1\oplus b_3$ 且 $Y=a_2\oplus a_3=b_2\oplus b_4$ 那么一定有 $X\oplus Y=(a_1\oplus a_2) \oplus (a_2\oplus a_3)=(b_1\oplus b_3)\oplus(b_2\oplus b_4)$ （即如果两个线性基都能表示出 $X$ 和 $Y$ 那么它们也一定都能表示出 $X\oplus Y$ ）

然后有个引理就是：线性基 $C$ 是线性基 $A$ 和 $B$ 的交当且仅当 $A$ 和 $B\backslash C$ 也可组成一个线性基（即 $A$ 和 $B\backslash C$ 线性无关）

**充分性：**

即如果 $C$ 是 $A$ 和 $B$ 的交那么 $A$ 和 $B\backslash C$ 线性无关。考虑如果 $A$ 和 $B\backslash C$ 线性相关的话就相当于 $A$ 和 $B\backslash C$ 还有交，与条件矛盾。

**必要性：**

即如果 $A$ 和 $B\backslash C$ 线性无关则 $C$ 是 $A$ 与 $B$ 的交。考虑一个 $c$ 如果是 $A$ 和 $B$ 的交且不能用 $C$ 表示，那么即 $C$ 和 $c$ 线性相关，又因为 $B$ 能表示 $C$ 那么一定是由 $B\backslash C$ 那部分表示的 $c$ ，并且 $A$ 也可以表示出 $c$ 那么 $A$ 与 $B\backslash C$ 都能表示出 $c$ ，所以两者不是线性无关与条件矛盾。 

然后考虑依次加入 $B$ 中每个基 $B_i$ 且保证加入前 $A$ 和 $B_{1,2,\cdots i-1}\backslash C$ 线性无关：

- 如果它不能能够被 $A$ 和 $B_{1,2,\cdots i-1}$ 表示则它**一定不是** $A$ 和 $B$ 的交可以不管。（它属于 $B\backslash C$ ）
- 如果它可以被 $A$ 和 $B_{1,2,\cdots i-1}$ 表示则我们考虑换基。把 $B_i$ 用 $A\bigcup (B\backslash C)$ 表示，比如 $B_4=A_1\oplus A_2\oplus B_0\oplus B_2$ （这时候有交出现了： $A_1\oplus A_2=B_4\oplus B_0\oplus B_2$ 且不能在 $C$ 中直接加入 $B_4$ 因为单凭 $A$ 无法表示 $B_4$ ）我们把 $B_4$ 换成 $B_4\oplus B_0\oplus B_2$  再加入 $C$ 中，那么可以发现 $B$ 能表示的东西不变，且此时 $A$ 与 $B\backslash (C\cup (B_4\oplus B_0\oplus B_2))$ 又线性无关了 

```c++
struct Base{
  ll r[N];
  inline base(){memset(r,0,sizeof r);}
  inline void ins(ll x){
    for(int i=N-1;~i;i--)if(x>>i&1){
      if(!r[i]){
        r[i]=x;
        return;
      }else x^=r[i];
    }
  }
  inline const int& operator [] (const int &x)const{return r[x];}
  inline int& operator [](int x){return r[x];}
  inline base operator +(const base &t)const{
    base b,c=*this,ans;
    for(int i=0;i<N;i++)if(t[i]){
      ll v=t[i],vb=t[i],flag=1;
      for(int j=N-1;~j;j--)if(v>>j&1){
        if(c[j]){
          v^=c[j];
          vb^=b[j];
        }else{
          c[j]=v;
          b[j]=vb;
          flag=0;
          break;
        }
      }
      if(flag) ans.ins(vb);
    }
    return ans;
  }
};
```

---

### 删除

（保证删除的向量一定之前插入过）

#### 方法一

离线，以时间为下标线段树分治，但要事先知道每个向量的出现时间段

#### ~~方法二~~

~~离线，对每个向量记录他还有多久被删去，插入时如果比这一位的基后删则交换一下，把的这个作为基并继续插入之前这一位的基，删除时看一下剩下的是不是它，是的话直接删就行~~ ~~这玩意想半天觉得很假发现确实是假的（比如先插一个 $10$ 和 $11$ 现在就剩个 $10$ 和 $01$ ，再把 $10$ 删了应该剩下 $11$ 实际上剩下 $01$ ）怪不得 http://uoj.ac/problem/91 只有两个人的题解写这个还写的基本上一模一样……都 $97$ 了~~

实际上挂是那两个人写假了正确性是没问题的比如插入 $11$ 和 $10$ 先删除 $10$ 那么插入 $10$ 时会把 $11$ 换成 $10$ 再插入 $10\oplus 11=01$  。删除时实际上是什么也不做，查询时只考虑删除时间大于当前时间的基向量。

然后有个问题就是这样做的正确性：大概是考虑一个被删除的向量，考虑它出现的最低的 $1$ 个基向量（也即是它最后插入的位置）比它低的位一定不含它（因为已经在这里插入了），比它高的位中

- 不包含它的，删不删除它 不影响
- 包含他，意味着之前存在某个时间当前这一位 $x$ 的被删除时间晚于包含它的那一位 $y$ 包含的某个向量，那之后被删除的这一位跑下来肯定是因为有比其更晚被删除的加入，那么 $x$　被换后往下走时一定会经过 $y$　且被删除时间晚于 $y$ 那么就应该是换成 $y$ 往下走，这与 $y$　最终位置比 $x$　位置高矛盾，所以得到不存在比当前这一位高的含有这个被删除的向量

（只是当前这一位基可能是由以前的向量和这一个要被删除的向量构成，但还是只有它这一位基含有这个向量，只删除这一个基就行）

例题：[UOJ91](http://uoj.ac/problem/91) 

> ### Description
> 我有一个数列 $a_1,a_2,…,a_n$ 每个 $a_i$ 都是小于 $2^m$ 的非负整数。
> 现在请您实现三种操作，格式说明如下：
> $1$ $x$ $y$ $w$ ：对于所有 $x≤i≤y$ ，将 $a_i$ 修改为 $a_i\ xor\ w$ 。其中 $w$ 是一个小于 $2^m$ 的非负整数。
> $2$ $x$ $y$ $w$ ：对于所有 $x≤i≤y$ ，将 $a_i$ 修改为 $w$。其中 $w$ 是一个小于 $2^m$ 的非负整数。
> 33：从 $a_1,a_2,…,a_n$ 中选出若干个数，使得选出的数异或和最大。请输出这个最大值。
> 这里 $xor$ 表示按位异或运算，$x_1,x_2,…,x_l$ 的异或和是指 $x_1\ xor\ x_2\ xor\ …\ xor\ x_l$ 。
>
> ### Constraints
>
> $n,m,q\leq 2000$

### Solution

 首先原序列差分后的线性基和原序列的线性基等价

那么每次操作就只有修改两个位置或者删除一段区间的向量

把修改看成删除再插入，即把上一个当前位置的向量的出现时间右端点改成当前 $tim-1$ ，把插入新的值的出现时间设为 $tim\sim q$

离线后按照上面的做即可，复杂度　$O(\frac{nmq}{\omega})$

```c++
#include<bits/stdc++.h>
#define FIO "uoj91"
#define ll long long

using namespace std;

const int N=2e3+5,M=N<<2;

#define bs bitset<N>

int n,m,q;
bs a[N],b[N];
char s[N];

inline bs rd(){
  bs a;
  scanf("%s",s);
  reverse(s,s+m);
  for(int i=0;i<m;i++)a[i]=s[i]-'0';
  return a;
}

int l[M],r[M],h[N],cnt;
bs w[M];
inline void add(int id,int tim){
  ++cnt;
  w[cnt]=b[id];
  l[cnt]=tim;
  r[cnt]=q;
  r[h[id]]=tim-1;
  h[id]=cnt;
}

int id[M],rig[N];
//!!! id -> M
inline bool cmp(const int &a,const int &b){
  return l[a]<l[b];
}

bs bas[N];
inline void ins(bs v,int r,int l){
  for(int i=m-1;~i;i--)if(v[i]){
    if(rig[i]<l){rig[i]=r;bas[i]=v;return;}
    if(rig[i]<r)swap(rig[i],r),swap(v,bas[i]);
    v^=bas[i];
  }
}

inline bs qry(int tim){
  bs ret;
  for(int i=m-1;~i;i--)if(rig[i]>=tim&&!ret[i])
    ret^=bas[i];
  return ret;
}

bool isq[N];

int main(){
  freopen(FIO".in","r",stdin);
  freopen(FIO".out","w",stdout);
  scanf("%d%d%d",&n,&m,&q);
  for(int i=1;i<=n;i++){
    a[i]=rd();
    b[i]=a[i]^a[i-1];
    add(i,1);
  }
  for(int i=1;i<=q;i++){
    int opt,x,y;
    bs w;
    scanf("%d",&opt);
    switch(opt){
      case 1:{
               scanf("%d%d",&x,&y);w=rd();
               for(int j=x;j<=y;j++)
                 a[j]^=w;
               b[x]^=w;
               add(x,i);
               if(y^n){
                b[y+1]^=w;
                add(y+1,i);
               }
               break;
             }
      case 2:{
               scanf("%d%d",&x,&y);w=rd();
               for(int j=x;j<=y;j++){
                 a[j]=w;
                 //!!! = not ^=
                 if(j>x&&h[j]){
                   r[h[j]]=i-1;
                   b[j].reset();
                   h[j]=0;
                 }
                }
               b[x]=w^a[x-1];
               add(x,i);
               if(y^n){
                b[y+1]=w^a[y+1];
                add(y+1,i);
               }
               break;
             }
      case 3:{
               isq[i]=1;
               break;
             }
    }
  }

  for(int i=1;i<=cnt;i++)id[i]=i;
  sort(id+1,id+cnt+1,cmp);

  for(int i=1,j=1;i<=q;i++){
    while(j<=cnt&&l[id[j]]<=i)ins(w[id[j]],r[id[j]],i),j++;
    if(isq[i]){
      bs ans=qry(i);
      for(int i=m-1;~i;i--)printf("%d",(int)ans[i]);
      puts("");
    }
  }

  return 0;
}
```


### 方法三

以上两种方法都需要离线，我们考虑一个在线做法：
对于每个**基向量**，维护其是由那些**向量**构成的（如果插入失败即这个向量能用之前的一些向量表示同样记录它是由那些表示的，即记录哪些之前的向量异或当前的可以得到 $0$ ）

每次删除向量 $v_i$ 时考虑分类讨论

- 如果存在之前的某个 $0$ 的构成包含 $v_i$ ，则用构成那个 $0$ 的其他的向量代替出现在其他**基**或其他 $0$ 向量中的 $v_i$ 
比如之前有 $b_1\oplus a_2\oplus a_4=0$ （其中 $a$ 是某个基的向量， $b$ 是某个插入失败的向量）那么比如要删除 $a_2$ ，由左式得到 $a_2=b_1\oplus a_4$ ，把所有 $a_2$ 出现的地方换成 $a_4\oplus b_1$ 再删掉这个 $0$ 即可（这个 $b_1$ 就相当于代替了 $a_2$ 的作用，并且由于 $a_2$ 被删除，这个式子不能再用来把其他项换回来）（比如把 $a_4$ 换成 $a_4\oplus b_1$ ）
- 如果不存在某个包含 $v_i$ 的 $0$ 可以被 $a$ 和 $b$ 表示出来，那么 $v_i$ 被删除后一定会降秩。找到**最低**的包含 $v_i$ 的基向量，把其他高于它也包含 $v_i$ 的异或上这一个基向量（它们对应的向量的构成也要异或），这样其他的基所表示的东西不变（一个基向量异或另一个基向量前后总的线性空间大小肯定不变），且只有这一个基向量含有 $v_i$ 了，那么就只删除这一个基就行。（这里不用考虑 $0$ 向量因为到了这一步就说明没有包含 $v_i$ 的 $0$ ）

刚才那题的用这个写法实现在线，可以见　https://www.cnblogs.com/daklqw/p/11545965.html

然后有道强制在线的题：[UOJ453]( http://uoj.ac/problem/453)

> ### Description
>
> 给定 $p\times s$ 的 $01$ 矩阵 $C$ ，求有多少对分别是 $p\times q$  和 $q\times s$ 的 $01$ 矩阵 $A$ 、 $B$ 满足 $AB=C$
>
> 有 $m$ 组询问， 每个询问会对 $C$ 的一行进行修改并求答案，强制在线
>
> ### Constraints
>
> $p,q,s,m\leq 1000$

### Solution

左乘一个矩阵相当于对矩阵进行行线性变换，右乘一个矩阵相当于对矩阵进行列线性变换

发现答案只与 $C$ 的秩有关，两个秩相同的 $C$ 的答案可以相互转换一一对应，算出所有 $C$ 的秩为 $r$ 的答案之和再除以秩为 $r$ 的矩阵个数就是答案

对于一特定的秩为 $r$ 的矩阵 $A$ 和特定的矩阵 $C$ ，矩阵 $B$ 的每一列就对应一个 $A$ 线性变换到 $C$ 的那一列的方法，对于特定的 $A$ 和 $C$ 的这一列， $B$ 这一列的方案数是 $2^{q-r}$ 。 $B$ 每一列都是这样，一共有 $s$ 列，得到对于特定的矩阵 $A$ 和 $C$ ， $B$ 的方案数是 $2^{(q-r)s}$ 

设 $n$ 行 $m$ 列秩为 $r$ 的矩阵数为 $f_{n,m,r}$ 

转移大概是 $f_{n,m,r}=f_{n,m-1,r}\times 2^{r}+f_{n,m-1,r-1}\times (2^{n}-2^{r-1})$

但我们知道对于 $p\times q$ 秩为 $r$ 的矩阵 $A$ ，进行列线性变换后变成 $p\times s$ 的矩阵时秩不一定还等于 $r$

考虑计算 $A$ 的秩是 $x$ 时有多少种秩为 $r$ 的 $C$ 可以由  $A$ 经过列线性变换得到

有个不会证的定理

> $m\times n$ 的列满秩（秩为 $n$ ）矩阵乘上 $n\times k$ 的矩阵得到的 $m\times k$ 的矩阵的秩等于这个 $n\times k$ 的矩阵的秩

把左边列满秩的 $p$ 行 $x$ 列矩阵看成是 $p$ 行 $s$ 列（只是最后有 $s-x$ 列全是 $0$ ），那么考虑所有列的线性变换就是一个任意的 $s$ 行 $s$ 列的矩阵。但是（线性变换矩阵的）最后的 $s-x$ 行没有意义因为左边只有前 $x$ 列有值，最后 $s-x$ 列全是 $0$ 。所以线性变换矩阵只有前 $x$ 行有用相当于一个 $x$ 行 $s$ 列的矩阵。由于我们要算乘出来 $p$ 行 $s$ 列秩为 $r$ 的矩阵有多少种情况，由之前的定理得到就是这个 $x$ 行 $s$ 列的秩为 $r$ 的情况数。

所以答案就是 $\sum_{x=r}^{\min(p,q)}\frac{f_{p,q,x}\times 2^{(q-x)s}\times f_{x,s,r}}{f_{p,s,r}}$

$C$ 带修改就是动态维护线性基的秩，照着上面的搞法做就行

可以记录一个 $pos_x=i,rnk_i=x$ 表示第 $x$ 个基向量（这个 $x$ 只是从前往后的第 $x$ 个，是个标号跟它是哪一位的基无关）在第 $i$ 位和第 $i$ 位的基向量放在了第 $x$ 个。

如果 $pos_x=0$ 就代表第 $x$ 个基向量没有插入任何一位，用它来替换其他的位置就行（相当于不用分类讨论，每次只要找含有 $j$ 的 $pos$ 最小的 $x$ 把它删了就行，如果它是个基再把秩数减一即可）

```c++
#include<bits/stdc++.h>
#define ll long long
#define FIO "uoj453"
using namespace std;

const int N=1e3+5,MOD=1000000007;

inline int add(int a,const int &b){return (a+=b)>=MOD?a-MOD:a;}
inline int sub(int a,const int &b){return (a-=b)<   0?a+MOD:a;}
inline int mul(const int &a,const int &b){return 1ll*a*b%MOD;}
inline int& inc(int &a,const int &b){return a=add(a,b);}
inline int& dec(int &a,const int &b){return a=sub(a,b);}
inline int& pro(int &a,const int &b){return a=mul(a,b);}
inline int qpow(int a,int b){int c=1;for(;b;b>>=1,pro(a,a))if(b&1)pro(c,a);return c;}

#define bs bitset<N>

int p,q,s,m,k;
int bin[N];
int ans[N],fp[N][N],fs[N][N];
bs C[N];

int rk;

inline bs rd(){
  bs ret;
  for(int i=1,x;i<=s;i++){
    scanf("%d",&x);
    ret[i]=x;
  }
  return ret;
}

bs id[N];
int pos[N],rnk[N];

inline void ins(int x){
  pos[x]=0;
  for(int i=s;i;i--)if(C[x][i]){
    if(!rnk[i]){
      rnk[i]=x;
      rk++;
      pos[x]=i;
      break;
    }
    id[x]^=id[rnk[i]];
    C[x]^=C[rnk[i]];
  }
}

inline int erase(int x){
  int mn=s+1,now=0;
  for(int i=1;i<=p;i++)if(id[i][x]&&pos[i]<mn)now=i,mn=pos[i];
  for(int i=1;i<=p;i++)if(id[i][x]&&i^now)C[i]^=C[now],id[i]^=id[now];
  if(pos[now])rk--,rnk[pos[now]]=0,pos[now]=0;
  C[now].reset();id[now].reset();
  return now;
}

int main(){
  freopen(FIO".in","r",stdin);
  freopen(FIO".out","w",stdout);
  scanf("%d%d%d%d%d",&p,&q,&s,&m,&k);

  for(int i=1;i<=p;i++)
    C[i]=rd(),id[i][i]=1,ins(i);

  bin[0]=1;for(int i=1;i<N;i++)bin[i]=mul(bin[i-1],2);

  fp[0][0]=fs[0][0]=1;
  for(int i=1;i<N;i++){
    for(int j=0;j<=min(i,p);j++){
      fp[i][j]=mul(fp[i-1][j],bin[j]);
      if(j)inc(fp[i][j],mul(fp[i-1][j-1],sub(bin[p],bin[j-1])));
    }
    for(int j=0;j<=min(i,s);j++){
      fs[i][j]=mul(fs[i-1][j],bin[j]);
      if(j)inc(fs[i][j],mul(fs[i-1][j-1],sub(bin[s],bin[j-1])));
    }
  }

  for(int r=1;r<=min(p,q);r++){
    for(int x=r;x<=min(p,q);x++)
      inc(ans[r],mul(fp[q][x],mul(fs[x][r],qpow(2,(q-x)*s))));
    pro(ans[r],qpow(fp[s][r],MOD-2));
  }

  int lst;

  printf("%d\n",lst=ans[rk]);

  while(m--){
    int j,x;
    scanf("%d",&j);
    j=j^(k*lst);
    x=erase(j);
    C[x]=rd();
    id[x][j]=1;
    ins(x);
    printf("%d\n",lst=ans[rk]);
  }

  return 0;
}
```

---

### 只选偶数的线性基

比如一个矩阵只能选偶数个位置可以将所有横着或者竖着相邻的位置对插入这样一定异或出来是有偶数个有值。如果要选奇数个就最开始加入一个只有一个格子的。

---

### 对于有特殊性质的线性基的奇怪写法

比如一列最多只有两个 $1$ 的情况每个向量只能选或不选，求最后异或出来为 $0$ 的方案数

把有两个 $1$ 的看成是两个对应列连的一条边，把只有一个 $1$ 的看成是对应点上的权值 $+1$ 

最后会形成若干个连通块使用并查集维护每个连通块的点数、边数和权值。

假设现在有一个 $n$ 个点 $m$ 条边点上的权值和是 $k$ 的连通块，分类讨论：

- $k=0$ ：那么这个连通块的矩阵就不满秩，只能像上面所说的表示出所有选偶数的情况。这时我们取 $m$ 条边的 $n-1$ 条形成一个树（必定能找到不然就不是一个连通块），其他任意的边的加入都可以由这 $n-1$ 条树边对应的向量异或出来，所以答案就是除了 $n-1$ 条边的其他任选的方案： $2^{m-(n-1)}$ 

- $k\neq 0$ ：除了那 $n-1$ 条可以任意表示剩余 $m-(n-1)$ 条边的情况外还有 $k$ 个可以单点翻转的，但是不能翻转奇数个否则无法消成 $0$ ，而任意偶数次都可以。我们可以任选前 $k-1$ 个单点的情况最后一个根据前面的奇偶性来选/不选，所以答案是 $2^{m-(n-1)}\times 2^{k-1}$ 
